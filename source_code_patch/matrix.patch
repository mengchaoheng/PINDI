diff --git a/README.md b/README.md
index 1cc31a5..6fa5cd3 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,6 @@
-# matrix [![Build Status](https://travis-ci.org/PX4/Matrix.svg?branch=master)](https://travis-ci.org/PX4/Matrix) [![Coverage Status](https://coveralls.io/repos/PX4/Matrix/badge.svg?branch=master&service=github)](https://coveralls.io/github/PX4/Matrix?branch=master)
+# matrix
+
+ARCHIVED - PX4-Matrix is now maintained within PX4-Autopilot. https://github.com/PX4/PX4-Autopilot/tree/4a3d64f1d76856d22323d1061ac6e560efda0a05/src/lib/matrix
 
 A simple and efficient template based matrix library.
 
diff --git a/matrix/LeastSquaresSolver.hpp b/matrix/LeastSquaresSolver.hpp
index 1f518b4..1550356 100644
--- a/matrix/LeastSquaresSolver.hpp
+++ b/matrix/LeastSquaresSolver.hpp
@@ -118,7 +118,7 @@ public:
 
         // size_t is unsigned and wraps i = 0 - 1 to i > N
         for (size_t i = N - 1; i < N; i--) {
-            printf("i %d\n", static_cast<int>(i));
+            // printf("i %d\n", static_cast<int>(i));
             x(i) = qtbv(i);
             for (size_t r = i+1; r < N; r++) {
                 x(i) -= _A(i,r) * x(r);
diff --git a/matrix/PseudoInverse.hpp b/matrix/PseudoInverse.hpp
index 2463529..1590efe 100644
--- a/matrix/PseudoInverse.hpp
+++ b/matrix/PseudoInverse.hpp
@@ -21,31 +21,38 @@ namespace matrix
  * Courrieu, P. (2008). Fast Computation of Moore-Penrose Inverse Matrices, 8(2), 25–29. http://arxiv.org/abs/0804.4809
  */
 template<typename Type, size_t M, size_t N>
-Matrix<Type, N, M> geninv(const Matrix<Type, M, N> & G)
+bool geninv(const Matrix<Type, M, N> & G, Matrix<Type, N, M>& res)
 {
     size_t rank;
     if (M <= N) {
         SquareMatrix<Type, M> A = G * G.transpose();
         SquareMatrix<Type, M> L = fullRankCholesky(A, rank);
 
-        SquareMatrix<Type, M> LtL = L.transpose() * L;
+        A = L.transpose() * L;
         SquareMatrix<Type, M> X;
-        if (!inv(LtL, X, rank)) {
-            return Matrix<Type, N, M>(); // LCOV_EXCL_LINE -- this can only be hit from numerical issues
+        if (!inv(A, X, rank)) {
+            res = Matrix<Type, N, M>();
+            return false; // LCOV_EXCL_LINE -- this can only be hit from numerical issues
         }
-        return G.transpose() * L * X * X * L.transpose();
+        // doing an intermediate assignment reduces stack usage
+        A = X * X * L.transpose();
+        res = G.transpose() * (L * A);
 
     } else {
         SquareMatrix<Type, N> A = G.transpose() * G;
         SquareMatrix<Type, N> L = fullRankCholesky(A, rank);
 
-        SquareMatrix<Type, N> LtL = L.transpose() * L;
+        A = L.transpose() * L;
         SquareMatrix<Type, N> X;
-        if(!inv(LtL, X, rank)) {
-            return Matrix<Type, N, M>(); // LCOV_EXCL_LINE -- this can only be hit from numerical issues
+        if(!inv(A, X, rank)) {
+            res = Matrix<Type, N, M>();
+            return false; // LCOV_EXCL_LINE -- this can only be hit from numerical issues
         }
-        return L * X * X * L.transpose() * G.transpose();
+        // doing an intermediate assignment reduces stack usage
+        A = X * X * L.transpose();
+        res = (L * A) * G.transpose();
     }
+    return true;
 }
 
 
diff --git a/matrix/Quaternion.hpp b/matrix/Quaternion.hpp
index 309cd53..ddcbdf9 100644
--- a/matrix/Quaternion.hpp
+++ b/matrix/Quaternion.hpp
@@ -325,6 +325,78 @@ public:
         return v * q  * Type(0.5);
     }
 
+    /**
+      * Computes the quaternion exponential of the 3D vector u
+      * as proposed in
+      * [1] Sveier A, Sjøberg AM, Egeland O. "Applied Runge–Kutta–Munthe-Kaas Integration
+      *     for the Quaternion Kinematics".Journal of Guidance, Control, and Dynamics. 2019
+      *
+      * return a quaternion computed as
+      * expq(u)=[cos||u||, sinc||u||*u]
+      * sinc(x)=sin(x)/x in the sin cardinal function
+      *
+      * This can be used to update a quaternion from the body rates
+      * rather than using
+      * qk+1=qk+qk.derivative1(wb)*dt
+      * we can use
+      * qk+1=qk*expq(dt*wb/2)
+      * which is a more robust update.
+      * A re-normalization step might necessary with both methods.
+      *
+      * @param u 3D vector u
+      */
+    static Quaternion expq(const Vector3<Type> &u)
+    {
+        const Type tol = Type(0.2);           // ensures an error < 10^-10
+        const Type c2 = Type(1.0 / 2.0);      // 1 / 2!
+        const Type c3 = Type(1.0 / 6.0);      // 1 / 3!
+        const Type c4 = Type(1.0 / 24.0);     // 1 / 4!
+        const Type c5 = Type(1.0 / 120.0);    // 1 / 5!
+        const Type c6 = Type(1.0 / 720.0);    // 1 / 6!
+        const Type c7 = Type(1.0 / 5040.0);   // 1 / 7!
+
+        Type u_norm = u.norm();
+        Type sinc_u, cos_u;
+
+        if (u_norm < tol) {
+            Type u2 = u_norm * u_norm;
+            Type u4 = u2 * u2;
+            Type u6 = u4 * u2;
+
+            // compute the first 4 terms of the Taylor serie
+            sinc_u = Type(1.0) - u2 * c3 + u4 * c5 - u6 * c7;
+            cos_u = Type(1.0) - u2 * c2 + u4 * c4 - u6 * c6;
+        } else {
+            sinc_u = Type(sin(u_norm) / u_norm);
+            cos_u = Type(cos(u_norm));
+        }
+        Vector<Type, 3> v = sinc_u * u;
+        return Quaternion<Type> (cos_u, v(0), v(1), v(2));
+    }
+
+    /** inverse right Jacobian of the quaternion logarithm u
+      * equation (20) in reference
+      * [1] Sveier A, Sjøberg AM, Egeland O. "Applied Runge–Kutta–Munthe-Kaas Integration
+      *     for the Quaternion Kinematics".Journal of Guidance, Control, and Dynamics. 2019
+      *
+      * This can be used to update a quaternion kinematic cleanly
+      * with higher order integration methods (like RK4) on the quaternion logarithm u.
+      *
+      * @param u 3D vector u
+      */
+    static Dcm<Type> inv_r_jacobian (const Vector3<Type> &u)
+    {
+        const Type tol = Type(1.0e-4);
+        Type u_norm = u.norm();
+        Dcm<Type> u_hat = u.hat();
+
+        if (u_norm < tol) { 	// result smaller than O(||.||^3)
+            return Type(0.5) * (Dcm<Type>() + u_hat + (Type(1.0 / 3.0) + u_norm * u_norm / Type(45.0)) * u_hat * u_hat);
+        } else {
+            return Type(0.5) * (Dcm<Type>() + u_hat + (Type(1.0) - u_norm * Type(cos(u_norm) / sin(u_norm))) / (u_norm * u_norm) * u_hat * u_hat);
+        }
+    }
+
     /**
      * Invert quaternion in place
      */
diff --git a/matrix/Slice.hpp b/matrix/Slice.hpp
index 6ab54c0..f98ac48 100644
--- a/matrix/Slice.hpp
+++ b/matrix/Slice.hpp
@@ -262,6 +262,40 @@ public:
         return norm_squared() > testVal*testVal;
     }
 
+    Type max() const
+    {
+        Type max_val = (*this)(0,0);
+
+        for (size_t i = 0; i < P; i++) {
+            for (size_t j = 0; j < Q; j++) {
+                Type val = (*this)(i,j);
+
+                if (val > max_val) {
+                    max_val = val;
+                }
+            }
+        }
+
+        return max_val;
+    }
+
+    Type min() const
+    {
+        Type min_val = (*this)(0,0);
+
+        for (size_t i = 0; i < P; i++) {
+            for (size_t j = 0; j < Q; j++) {
+                Type val = (*this)(i,j);
+
+                if (val < min_val) {
+                    min_val = val;
+                }
+            }
+        }
+
+        return min_val;
+    }
+
 private:
     size_t _x0, _y0;
     Matrix<Type,M,N>* _data;
diff --git a/test/CMakeLists.txt.in b/test/CMakeLists.txt.in
index fb9ff2f..a341cac 100644
--- a/test/CMakeLists.txt.in
+++ b/test/CMakeLists.txt.in
@@ -4,7 +4,7 @@ project(googletest-download NONE)
 
 include(ExternalProject)
 ExternalProject_Add(googletest
-	URL https://github.com/google/googletest/archive/8b6d3f9c4a774bef3081195d422993323b6bb2e0.zip
+	URL https://github.com/google/googletest/archive/e2239ee6043f73722e7aa812a459f54a28552929.zip
 	SOURCE_DIR "${CMAKE_CURRENT_BINARY_DIR}/googletest-src"
 	BINARY_DIR "${CMAKE_CURRENT_BINARY_DIR}/googletest-build"
 	CONFIGURE_COMMAND ""
diff --git a/test/attitude.cpp b/test/attitude.cpp
index cbdcf3d..d895496 100644
--- a/test/attitude.cpp
+++ b/test/attitude.cpp
@@ -89,6 +89,52 @@ int main()
     q = Quatf();
     TEST(isEqual(q, Quatf(1, 0, 0, 0)));
 
+    // quaternion exponential with v=0
+    v = Vector3f();
+    q = Quatf(1.0f, 0.0f, 0.0f, 0.0f);
+    Dcmf M = Dcmf()*0.5f;
+    TEST(isEqual(q, Quatf::expq(v)));
+    TEST(isEqual(M, Quatf::inv_r_jacobian(v)));
+
+    // quaternion exponential with small v
+    v = Vector3f(0.001f,0.002f,-0.003f);
+    q = Quatf(0.999993000008167f, 0.000999997666668f,
+              0.001999995333337f, -0.002999993000005f);
+    {
+        float M_data[] =  {
+            0.499997833331311f, 0.001500333333644f,  0.000999499999533f,
+            -0.001499666666356f, 0.499998333331778f, -0.000501000000933f,
+            -0.001000500000467f, 0.000498999999067f,  0.499999166665889f
+        };
+        M = Dcmf(M_data);
+    }
+    TEST(isEqual(q, Quatf::expq(v)));
+    TEST(isEqual(M, Quatf::inv_r_jacobian(v)));
+
+    // quaternion exponential with v
+    v = Vector3f(1.0f, -2.0f, 3.0f);
+    q = Quatf(-0.825299062075259f, -0.150921327219964f,
+              0.301842654439929f, -0.452763981659893f);
+    {
+        float M_data[] =  {
+            2.574616981530584f, -1.180828156687602f, -1.478757764968596f,
+            1.819171843312398f,  2.095859216561988f,  0.457515529937193f,
+            0.521242235031404f,  1.457515529937193f,  1.297929608280994f
+        };
+        M = Dcmf(M_data);
+    }
+    TEST(isEqual(q, Quatf::expq(v)));
+    TEST(isEqual(M, Quatf::inv_r_jacobian(v)));
+
+    // quaternion kinematic update
+    q = Quatf();
+    float h=0.001f;    // sampling time [s]
+    Vector3f w_B=Vector3f(0.1f,0.2f,0.3f);     // body rate in body frame
+    Quatf qa=q+0.5f*h*q.derivative1(w_B);
+    qa.normalize();
+    Quatf qb=q*Quatf::expq(0.5f*h*w_B);
+    TEST(isEqual(qa, qb));
+
     // euler to quaternion
     q = Quatf(euler_check);
     TEST(isEqual(q, q_check));
diff --git a/test/pseudoInverse.cpp b/test/pseudoInverse.cpp
index e7d8b10..a313a58 100644
--- a/test/pseudoInverse.cpp
+++ b/test/pseudoInverse.cpp
@@ -22,7 +22,9 @@ int main()
     };
 
     Matrix<float, 3, 4> A0(data0);
-    Matrix<float, 4, 3> A0_I = geninv(A0);
+    Matrix<float, 4, 3> A0_I;
+    bool ret = geninv(A0, A0_I);
+    TEST(ret);
     Matrix<float, 4, 3> A0_I_check(data0_check);
 
     TEST((A0_I - A0_I_check).abs().max() < 1e-5);
@@ -42,7 +44,9 @@ int main()
     };
 
     Matrix<float, 4, 3> A1(data1);
-    Matrix<float, 3, 4> A1_I = geninv(A1);
+    Matrix<float, 3, 4> A1_I;
+    ret = geninv(A1, A1_I);
+    TEST(ret);
     Matrix<float, 3, 4> A1_I_check(data1_check);
 
     TEST((A1_I - A1_I_check).abs().max() < 1e-5);
@@ -53,7 +57,8 @@ int main()
     Matrix<float, n_large - 1, n_large> A_large_I;
 
     for (size_t i = 0; i < n_large; i++) {
-        A_large_I = geninv(A_large);
+        ret = geninv(A_large, A_large_I);
+        TEST(ret);
         TEST(isEqual(A_large, A_large_I.T()));
     }
 
@@ -69,13 +74,17 @@ int main()
     };
 
     SquareMatrix<float, 3> A2(data2);
-    SquareMatrix<float, 3> A2_I = geninv(A2);
+    SquareMatrix<float, 3> A2_I;
+    ret = geninv(A2, A2_I);
+    TEST(ret);
     SquareMatrix<float, 3> A2_I_check(data2_check);
     TEST((A2_I - A2_I_check).abs().max() < 1e-3);
 
     // Null matrix test
     Matrix<float, 6, 16> A3;
-    Matrix<float, 16, 6> A3_I = geninv(A3);
+    Matrix<float, 16, 6> A3_I;
+    ret = geninv(A3, A3_I);
+    TEST(ret);
     Matrix<float, 16, 6> A3_I_check;
     TEST((A3_I - A3_I_check).abs().max() < 1e-5);
 
@@ -108,7 +117,9 @@ int main()
         { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}
     };
     Matrix<float, 16, 6> A_check = Matrix<float, 16, 6>(A_quad_w);
-    Matrix<float, 16, 6> A = geninv(B);
+    Matrix<float, 16, 6> A;
+    ret = geninv(B, A);
+    TEST(ret);
     TEST((A - A_check).abs().max() < 1e-5);
 
     // Real-world test case
@@ -120,7 +131,9 @@ int main()
         { 0.607814, -0.607814,  0.607814, -0.607814,  1.0000,  1.0000}
     };
     Matrix<float, 5, 6> real ( real_alloc);
-    Matrix<float, 6, 5> real_pinv = geninv(real);
+    Matrix<float, 6, 5> real_pinv;
+    ret = geninv(real, real_pinv);
+    TEST(ret);
 
     // from SVD-based inverse
     const float real_pinv_expected_alloc[6][5] = {
diff --git a/test/slice.cpp b/test/slice.cpp
index a8db0ac..6f838f0 100644
--- a/test/slice.cpp
+++ b/test/slice.cpp
@@ -125,6 +125,11 @@ int main()
     TEST(!v5.xy().longerThan(5.f));
     TEST(isEqualF(5.f, v5.xy().norm()));
 
+    // min/max
+    TEST(m33.row(1).max() == 5);
+    TEST(m33.col(0).min() == 0);
+    TEST((m33.slice<2,2>(1,1).max()) == 10);
+
     // assign scalar value to slice
     Matrix<float, 3, 1> L;
     L(0,0) = -1;
