diff --git a/ROMFS/px4fmu_common/init.d-posix/airframes/15002_ductedfan2 b/ROMFS/px4fmu_common/init.d-posix/airframes/15002_ductedfan2
new file mode 100644
index 0000000000..8a1bb86282
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d-posix/airframes/15002_ductedfan2
@@ -0,0 +1,46 @@
+#!/bin/sh
+#
+# @name ductedfan2
+#
+# @type Ducted Fan
+# @class Copter
+#
+# @output MAIN1 Left swashplate servomotor, pitch axis
+# @output MAIN2 Right swashplate servomotor, roll axis
+# @output MAIN3 Upper rotor (CCW)
+# @output MAIN4 Lower rotor (CW)
+#
+# @maintainer Emmanuel Roussel
+#
+# @board px4_fmu-v2 exclude
+# @board intel_aerofc-v1 exclude
+# @board bitcraze_crazyflie exclude
+#
+
+. ${R}etc/init.d/rc.mc_defaults
+
+
+
+param set-default MC_ROLL_P 6.5
+param set-default MC_ROLLRATE_P 0.45
+param set-default MC_ROLLRATE_I 0.1
+param set-default MC_ROLLRATE_D 0.01
+param set-default MC_ROLLRATE_FF 0
+param set-default MC_PITCH_P 6.5
+param set-default MC_PITCHRATE_P 0.45
+param set-default MC_PITCHRATE_I 0.05
+param set-default MC_PITCHRATE_D 0.01
+param set-default MC_PITCHRATE_FF 0
+param set-default MC_YAW_P 2
+param set-default MC_YAWRATE_P 0.3
+param set-default MC_YAWRATE_I 0.05
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+
+
+
+
+set MAV_TYPE 3
+set PWM_OUT 12
+
+set MIXER ductedfan2
diff --git a/ROMFS/px4fmu_common/init.d-posix/airframes/15003_ductedfan4 b/ROMFS/px4fmu_common/init.d-posix/airframes/15003_ductedfan4
new file mode 100644
index 0000000000..15590ce353
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d-posix/airframes/15003_ductedfan4
@@ -0,0 +1,82 @@
+#!/bin/sh
+#
+# @name ductedfan4
+#
+# @type Ducted Fan
+# @class Copter
+#
+# @output MAIN1 Upper rotor (CCW)
+# @output MAIN2 servomotor, roll axis
+# @output MAIN3 servomotor, pitch axis
+# @output MAIN4 servomotor, roll axis
+# @output MAIN5 servomotor, pitch axis
+#
+# @maintainer Emmanuel Roussel
+#
+# @board px4_fmu-v2 exclude
+# @board intel_aerofc-v1 exclude
+# @board bitcraze_crazyflie exclude
+#
+
+. ${R}etc/init.d/rc.mc_defaults
+
+
+param set-default MC_ROLL_P 6
+param set-default MC_ROLLRATE_P 0.4
+# param set-default MC_ROLLRATE_I 0.3
+param set-default MC_ROLLRATE_I 0.0
+param set-default MC_ROLLRATE_D 0.0
+param set-default MC_ROLLRATE_FF 0
+
+param set-default MC_PITCH_P 6
+param set-default MC_PITCHRATE_P 0.4
+# param set-default MC_PITCHRATE_I 0.3
+param set-default MC_PITCHRATE_I 0.0
+param set-default MC_PITCHRATE_D 0.0
+param set-default MC_PITCHRATE_FF 0
+
+param set-default MC_YAW_P 5
+param set-default MC_YAWRATE_P 0.2
+# param set-default MC_YAWRATE_I 0.3
+param set-default MC_YAWRATE_I 0.0
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+param set-default MC_YAW_WEIGHT 1
+
+# param set-default USER_INDI_R_P 13.699
+# param set-default USER_INDI_P_P 13.699
+# param set-default USER_INDI_Y_P 17.806
+param set-default USER_INDI_R_P 12
+param set-default USER_INDI_P_P 12
+param set-default USER_INDI_Y_P 12
+# 0.15rad
+param set-default USER_DIST_MAG 0.1396
+
+param set-default MPC_THR_HOVER 0.5
+param set-default RTL_RETURN_ALT 2.5
+param set-default RTL_DESCEND_ALT 2.5
+param set-default SDLOG_PROFILE  17
+param set-default SDLOG_MODE  0
+
+param set-default USER_CS_CUTOFF  10
+param set-default IMU_GYRO_CUTOFF  0
+param set-default IMU_DGYRO_CUTOFF  10
+param set-default USER_PID_CA 0
+
+param set-default IMU_GYRO_RATEMAX  0
+# param set-default IMU_INTEG_RATE  250
+
+# param set-default EKF2_ACC_B_NOISE  0.001
+# param set-default EKF2_ACC_NOISE  0.1
+# param set-default EKF2_GYR_B_NOISE  0.0005
+# param set-default EKF2_GYR_NOISE  0.001
+# param set-default EKF2_MAG_NOISE  0.01
+# param set-default EKF2_BARO_NOISE  1.0
+# param set-default EKF2_GPS_V_NOISE  0.2
+
+param set-default USER_ACTUATOR 1
+
+set MAV_TYPE 3
+set PWM_OUT 1
+
+set MIXER ductedfan4
diff --git a/ROMFS/px4fmu_common/init.d-posix/airframes/15004_ductedfan6 b/ROMFS/px4fmu_common/init.d-posix/airframes/15004_ductedfan6
new file mode 100644
index 0000000000..cd6819cd26
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d-posix/airframes/15004_ductedfan6
@@ -0,0 +1,61 @@
+#!/bin/sh
+#
+# @name ductedfan6
+#
+# @type Ducted Fan
+# @class Copter
+#
+# @output MAIN1 Upper rotor (CCW)
+# @output MAIN2 servomotor, roll axis
+# @output MAIN3 servomotor, roll pitch axis
+# @output MAIN4 servomotor, roll pitch axis
+# @output MAIN5 servomotor, roll axis
+# @output MAIN6 servomotor, roll pitch axis
+# @output MAIN7 servomotor, roll pitch axis
+#
+# @maintainer Emmanuel Roussel
+#
+# @board px4_fmu-v2 exclude
+# @board intel_aerofc-v1 exclude
+# @board bitcraze_crazyflie exclude
+#
+
+. ${R}etc/init.d/rc.mc_defaults
+
+
+param set-default MC_ROLL_P 6
+param set-default MC_ROLLRATE_P 0.45
+param set-default MC_ROLLRATE_I 0.3
+param set-default MC_ROLLRATE_D 0.0
+param set-default MC_ROLLRATE_FF 0
+
+param set-default MC_PITCH_P 6
+param set-default MC_PITCHRATE_P 0.45
+param set-default MC_PITCHRATE_I 0.3
+param set-default MC_PITCHRATE_D 0.0
+param set-default MC_PITCHRATE_FF 0
+
+param set-default MC_YAW_P 5
+param set-default MC_YAWRATE_P 0.4
+param set-default MC_YAWRATE_I 0.3
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+
+param set-default USER_INDI_R_P 12.0
+param set-default USER_INDI_P_P 12.0
+param set-default USER_INDI_Y_P 10.0
+
+param set-default MPC_THR_HOVER 0.5
+param set-default RTL_RETURN_ALT 2.5
+param set-default RTL_DESCEND_ALT 2.5
+param set-default SDLOG_PROFILE  1
+param set-default SDLOG_MODE  0
+
+param set-default USER_CS_CUTOFF  8
+param set-default IMU_DGYRO_CUTOFF  10
+param set-default USER_PID_CA 0
+
+set MAV_TYPE 3
+set PWM_OUT 1
+
+set MIXER ductedfan6
diff --git a/ROMFS/px4fmu_common/init.d-posix/airframes/15005_ductedfan_mini b/ROMFS/px4fmu_common/init.d-posix/airframes/15005_ductedfan_mini
new file mode 100644
index 0000000000..caee510b5a
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d-posix/airframes/15005_ductedfan_mini
@@ -0,0 +1,59 @@
+#!/bin/sh
+#
+# @name ductedfan_mini
+#
+# @type Ducted Fan
+# @class Copter
+#
+# @output MAIN1 Upper rotor (CCW)
+# @output MAIN2 servomotor, roll axis
+# @output MAIN3 servomotor, pitch axis
+# @output MAIN4 servomotor, roll axis
+# @output MAIN5 servomotor, pitch axis
+#
+# @maintainer Emmanuel Roussel
+#
+# @board px4_fmu-v2 exclude
+# @board intel_aerofc-v1 exclude
+# @board bitcraze_crazyflie exclude
+#
+
+. ${R}etc/init.d/rc.mc_defaults
+
+
+param set-default MC_ROLL_P 6
+param set-default MC_ROLLRATE_P 0.45
+param set-default MC_ROLLRATE_I 0.3
+param set-default MC_ROLLRATE_D 0.0
+param set-default MC_ROLLRATE_FF 0
+
+param set-default MC_PITCH_P 6
+param set-default MC_PITCHRATE_P 0.45
+param set-default MC_PITCHRATE_I 0.3
+param set-default MC_PITCHRATE_D 0.0
+param set-default MC_PITCHRATE_FF 0
+
+param set-default MC_YAW_P 5
+param set-default MC_YAWRATE_P 0.4
+param set-default MC_YAWRATE_I 0.3
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+
+param set-default USER_INDI_R_P 12.0
+param set-default USER_INDI_P_P 12.0
+param set-default USER_INDI_Y_P 10.0
+
+param set-default MPC_THR_HOVER 0.5
+param set-default RTL_RETURN_ALT 2.5
+param set-default RTL_DESCEND_ALT 2.5
+param set-default SDLOG_PROFILE  1
+param set-default SDLOG_MODE  0
+
+param set-default USER_CS_CUTOFF  8
+param set-default IMU_DGYRO_CUTOFF  10
+param set-default USER_PID_CA 0
+
+set MAV_TYPE 3
+set PWM_OUT 1
+
+set MIXER ductedfan_mini
diff --git a/ROMFS/px4fmu_common/init.d-posix/airframes/CMakeLists.txt b/ROMFS/px4fmu_common/init.d-posix/airframes/CMakeLists.txt
index 660e68704c..59e4a87281 100644
--- a/ROMFS/px4fmu_common/init.d-posix/airframes/CMakeLists.txt
+++ b/ROMFS/px4fmu_common/init.d-posix/airframes/CMakeLists.txt
@@ -75,6 +75,10 @@ px4_add_romfs_files(
 	2507_cloudship
 	6011_typhoon_h480
 	6011_typhoon_h480.post
+	15002_ductedfan2
+	15003_ductedfan4
+	15004_ductedfan6
+	15005_ductedfan_mini
 	6012_typhoon_ctrlalloc
 	6012_typhoon_ctrlalloc.post
 )
diff --git a/ROMFS/px4fmu_common/init.d/airframes/1003_ductedfan4.hil b/ROMFS/px4fmu_common/init.d/airframes/1003_ductedfan4.hil
new file mode 100644
index 0000000000..c91ca33e46
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d/airframes/1003_ductedfan4.hil
@@ -0,0 +1,78 @@
+#!/bin/sh
+#
+# @name HIL ductedfan4
+#
+# @type Simulation
+# @class Copter
+#
+# @output MAIN1 Upper rotor (CCW)
+# @output MAIN2 servomotor, roll axis
+# @output MAIN3 servomotor, roll axis
+# @output MAIN4 servomotor, pitch axis
+# @output MAIN5 servomotor, pitch axis
+#
+# @maintainer
+#
+
+
+. ${R}etc/init.d/rc.mc_defaults
+
+param set-default MC_ROLL_P 6
+param set-default MC_ROLLRATE_P 0.45
+param set-default MC_ROLLRATE_I 0.3
+param set-default MC_ROLLRATE_D 0.0
+param set-default MC_ROLLRATE_FF 0
+
+param set-default MC_PITCH_P 6
+param set-default MC_PITCHRATE_P 0.45
+param set-default MC_PITCHRATE_I 0.3
+param set-default MC_PITCHRATE_D 0.0
+param set-default MC_PITCHRATE_FF 0
+
+param set-default MC_YAW_P 5
+param set-default MC_YAWRATE_P 0.3
+param set-default MC_YAWRATE_I 0.1
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+
+param set-default MC_ACRO_EXPO_Y 0
+param set-default MC_ACRO_EXPO 0
+param set-default MC_ACRO_SUPEXPO 0
+param set-default MC_ACRO_SUPEXPOY 0
+param set-default MC_ACRO_R_MAX 90.0
+param set-default MC_ACRO_P_MAX 90.0
+param set-default MC_ACRO_Y_MAX 90.0
+
+param set-default USER_INDI_R_P 12.0
+param set-default USER_INDI_P_P 12.0
+param set-default USER_INDI_Y_P 10.0
+
+param set-default MPC_THR_HOVER 0.5
+param set-default RTL_RETURN_ALT 2.5
+param set-default RTL_DESCEND_ALT 2.5
+param set-default SDLOG_PROFILE  1
+param set-default SDLOG_MODE  0
+
+param set-default CS1_CUTOFF  8
+param set-default DOMEGA_CUTOFF  10
+param set-default DOMEGA_D_CUTOFF  10
+param set-default OMEGA_CUTOFF  10
+param set-default IMU_DGYRO_CUTOFF  10
+param set-default USER_PID_CA 0
+
+param set-default MC_PWM_HOVER 1500
+
+set MAV_TYPE 3
+set MIXER ductedfan4_hitl
+set PWM_OUT 1
+
+param set SYS_HITL 1
+
+# disable some checks to allow to fly
+# - with usb
+param set-default CBRK_USB_CHK 197848
+# - without real battery
+param set-default CBRK_SUPPLY_CHK 894281
+# - without safety switch
+param set-default COM_PREARM_MODE 0
+param set-default CBRK_IO_SAFETY 22027
diff --git a/ROMFS/px4fmu_common/init.d/airframes/15002_ducted_fan2 b/ROMFS/px4fmu_common/init.d/airframes/15002_ducted_fan2
new file mode 100644
index 0000000000..53d3143cbe
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d/airframes/15002_ducted_fan2
@@ -0,0 +1,74 @@
+#!/bin/sh
+#
+# @name ductedfan2
+#
+# @type Ducted Fan
+# @class Copter
+#
+# @output MAIN1 Upper rotor (CW)
+# @output MAIN2 Lower rotor (CCW)
+# @output MAIN3 servomotor, roll axis
+# @output MAIN4 servomotor, pitch axis
+#
+# @maintainer
+#
+
+. ${R}etc/init.d/rc.mc_defaults
+
+param set-default MC_ROLL_P 5
+param set-default MC_ROLLRATE_P 0.45
+param set-default MC_ROLLRATE_I 0.4
+param set-default MC_ROLLRATE_D 0.0
+param set-default MC_ROLLRATE_FF 0
+param set-default MC_PITCH_P 5
+param set-default MC_PITCHRATE_P 0.45
+param set-default MC_PITCHRATE_I 0.4
+param set-default MC_PITCHRATE_D 0.0
+param set-default MC_PITCHRATE_FF 0
+param set-default MC_YAW_P 5
+param set-default MC_YAWRATE_P 0.4
+param set-default MC_YAWRATE_I 0.2
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+
+param set-default NAV_ACC_RAD 2
+
+param set-default PWM_DISARMED 900
+param set-default PWM_MIN 1090
+param set-default PWM_MAX 1910
+param set-default PWM_MAIN_MIN3 1340
+param set-default PWM_MAIN_MIN4 1330
+param set-default PWM_MAIN_MAX3 1700
+param set-default PWM_MAIN_MAX4 1690
+param set-default PWM_RATE 150
+
+param set-default RTL_RETURN_ALT 2.5
+param set-default RTL_DESCEND_ALT 2.5
+
+param set-default CBRK_USB_CHK 197848
+param set-default BAT1_N_CELLS 6
+param set-default BAT1_V_CHARGED 4.2
+
+# TELEM1 ttyS1
+param set-default MAV_0_CONFIG 101
+param set-default MAV_0_MODE 0
+param set-default MAV_0_FORWARD 1
+param set-default SER_TEL1_BAUD 921600
+
+# TELEM2 ttyS2
+param set-default MAV_1_CONFIG 102
+param set-default MAV_1_MODE 0
+param set-default MAV_1_FORWARD 1
+#param set-default MAV_1_RATE 1200
+param set-default SER_TEL2_BAUD 57600
+
+param set-default SDLOG_PROFILE  17
+
+#param set-default IMU_GYRO_RATEMAX 400
+
+set MAV_TYPE 3
+
+set MIXER ductedfan2
+
+# use PWM parameters for throttle channel
+set PWM_OUT 12
diff --git a/ROMFS/px4fmu_common/init.d/airframes/15003_ducted_fan4 b/ROMFS/px4fmu_common/init.d/airframes/15003_ducted_fan4
new file mode 100644
index 0000000000..c08966b00c
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d/airframes/15003_ducted_fan4
@@ -0,0 +1,95 @@
+#!/bin/sh
+#
+# @name ductedfan4
+#
+# @type Ducted Fan
+# @class Copter
+#
+# @output MAIN1 Upper rotor (CCW)
+# @output MAIN2 servomotor, roll axis
+# @output MAIN3 servomotor, pitch axis
+# @output MAIN4 servomotor, roll axis
+# @output MAIN5 servomotor, pitch axis
+#
+# @maintainer
+#
+
+
+. ${R}etc/init.d/rc.mc_defaults
+
+
+param set-default MC_ROLL_P 6
+param set-default MC_ROLLRATE_P 0.45
+param set-default MC_ROLLRATE_I 0.3
+param set-default MC_ROLLRATE_D 0.0
+param set-default MC_ROLLRATE_FF 0
+
+param set-default MC_PITCH_P 6
+param set-default MC_PITCHRATE_P 0.45
+param set-default MC_PITCHRATE_I 0.3
+param set-default MC_PITCHRATE_D 0.0
+param set-default MC_PITCHRATE_FF 0
+
+param set-default MC_YAW_P 5
+param set-default MC_YAWRATE_P 0.4
+param set-default MC_YAWRATE_I 0.3
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+
+param set-default MPC_THR_HOVER 0.7
+param set-default MPC_VEL_MANUAL 4
+param set-default MPC_XY_CRUISE 4
+param set-default MPC_XY_P 1
+param set-default MPC_XY_TRAJ_P 1
+param set-default MPC_XY_VEL_MAX 4
+param set-default MPC_XY_VEL_P_ACC 2
+
+param set-default MPC_Z_P 1.5
+param set-default MPC_Z_VEL_I_ACC 0.4
+param set-default MPC_Z_VEL_MAX_DN 0.5
+param set-default MPC_Z_VEL_MAX_UP 2
+param set-default MPC_Z_VEL_P_ACC 2
+
+param set-default NAV_ACC_RAD 2
+
+param set-default PWM_DISARMED 900
+param set-default PWM_MIN 1000
+param set-default PWM_MAX 2000
+param set-default PWM_MAIN_MIN5 1275
+param set-default PWM_MAIN_MIN6 1277
+param set-default PWM_MAIN_MIN7 1360
+param set-default PWM_MAIN_MIN8 1320
+
+param set-default PWM_MAIN_MAX5 1635
+param set-default PWM_MAIN_MAX6 1637
+param set-default PWM_MAIN_MAX7 1720
+param set-default PWM_MAIN_MAX8 1680
+param set-default PWM_MAIN_RATE 333
+
+param set-default RTL_RETURN_ALT 2.5
+param set-default RTL_DESCEND_ALT 2.5
+
+param set-default CBRK_USB_CHK 197848
+param set-default BAT1_N_CELLS 4
+param set-default BAT1_V_CHARGED 4.2
+
+# TELEM1 ttyS1
+param set-default MAV_0_CONFIG 101
+param set-default MAV_0_MODE 0
+param set-default MAV_0_FORWARD 1
+param set-default SER_TEL1_BAUD 921600
+
+param set-default SDLOG_PROFILE  1
+param set-default USER_CS_CUTOFF  3
+param set-default IMU_DGYRO_CUTOFF  5
+
+param set-default COM_PREARM_MODE  1
+#param set-default CBRK_IO_SAFETY  22027
+#param set-default IMU_GYRO_RATEMAX 400
+
+set MAV_TYPE 3
+
+set MIXER ductedfan4
+
+# use PWM parameters for throttle channel
+set PWM_OUT 1
diff --git a/ROMFS/px4fmu_common/init.d/airframes/15004_ducted_fan6 b/ROMFS/px4fmu_common/init.d/airframes/15004_ducted_fan6
new file mode 100644
index 0000000000..2ffa3e75c2
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d/airframes/15004_ducted_fan6
@@ -0,0 +1,99 @@
+#!/bin/sh
+#
+# @name ductedfan6
+#
+# @type Ducted Fan
+# @class Copter
+#
+# @output MAIN1 Upper rotor (CCW)
+# @output MAIN2 servomotor, roll axis
+# @output MAIN3 servomotor, roll pitch axis
+# @output MAIN4 servomotor, roll pitch axis
+# @output MAIN5 servomotor, roll axis
+# @output MAIN6 servomotor, roll pitch axis
+# @output MAIN7 servomotor, roll pitch axis
+
+#
+# @maintainer
+#
+
+
+. ${R}etc/init.d/rc.mc_defaults
+
+
+param set-default MC_ROLL_P 6
+param set-default MC_ROLLRATE_P 0.45
+param set-default MC_ROLLRATE_I 0.3
+param set-default MC_ROLLRATE_D 0.0
+param set-default MC_ROLLRATE_FF 0
+
+param set-default MC_PITCH_P 6
+param set-default MC_PITCHRATE_P 0.45
+param set-default MC_PITCHRATE_I 0.3
+param set-default MC_PITCHRATE_D 0.0
+param set-default MC_PITCHRATE_FF 0
+
+param set-default MC_YAW_P 5
+param set-default MC_YAWRATE_P 0.4
+param set-default MC_YAWRATE_I 0.3
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+
+param set-default MPC_THR_HOVER 0.7
+param set-default MPC_VEL_MANUAL 4
+param set-default MPC_XY_CRUISE 4
+param set-default MPC_XY_P 1
+param set-default MPC_XY_TRAJ_P 1
+param set-default MPC_XY_VEL_MAX 4
+param set-default MPC_XY_VEL_P_ACC 2
+
+param set-default MPC_Z_P 1.5
+param set-default MPC_Z_VEL_I_ACC 0.4
+param set-default MPC_Z_VEL_MAX_DN 0.5
+param set-default MPC_Z_VEL_MAX_UP 2
+param set-default MPC_Z_VEL_P_ACC 2
+
+param set-default NAV_ACC_RAD 2
+
+param set-default PWM_DISARMED 900
+param set-default PWM_MIN 1000
+param set-default PWM_MAX 2000
+param set-default PWM_MAIN_MIN5 1275
+param set-default PWM_MAIN_MIN6 1277
+param set-default PWM_MAIN_MIN7 1360
+param set-default PWM_MAIN_MIN8 1320
+
+param set-default PWM_MAIN_MAX5 1635
+param set-default PWM_MAIN_MAX6 1637
+param set-default PWM_MAIN_MAX7 1720
+param set-default PWM_MAIN_MAX8 1680
+param set-default PWM_MAIN_RATE 333
+
+param set-default RTL_RETURN_ALT 2.5
+param set-default RTL_DESCEND_ALT 2.5
+
+param set-default CBRK_USB_CHK 197848
+param set-default BAT1_N_CELLS 4
+param set-default BAT1_V_CHARGED 4.2
+
+# TELEM1 ttyS1
+param set-default MAV_0_CONFIG 101
+param set-default MAV_0_MODE 0
+param set-default MAV_0_FORWARD 1
+param set-default SER_TEL1_BAUD 921600
+
+param set-default SDLOG_PROFILE  1
+param set-default USER_CS_CUTOFF  3
+param set-default IMU_DGYRO_CUTOFF  5
+
+param set-default COM_PREARM_MODE  1
+#param set-default CBRK_IO_SAFETY  22027
+#param set-default IMU_GYRO_RATEMAX 400
+
+
+set MAV_TYPE 3
+
+set MIXER ductedfan6
+
+# use PWM parameters for throttle channel
+set PWM_OUT 1
diff --git a/ROMFS/px4fmu_common/init.d/airframes/15005_ducted_fan_mini b/ROMFS/px4fmu_common/init.d/airframes/15005_ducted_fan_mini
new file mode 100644
index 0000000000..d90c857236
--- /dev/null
+++ b/ROMFS/px4fmu_common/init.d/airframes/15005_ducted_fan_mini
@@ -0,0 +1,95 @@
+#!/bin/sh
+#
+# @name ductedfan_mini
+#
+# @type Ducted Fan
+# @class Copter
+#
+# @output MAIN1 Upper rotor (CCW)
+# @output MAIN2 servomotor, roll axis
+# @output MAIN3 servomotor, pitch axis
+# @output MAIN4 servomotor, roll axis
+# @output MAIN5 servomotor, pitch axis
+#
+# @maintainer
+#
+
+
+. ${R}etc/init.d/rc.mc_defaults
+
+
+param set-default MC_ROLL_P 6
+param set-default MC_ROLLRATE_P 0.45
+param set-default MC_ROLLRATE_I 0.3
+param set-default MC_ROLLRATE_D 0.0
+param set-default MC_ROLLRATE_FF 0
+
+param set-default MC_PITCH_P 6
+param set-default MC_PITCHRATE_P 0.45
+param set-default MC_PITCHRATE_I 0.3
+param set-default MC_PITCHRATE_D 0.0
+param set-default MC_PITCHRATE_FF 0
+
+param set-default MC_YAW_P 5
+param set-default MC_YAWRATE_P 0.4
+param set-default MC_YAWRATE_I 0.3
+param set-default MC_YAWRATE_D 0
+param set-default MC_YAWRATE_FF 0
+
+param set-default MPC_THR_HOVER 0.7
+param set-default MPC_VEL_MANUAL 4
+param set-default MPC_XY_CRUISE 4
+param set-default MPC_XY_P 1
+param set-default MPC_XY_TRAJ_P 1
+param set-default MPC_XY_VEL_MAX 4
+param set-default MPC_XY_VEL_P_ACC 2
+
+param set-default MPC_Z_P 1.5
+param set-default MPC_Z_VEL_I_ACC 0.4
+param set-default MPC_Z_VEL_MAX_DN 0.5
+param set-default MPC_Z_VEL_MAX_UP 2
+param set-default MPC_Z_VEL_P_ACC 2
+
+param set-default NAV_ACC_RAD 2
+
+param set-default PWM_DISARMED 900
+param set-default PWM_MIN 1000
+param set-default PWM_MAX 2000
+param set-default PWM_MAIN_MIN5 1275
+param set-default PWM_MAIN_MIN6 1277
+param set-default PWM_MAIN_MIN7 1360
+param set-default PWM_MAIN_MIN8 1320
+
+param set-default PWM_MAIN_MAX5 1635
+param set-default PWM_MAIN_MAX6 1637
+param set-default PWM_MAIN_MAX7 1720
+param set-default PWM_MAIN_MAX8 1680
+param set-default PWM_MAIN_RATE 333
+
+param set-default RTL_RETURN_ALT 2.5
+param set-default RTL_DESCEND_ALT 2.5
+
+param set-default CBRK_USB_CHK 197848
+param set-default BAT1_N_CELLS 4
+param set-default BAT1_V_CHARGED 4.2
+
+# TELEM1 ttyS1
+param set-default MAV_0_CONFIG 101
+param set-default MAV_0_MODE 0
+param set-default MAV_0_FORWARD 1
+param set-default SER_TEL1_BAUD 921600
+
+param set-default SDLOG_PROFILE  1
+param set-default USER_CS_CUTOFF  3
+param set-default IMU_DGYRO_CUTOFF  5
+
+param set-default COM_PREARM_MODE  1
+#param set-default CBRK_IO_SAFETY  22027
+#param set-default IMU_GYRO_RATEMAX 400
+
+set MAV_TYPE 3
+
+set MIXER ductedfan_mini
+
+# use PWM parameters for throttle channel
+set PWM_OUT 1
diff --git a/ROMFS/px4fmu_common/init.d/airframes/CMakeLists.txt b/ROMFS/px4fmu_common/init.d/airframes/CMakeLists.txt
index f1ce40b6aa..46bf6c2599 100644
--- a/ROMFS/px4fmu_common/init.d/airframes/CMakeLists.txt
+++ b/ROMFS/px4fmu_common/init.d/airframes/CMakeLists.txt
@@ -38,6 +38,7 @@ px4_add_romfs_files(
 	1000_rc_fw_easystar.hil
 	1001_rc_quad_x.hil
 	1002_standard_vtol.hil
+	1003_ductedfan4.hil
 	1100_rc_quad_x_sih.hil

 	# [2000, 2999] Standard planes"
@@ -146,6 +147,10 @@ px4_add_romfs_files(
 	14002_tri_y_yaw-

 	15001_coax_heli
+	15002_ducted_fan2
+	15003_ducted_fan4
+	15004_ducted_fan6
+	15005_ducted_fan_mini

 	16001_helicopter

diff --git a/ROMFS/px4fmu_common/mixers/CMakeLists.txt b/ROMFS/px4fmu_common/mixers/CMakeLists.txt
index df861065a2..dc928a9392 100644
--- a/ROMFS/px4fmu_common/mixers/CMakeLists.txt
+++ b/ROMFS/px4fmu_common/mixers/CMakeLists.txt
@@ -95,4 +95,9 @@ px4_add_romfs_files(
 	vtol_delta.aux.mix
 	vtol_tailsitter_duo.main.mix
 	wingwing.main.mix
+	ductedfan2.main.mix
+	ductedfan4.main.mix
+	ductedfan6.main.mix
+	ductedfan4_hitl.main.mix
+	ductedfan_mini.main.mix
 )
diff --git a/ROMFS/px4fmu_common/mixers/ductedfan2.main.mix b/ROMFS/px4fmu_common/mixers/ductedfan2.main.mix
new file mode 100644
index 0000000000..51919679cb
--- /dev/null
+++ b/ROMFS/px4fmu_common/mixers/ductedfan2.main.mix
@@ -0,0 +1,44 @@
+ducted fan mixer
+- One motor per rotor.
+- Two servos act on the control surfaces.
+===========================
+
+thrust is range from 0 to 1,
+This mixer generates a full-range output (-1 to 1) from an input in the (0 - 1)
+range.  Inputs below zero are treated as zero.
+
+Upper rotor (CW)
+Mixing between yaw and thrust
+-------------
+M: 2
+S: 0 2  -10000  -10000      0 -10000  10000
+S: 0 3       0   20000 -10000 -10000  10000
+
+Lower rotor (CCW)
+Mixing between yaw and thrust
+-------------
+M: 2
+S: 0 2  10000  10000      0 -10000  10000
+S: 0 3      0  20000 -10000 -10000  10000
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+roll control surfaces
+-------------
+M: 1
+S: 0 0  -10000  -10000      0 -10000  10000
+
+pitch control surfaces
+-------------
+M: 1
+S: 0 1  10000  10000      0 -10000  10000
+
+
+
+
diff --git a/ROMFS/px4fmu_common/mixers/ductedfan4.main.mix b/ROMFS/px4fmu_common/mixers/ductedfan4.main.mix
new file mode 100644
index 0000000000..7e4acbe7c3
--- /dev/null
+++ b/ROMFS/px4fmu_common/mixers/ductedfan4.main.mix
@@ -0,0 +1,54 @@
+ducted fan mixer
+- One motor.
+- four servos act on the control surfaces.
+===========================
+
+thrust is range from 0 to 1,
+This mixer generates a full-range output (-1 to 1) from an input in the (0 - 1)
+range.  Inputs below zero are treated as zero.
+
+Upper rotor (CVW)
+just thrust
+-------------
+M: 1
+S: 0 3       0   20000 -10000 -10000  10000
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+-control surfaces 1, roll and yaw
+-------------
+M: 2
+S: 0 0  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 2, pitch and yaw
+-------------
+M: 2
+S: 0 1  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 3, roll and yaw
+-------------
+M: 2
+S: 0 0  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 4, pitch and yaw
+-------------
+M: 2
+S: 0 1  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+
+
+
diff --git a/ROMFS/px4fmu_common/mixers/ductedfan4_hitl.main.mix b/ROMFS/px4fmu_common/mixers/ductedfan4_hitl.main.mix
new file mode 100644
index 0000000000..7e4acbe7c3
--- /dev/null
+++ b/ROMFS/px4fmu_common/mixers/ductedfan4_hitl.main.mix
@@ -0,0 +1,54 @@
+ducted fan mixer
+- One motor.
+- four servos act on the control surfaces.
+===========================
+
+thrust is range from 0 to 1,
+This mixer generates a full-range output (-1 to 1) from an input in the (0 - 1)
+range.  Inputs below zero are treated as zero.
+
+Upper rotor (CVW)
+just thrust
+-------------
+M: 1
+S: 0 3       0   20000 -10000 -10000  10000
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+-control surfaces 1, roll and yaw
+-------------
+M: 2
+S: 0 0  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 2, pitch and yaw
+-------------
+M: 2
+S: 0 1  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 3, roll and yaw
+-------------
+M: 2
+S: 0 0  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 4, pitch and yaw
+-------------
+M: 2
+S: 0 1  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+
+
+
diff --git a/ROMFS/px4fmu_common/mixers/ductedfan6.main.mix b/ROMFS/px4fmu_common/mixers/ductedfan6.main.mix
new file mode 100644
index 0000000000..b4bbffe5be
--- /dev/null
+++ b/ROMFS/px4fmu_common/mixers/ductedfan6.main.mix
@@ -0,0 +1,72 @@
+ducted fan mixer
+- One motor.
+- six servos act on the control surfaces.
+===========================
+
+thrust is range from 0 to 1,
+This mixer generates a full-range output (-1 to 1) from an input in the (0 - 1)
+range.  Inputs below zero are treated as zero.
+
+Upper rotor (CVW)
+just thrust
+-------------
+M: 1
+S: 0 3       0   20000 -10000 -10000  10000
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+-control surfaces 1, roll and yaw
+-------------
+M: 2
+S: 0 0  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 2, pitch and yaw
+-------------
+M: 3
+S: 0 0  -10000  -10000      0 -10000  10000
+S: 0 1  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 2, roll, pitch and yaw
+-------------
+M: 3
+S: 0 0  10000  10000      0 -10000  10000
+S: 0 1  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 4, roll and yaw
+-------------
+M: 2
+S: 0 0  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 5, roll, pitch and yaw
+-------------
+M: 3
+S: 0 0  10000  10000      0 -10000  10000
+S: 0 1  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 6, roll, pitch and yaw
+-------------
+M: 3
+S: 0 0  -10000  -10000      0 -10000  10000
+S: 0 1  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+
+
+
+
+
diff --git a/ROMFS/px4fmu_common/mixers/ductedfan_mini.main.mix b/ROMFS/px4fmu_common/mixers/ductedfan_mini.main.mix
new file mode 100644
index 0000000000..7e4acbe7c3
--- /dev/null
+++ b/ROMFS/px4fmu_common/mixers/ductedfan_mini.main.mix
@@ -0,0 +1,54 @@
+ducted fan mixer
+- One motor.
+- four servos act on the control surfaces.
+===========================
+
+thrust is range from 0 to 1,
+This mixer generates a full-range output (-1 to 1) from an input in the (0 - 1)
+range.  Inputs below zero are treated as zero.
+
+Upper rotor (CVW)
+just thrust
+-------------
+M: 1
+S: 0 3       0   20000 -10000 -10000  10000
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+This mixer is empty.
+-------------
+Z:
+
+-control surfaces 1, roll and yaw
+-------------
+M: 2
+S: 0 0  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 2, pitch and yaw
+-------------
+M: 2
+S: 0 1  -10000  -10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 3, roll and yaw
+-------------
+M: 2
+S: 0 0  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+-control surfaces 4, pitch and yaw
+-------------
+M: 2
+S: 0 1  10000  10000      0 -10000  10000
+S: 0 2  10000  10000      0 -10000  10000
+
+
+
+
diff --git a/Tools/px4airframes/srcparser.py b/Tools/px4airframes/srcparser.py
index 2fd314d67f..cd04515687 100644
--- a/Tools/px4airframes/srcparser.py
+++ b/Tools/px4airframes/srcparser.py
@@ -96,6 +96,8 @@ class ParameterGroup(object):
             return "Rover"
         elif (self.name == "Boat"):
             return "Boat"
+        elif (self.name == "Ducted Fan"):
+            return "ductedfan"
         elif (self.name == "Balloon"):
             return "Balloon"
         elif (self.name == "Vectored 6 DOF UUV"):
diff --git a/Tools/sitl_run.sh b/Tools/sitl_run.sh
index 9f36364ab2..2827928e61 100755
--- a/Tools/sitl_run.sh
+++ b/Tools/sitl_run.sh
@@ -50,11 +50,11 @@ else
 fi

 # Disable follow mode
-if [[ "$PX4_NO_FOLLOW_MODE" != "1" ]]; then
-    follow_mode="--gui-client-plugin libgazebo_user_camera_plugin.so"
-else
-    follow_mode=""
-fi
+# if [[ "$PX4_NO_FOLLOW_MODE" != "1" ]]; then
+#     follow_mode="--gui-client-plugin libgazebo_user_camera_plugin.so"
+# else
+#     follow_mode=""
+# fi

 if [ "$program" == "jmavsim" ]; then
 	jmavsim_pid=`ps aux | grep java | grep "\-jar jmavsim_run.jar" | awk '{ print $2 }'`
diff --git a/cmake/px4_add_common_flags.cmake b/cmake/px4_add_common_flags.cmake
index d180e92b85..9fef9e3cb8 100644
--- a/cmake/px4_add_common_flags.cmake
+++ b/cmake/px4_add_common_flags.cmake
@@ -68,7 +68,7 @@ function(px4_add_common_flags)
 		# Warnings
 		-Wall
 		-Wextra
-		-Werror
+		#-Werror

 		-Warray-bounds
 		-Wcast-align
diff --git a/imu.txt b/imu.txt
new file mode 100644
index 0000000000..f91fdb461d
--- /dev/null
+++ b/imu.txt
@@ -0,0 +1,5 @@
+mems FIFORead -> ProcessGyro or ProcessAccel ->
+PX4Geroscop's updateFIFO or PX4Accelerometer's updateFIFO ->
+publish sensor_gyro_fifo and sensor_gyro
+
+src/drivers, which used in the rc.board_sensors -> src/lib/drivers -> src/modules/sensors
diff --git a/msg/CMakeLists.txt b/msg/CMakeLists.txt
index b66c6e41b5..fcc0196ba8 100644
--- a/msg/CMakeLists.txt
+++ b/msg/CMakeLists.txt
@@ -38,6 +38,8 @@ set(msg_files
 	actuator_armed.msg
 	actuator_controls.msg
 	actuator_outputs.msg
+	actuator_outputs_value.msg
+	allocation_value.msg
 	adc_report.msg
 	airspeed.msg
 	airspeed_validated.msg
diff --git a/msg/actuator_controls.msg b/msg/actuator_controls.msg
index c4b52ea48d..4b1142b22e 100644
--- a/msg/actuator_controls.msg
+++ b/msg/actuator_controls.msg
@@ -22,7 +22,11 @@ uint8 GROUP_INDEX_PAYLOAD = 6

 uint64 timestamp_sample	    # the timestamp the data this control response is based on was sampled
 float32[8] control
-
+float32[3] indi_fb
+float32[3] error_fb
+float32 indi_dt
+float32 rate_control_running_time
+bool control_flag
 # TOPICS actuator_controls actuator_controls_0 actuator_controls_1 actuator_controls_2 actuator_controls_3
 # TOPICS actuator_controls_4 actuator_controls_5
 # TOPICS actuator_controls_virtual_fw actuator_controls_virtual_mc
diff --git a/msg/actuator_outputs_value.msg b/msg/actuator_outputs_value.msg
new file mode 100644
index 0000000000..e9ef7b1de0
--- /dev/null
+++ b/msg/actuator_outputs_value.msg
@@ -0,0 +1,2 @@
+uint64 timestamp				# time since system start (microseconds)
+float32[4] delta				# Control deflection angle. 1-4 for control surfaces (rad)
diff --git a/msg/allocation_value.msg b/msg/allocation_value.msg
new file mode 100644
index 0000000000..24d484a668
--- /dev/null
+++ b/msg/allocation_value.msg
@@ -0,0 +1,13 @@
+uint64 timestamp	# time since system start(microseconds)
+uint64 timestamp_sample
+int8 flag #0-inv, 1-wls, 2-dir, 3-pca  4-for pca when err_flag_1<0
+float32[3] error
+float32[3] ud_error
+float32[3] ue_error
+float32[4] u
+float32[4] u_ultimate
+float32[4] umin
+float32[4] umax
+
+
+
diff --git a/msg/vehicle_angular_acceleration.msg b/msg/vehicle_angular_acceleration.msg
index a072035616..aa3848835a 100644
--- a/msg/vehicle_angular_acceleration.msg
+++ b/msg/vehicle_angular_acceleration.msg
@@ -3,3 +3,4 @@ uint64 timestamp        # time since system start (microseconds)
 uint64 timestamp_sample # timestamp of the data sample on which this message is based (microseconds)

 float32[3] xyz          # angular acceleration about the FRD body frame XYZ-axis in rad/s^2
+float32[3] xyz_raw          # angular acceleration about the FRD body frame XYZ-axis in rad/s^2
diff --git a/msg/vehicle_angular_velocity.msg b/msg/vehicle_angular_velocity.msg
index a8748772b7..a46e572aa7 100644
--- a/msg/vehicle_angular_velocity.msg
+++ b/msg/vehicle_angular_velocity.msg
@@ -4,4 +4,10 @@ uint64 timestamp_sample # timestamp of the data sample on which this message is

 float32[3] xyz		# Bias corrected angular velocity about the FRD body frame XYZ-axis in rad/s

+float32[3] xyz_raw		# Bias corrected angular velocity about the FRD body frame XYZ-axis in rad/s
+
+float32[3] xyz_notched		# Bias corrected angular velocity about the FRD body frame XYZ-axis in rad/s
+
+float32 dt		# Bias corrected angular velocity about the FRD body frame XYZ-axis in rad/s
+
 # TOPICS vehicle_angular_velocity vehicle_angular_velocity_groundtruth
diff --git a/msg/vehicle_command.msg b/msg/vehicle_command.msg
index 6d69141068..8169ad0475 100644
--- a/msg/vehicle_command.msg
+++ b/msg/vehicle_command.msg
@@ -165,3 +165,4 @@ uint8 source_system		# System sending the command
 uint8 source_component		# Component sending the command
 uint8 confirmation		# 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
 bool from_external
+uint8 test_flag # 0: not in the test. 1: start. 2: end.
diff --git a/platforms/common/include/px4_platform_common/px4_work_queue/WorkQueueManager.hpp b/platforms/common/include/px4_platform_common/px4_work_queue/WorkQueueManager.hpp
index 167ae858ee..eb522732fe 100644
--- a/platforms/common/include/px4_platform_common/px4_work_queue/WorkQueueManager.hpp
+++ b/platforms/common/include/px4_platform_common/px4_work_queue/WorkQueueManager.hpp
@@ -48,8 +48,8 @@ struct wq_config_t {

 namespace wq_configurations
 {
-static constexpr wq_config_t rate_ctrl{"wq:rate_ctrl", 1952, 0}; // PX4 inner loop highest priority
-static constexpr wq_config_t ctrl_alloc{"wq:ctrl_alloc", 9500, 0}; // PX4 control allocation, same priority as rate_ctrl
+static constexpr wq_config_t rate_ctrl{"wq:rate_ctrl", 4452, 0}; // PX4 inner loop highest priority
+static constexpr wq_config_t ctrl_alloc{"wq:ctrl_alloc", 5500, 0}; // PX4 control allocation, same priority as rate_ctrl

 static constexpr wq_config_t SPI0{"wq:SPI0", 2336, -1};
 static constexpr wq_config_t SPI1{"wq:SPI1", 2336, -2};
@@ -60,9 +60,9 @@ static constexpr wq_config_t SPI5{"wq:SPI5", 2336, -6};
 static constexpr wq_config_t SPI6{"wq:SPI6", 2336, -7};

 static constexpr wq_config_t I2C0{"wq:I2C0", 2336, -8};
-static constexpr wq_config_t I2C1{"wq:I2C1", 2336, -9};
+static constexpr wq_config_t I2C1{"wq:I2C1", 1836, -9};
 static constexpr wq_config_t I2C2{"wq:I2C2", 2336, -10};
-static constexpr wq_config_t I2C3{"wq:I2C3", 2336, -11};
+static constexpr wq_config_t I2C3{"wq:I2C3", 1836, -11};
 static constexpr wq_config_t I2C4{"wq:I2C4", 2336, -12};

 // PX4 att/pos controllers, highest priority after sensors.
@@ -73,7 +73,7 @@ static constexpr wq_config_t INS1{"wq:INS1", 6000, -15};
 static constexpr wq_config_t INS2{"wq:INS2", 6000, -16};
 static constexpr wq_config_t INS3{"wq:INS3", 6000, -17};

-static constexpr wq_config_t hp_default{"wq:hp_default", 1900, -18};
+static constexpr wq_config_t hp_default{"wq:hp_default", 4600, -18};

 static constexpr wq_config_t uavcan{"wq:uavcan", 3624, -19};

diff --git a/platforms/common/uORB/SubscriptionInterval.hpp b/platforms/common/uORB/SubscriptionInterval.hpp
index 36e629f26d..93734c4670 100644
--- a/platforms/common/uORB/SubscriptionInterval.hpp
+++ b/platforms/common/uORB/SubscriptionInterval.hpp
@@ -53,7 +53,7 @@ namespace uORB
 {

 // Base subscription wrapper class
-class SubscriptionInterval
+class  SubscriptionInterval
 {
 public:

diff --git a/platforms/posix/Debug/launch_sim.json.in b/platforms/posix/Debug/launch_sim.json.in
index f10f425efd..1a7504b9bc 100644
--- a/platforms/posix/Debug/launch_sim.json.in
+++ b/platforms/posix/Debug/launch_sim.json.in
@@ -154,7 +154,11 @@
               "tailsitter",
               "tiltrotor",
               "r1_rover",
-              "boat"
+              "boat",
+	          "ductedfan2",
+              "ductedfan4",
+              "ductedfan6",
+              "ductedfan_mini"
             ],
             "default": "iris"
           }
diff --git a/platforms/posix/cmake/sitl_target.cmake b/platforms/posix/cmake/sitl_target.cmake
index f1ef214642..e3e6d9193a 100644
--- a/platforms/posix/cmake/sitl_target.cmake
+++ b/platforms/posix/cmake/sitl_target.cmake
@@ -133,6 +133,10 @@ set(models
 	typhoon_h480
 	uuv_bluerov2_heavy
 	uuv_hippocampus
+	ductedfan2
+	ductedfan4
+	ductedfan6
+	ductedfan_mini
 )

 set(worlds
diff --git a/src/drivers/imu/bosch/bmi055/BMI055_Gyroscope.cpp b/src/drivers/imu/bosch/bmi055/BMI055_Gyroscope.cpp
index 6a18c2a7c5..3791cc492b 100644
--- a/src/drivers/imu/bosch/bmi055/BMI055_Gyroscope.cpp
+++ b/src/drivers/imu/bosch/bmi055/BMI055_Gyroscope.cpp
@@ -72,7 +72,20 @@ void BMI055_Gyroscope::print_status()
 {
 	I2CSPIDriverBase::print_status();

-	PX4_INFO("FIFO empty interval: %d us (%.1f Hz)", _fifo_empty_interval_us, 1e6 / _fifo_empty_interval_us);
+	const float min_interval = FIFO_SAMPLE_DT;
+	PX4_INFO("min_interval: %.1f us",(double) min_interval);
+	PX4_INFO("FIFO_SAMPLE_DT: %.1f us (FIFO_MAX_SAMPLES %d)", (double) FIFO_SAMPLE_DT, FIFO_MAX_SAMPLES);
+	_fifo_empty_interval_us = math::max(roundf((1e6f / (float)_px4_gyro.get_max_rate_hz()) / min_interval) * min_interval, min_interval);
+
+	PX4_INFO("FIFO get_max_rate_hz: %d hz ", _px4_gyro.get_max_rate_hz());
+	PX4_INFO("FIFO empty interval: %d us (%.1f Hz, samples:%.1f)", _fifo_empty_interval_us, (double) (1e6 / _fifo_empty_interval_us), (double)(_fifo_empty_interval_us / (1e6f / RATE)));
+
+	_fifo_samples = math::min((float)_fifo_empty_interval_us / (1e6f / RATE), (float)FIFO_MAX_SAMPLES);
+	PX4_INFO("FIFO _fifo_samples: %d ", _fifo_samples);
+	// recompute FIFO empty interval (us) with actual sample limit
+	_fifo_empty_interval_us = _fifo_samples * (1e6f / RATE);
+
+	PX4_INFO("FIFO empty interval: %d us (%.1f Hz)", _fifo_empty_interval_us, (double) (1e6 / _fifo_empty_interval_us));

 	perf_print_counter(_bad_register_perf);
 	perf_print_counter(_bad_transfer_perf);
diff --git a/src/drivers/imu/invensense/icm20689/ICM20689.cpp b/src/drivers/imu/invensense/icm20689/ICM20689.cpp
index e974f0d81e..afae46abc4 100644
--- a/src/drivers/imu/invensense/icm20689/ICM20689.cpp
+++ b/src/drivers/imu/invensense/icm20689/ICM20689.cpp
@@ -96,7 +96,31 @@ void ICM20689::print_status()
 {
 	I2CSPIDriverBase::print_status();

-	PX4_INFO("FIFO empty interval: %d us (%.1f Hz)", _fifo_empty_interval_us, 1e6 / _fifo_empty_interval_us);
+	// PX4_INFO("FIFO empty interval: %d us (%.1f Hz)", _fifo_empty_interval_us, 1e6 / _fifo_empty_interval_us);
+
+	// round down to nearest FIFO sample dt * SAMPLES_PER_TRANSFER
+	const float min_interval = FIFO_SAMPLE_DT * SAMPLES_PER_TRANSFER;
+
+	PX4_INFO("FIFO_SAMPLE_DT: %.1f us (SAMPLES_PER_TRANSFER %d FIFO_MAX_SAMPLES %d)", (double) FIFO_SAMPLE_DT, SAMPLES_PER_TRANSFER, FIFO_MAX_SAMPLES);
+	PX4_INFO("min_interval: %.1f us", (double) min_interval);
+	PX4_INFO("FIFO get_max_rate_hz: %d hz, %.1f us.", _px4_gyro.get_max_rate_hz(), (double) (1e6f / (float)_px4_gyro.get_max_rate_hz()));
+
+	_fifo_empty_interval_us = math::max(roundf((1e6f / (float)_px4_gyro.get_max_rate_hz()) / min_interval) * min_interval, min_interval);
+
+
+
+	PX4_INFO("FIFO _fifo_empty_interval_us by IMU_GYRO_RATEMAX: %d us (%.1f Hz, samples:%.1f)", _fifo_empty_interval_us, (double) (1e6 / _fifo_empty_interval_us), (double) (_fifo_empty_interval_us / (1e6f / GYRO_RATE)));
+
+
+	_fifo_gyro_samples = roundf(math::min((float)_fifo_empty_interval_us / (1e6f / GYRO_RATE), (float)FIFO_MAX_SAMPLES));
+
+
+	PX4_INFO("FIFO _fifo_gyro_samples: %d ", _fifo_gyro_samples);
+
+	// recompute FIFO empty interval (us) with actual gyro sample limit
+	_fifo_empty_interval_us = _fifo_gyro_samples * (1e6f / GYRO_RATE);
+
+	PX4_INFO("FIFO final empty interval: %d us (%.1f Hz)", _fifo_empty_interval_us, (double) (1e6 / _fifo_empty_interval_us));

 	perf_print_counter(_bad_register_perf);
 	perf_print_counter(_bad_transfer_perf);
diff --git a/src/drivers/pwm_out/PWMOut.cpp b/src/drivers/pwm_out/PWMOut.cpp
index 4aea51383e..fd3c75250e 100644
--- a/src/drivers/pwm_out/PWMOut.cpp
+++ b/src/drivers/pwm_out/PWMOut.cpp
@@ -642,7 +642,7 @@ void PWMOut::Run()
 		_parameter_update_sub.copy(&pupdate);

 		// update parameters from storage
-		// update_params(); // do not update PWM params for now (was interfering with VTOL PWM settings)
+		update_params(); // do not update PWM params for now (was interfering with VTOL PWM settings)
 	}

 	if (_current_update_rate == 0) {
@@ -2217,7 +2217,8 @@ int PWMOut::print_status()
 		PX4_INFO("%d - PWM_EXTRA 0x%04" PRIx32, _instance, _pwm_mask);
 	}

-	PX4_INFO("%d - Max update rate: %i Hz", _instance, _current_update_rate);
+	PX4_INFO("%d - Max update rate(_current_update_rate): %i Hz", _instance, _current_update_rate);
+	PX4_INFO("instance: %d, default: %d, alt: %d", _instance, _pwm_default_rate, _pwm_alt_rate);

 	const char *mode_str = nullptr;

diff --git a/src/drivers/px4io/px4io.cpp b/src/drivers/px4io/px4io.cpp
index 2cb9984496..5cb7d958d0 100644
--- a/src/drivers/px4io/px4io.cpp
+++ b/src/drivers/px4io/px4io.cpp
@@ -2202,7 +2202,7 @@ PX4IO::io_publish_pwm_outputs()
 		outputs.output[i] = ctl[i];
 	}

-	_to_outputs.publish(outputs);
+	_to_outputs.publish(outputs);  // 50hz

 	/* get mixer status flags from IO */
 	MultirotorMixer::saturation_status saturation_status;
diff --git a/src/examples/work_item/WorkItemExample.cpp b/src/examples/work_item/WorkItemExample.cpp
index 33d2c4258b..381804e41a 100644
--- a/src/examples/work_item/WorkItemExample.cpp
+++ b/src/examples/work_item/WorkItemExample.cpp
@@ -35,7 +35,7 @@

 WorkItemExample::WorkItemExample() :
 	ModuleParams(nullptr),
-	ScheduledWorkItem(MODULE_NAME, px4::wq_configurations::test1)
+	ScheduledWorkItem(MODULE_NAME, px4::wq_configurations::hp_default)
 {
 }

diff --git a/src/lib/mixer/MultirotorMixer/MultirotorMixer.cpp b/src/lib/mixer/MultirotorMixer/MultirotorMixer.cpp
index 92780e977c..d3cb22af69 100644
--- a/src/lib/mixer/MultirotorMixer/MultirotorMixer.cpp
+++ b/src/lib/mixer/MultirotorMixer/MultirotorMixer.cpp
@@ -324,7 +324,7 @@ MultirotorMixer::mix(float *outputs, unsigned space)
 	float pitch   = math::constrain(get_control(0, 1), -1.0f, 1.0f);
 	float yaw     = math::constrain(get_control(0, 2), -1.0f, 1.0f);
 	float thrust  = math::constrain(get_control(0, 3), 0.0f, 1.0f);
-
+	// printf("roll: %f, pitch: %f, yaw: %f \n", (double) roll, (double) pitch, (double) yaw);
 	// clean out class variable used to capture saturation
 	_saturation_status.value = 0;

diff --git a/src/lib/mixer/SimpleMixer/SimpleMixer.cpp b/src/lib/mixer/SimpleMixer/SimpleMixer.cpp
index 270b77ffcf..f26d490137 100644
--- a/src/lib/mixer/SimpleMixer/SimpleMixer.cpp
+++ b/src/lib/mixer/SimpleMixer/SimpleMixer.cpp
@@ -360,7 +360,7 @@ SimpleMixer::scale(const mixer_scaler_s &scaler, float input)
 		output = (input * scaler.positive_scale) + scaler.offset;
 	}

-	return math::constrain(output, scaler.min_output, scaler.max_output);
+	return math::constrain(output, scaler.min_output, scaler.max_output); // constrain controller output
 }

 int
diff --git a/src/lib/mixer_module/CMakeLists.txt b/src/lib/mixer_module/CMakeLists.txt
index e451b22b31..c4e6b86d8d 100644
--- a/src/lib/mixer_module/CMakeLists.txt
+++ b/src/lib/mixer_module/CMakeLists.txt
@@ -31,4 +31,4 @@
 #
 ############################################################################

-px4_add_library(mixer_module mixer_module.cpp)
+px4_add_library(mixer_module mixer_module.cpp wls_alloc_gen.c  wls_alloc_gen_emxutil.c)
diff --git a/src/lib/mixer_module/ControlAllocation.h b/src/lib/mixer_module/ControlAllocation.h
new file mode 100644
index 0000000000..f8151112b5
--- /dev/null
+++ b/src/lib/mixer_module/ControlAllocation.h
@@ -0,0 +1,1845 @@
+
+#include <matrix/math.hpp>
+// #include <iostream>
+#include <stdlib.h>
+// #include <limits>
+using namespace matrix;
+#if !defined(FLT_MAX)
+#define FLT_MAX     __FLT_MAX__
+#endif
+
+// Add the min_user function definition here
+template<typename Type, size_t M, size_t N>
+inline void min_user(const Matrix<Type, M, N> &x, Type &x_min, size_t &x_index)
+{
+    const Matrix<Type, M, N> &self = x;
+    x_min = self(0, 0);
+    x_index = 0;
+
+    for (size_t i = 0; i < M; ++i) {
+        for (size_t j = 0; j < N; ++j) {
+            if (self(i, j) < x_min) {
+                x_min = self(i, j);
+                x_index = i; // Assuming that you want the index along the row
+            }
+        }
+    }
+}
+// 计算 rho 的函数, for DPscaled_LPCA
+const int SIZE_ydt = 3; // 假设 ydt 是一个包含 5 个元素的一维数组
+const int SIZE_Bt_row = 3; // 假设 Bt 是一个 5x5 的二维数组
+const int SIZE_Bt_col = 4;
+//rho = ydt'*Bt*u/(ydt'*ydt)
+inline float calculateRho(float ydt[], float u[], float Bt[][SIZE_Bt_col], float tol) {
+    float numerator = 0.0f;
+    float denominator = 0.0f;
+    float ydt_T_Bt[SIZE_Bt_col];
+    for (int j = 0; j < SIZE_Bt_col; ++j) {
+        ydt_T_Bt[j] = 0;
+        for (int k = 0; k < SIZE_ydt; ++k) { //or < SIZE_Bt_row
+            ydt_T_Bt[j] += ydt[k] * Bt[k][j];
+        }
+    }
+    for (int k = 0; k < SIZE_Bt_col; ++k) {
+        numerator += ydt_T_Bt[k] * u[k];
+    }
+    // 计算 ydt 的2范数
+    // std::cout << "ydt: [";
+    //     for (size_t i = 0; i < SIZE_ydt; ++i) {
+    //         std::cout << ydt[i];
+    //         if (i < SIZE_ydt - 1) {
+    //             std::cout << ", ";
+    //         }
+    //     }
+    //     std::cout << "]" << std::endl;
+    for (int i = 0; i < SIZE_ydt; ++i) {
+        denominator += ydt[i] * ydt[i];
+        // std::cout <<"denominator"<< denominator<< std::endl;
+    }
+    // 避免除以零  // ydt的模不会很小
+    // std::cout <<"denominator"<< denominator<< std::endl;
+    // std::cout <<"fabs(denominator)"<< fabs(denominator)<< std::endl;
+    // std::cout <<"tol"<< tol<< std::endl;
+    float relativeEpsilon = tol * fabs(numerator); // 动态阈值
+
+    // //或者
+    // const double ABSOLUTE_EPSILON = 1e-10;
+    // const double RELATIVE_EPSILON = 1e-10;
+
+    // double safeDivide(double numerator, double denominator) {
+    //     if (abs(denominator) < ABSOLUTE_EPSILON) {
+    //         if (abs(denominator) < RELATIVE_EPSILON * abs(numerator)) {
+    //             throw invalid_argument("Denominator is too close to zero compared to the numerator.");
+    //         }
+    //     }
+    //     return numerator / denominator;
+    // }
+
+    if (fabs(denominator) < relativeEpsilon ) {
+        // std::cerr << "Error: Division by zero." << std::endl;
+        return 1.0f;
+    }
+    // 计算 rho
+    return numerator / denominator;
+}
+
+// 函数用于计算两个正整数集合的差
+inline void setdiff(int setA[], int sizeA, int setB[], int sizeB, int result[]) {
+    int sizeResult = 0;
+    for (int i = 0; i < sizeA; ++i) {
+        bool foundInB = false;
+        // 检查当前 setA 中的元素是否在 setB 中
+        for (int j = 0; j < sizeB; ++j) {
+            if (setA[i] == setB[j]) {
+                foundInB = true;
+                break;
+            }
+        }
+        // 如果当前元素不在 setB 中，则将其添加到结果中
+        if (!foundInB) {
+            result[sizeResult++] = setA[i];
+        }
+    }
+}
+
+// 定义线性规划问题结构体
+template<int M, int N>
+struct LinearProgrammingProblem {
+    int m=M;
+    int n=N;
+    int inB[M];
+    int inD[N-M]; //
+    int itlim;
+    float A[M][N];
+    float b[N];
+    float c[N];
+    float h[N];
+    bool e[N];
+    float tol=10*FLT_EPSILON; // important value, if control surface saturation, Use a larger value
+    // 默认构造函数，将所有成员变量初始化为0
+    LinearProgrammingProblem() : m(M), n(N), itlim(0) {
+        // 将数组成员变量初始化为0
+        for (int i = 0; i < M; ++i) {
+            inB[i] = 0;
+        }
+        for (int i = 0; i < N-M; ++i) {
+            inD[i] = 0;
+        }
+        for (int i = 0; i < M; ++i) {
+            for (int j = 0; j < N; ++j) {
+                A[i][j] = 0.0f;
+            }
+        }
+        for (int i = 0; i < N; ++i) {
+            b[i] = 0.0f;
+            c[i] = 0.0f;
+            h[i] = 0.0f;
+            e[i] = false;
+        }
+    }
+    // 赋值运算符
+    LinearProgrammingProblem& operator=(const LinearProgrammingProblem& other) {
+        if (this != &other) {
+            m = other.m;
+            n = other.n;
+            itlim = other.itlim;
+            tol = other.tol;
+            // 复制数组成员变量
+            for (int i = 0; i < M; ++i) {
+                inB[i] = other.inB[i];
+            }
+            for (int i = 0; i < N - M; ++i) {
+                inD[i] = other.inD[i];
+            }
+            for (int i = 0; i < M; ++i) {
+                for (int j = 0; j < N; ++j) {
+                    A[i][j] = other.A[i][j];
+                }
+            }
+            for (int i = 0; i < N; ++i) {
+                b[i] = other.b[i];
+                c[i] = other.c[i];
+                h[i] = other.h[i];
+                e[i] = other.e[i];
+            }
+        }
+        return *this;
+    }
+    // 拷贝构造函数
+    LinearProgrammingProblem(const LinearProgrammingProblem<M, N>& other) {
+        m = other.m;
+        n = other.n;
+        itlim = other.itlim;
+        tol = other.tol;
+        // 复制数组成员变量
+        for (int i = 0; i < M; ++i) {
+            inB[i] = other.inB[i];
+        }
+        for (int i = 0; i < N - M; ++i) {
+            inD[i] = other.inD[i];
+        }
+        for (int i = 0; i < M; ++i) {
+            for (int j = 0; j < N; ++j) {
+                A[i][j] = other.A[i][j];
+            }
+        }
+        for (int i = 0; i < N; ++i) {
+            b[i] = other.b[i];
+            c[i] = other.c[i];
+            h[i] = other.h[i];
+            e[i] = other.e[i];
+        }
+    }
+};
+// 定义结果结构体
+template<int M, int N>
+struct LinearProgrammingResult {
+    float y0[M];
+    int inB[M];
+    bool e[N];
+    int iters;
+    bool errout;
+    // 其他结果成员
+    // 默认构造函数，将所有成员变量初始化为0
+    LinearProgrammingResult() : iters(0), errout(false) {
+        // 将数组成员变量初始化为0
+        for (int i = 0; i < M; ++i) {
+            y0[i] = 0.0f;
+            inB[i] = 0;
+        }
+        for (int i = 0; i < N; ++i) {
+            e[i] = false;
+        }
+    }
+    // 拷贝构造函数
+    LinearProgrammingResult(const LinearProgrammingResult<M, N>& other) {
+        // 将成员变量从另一个对象复制到当前对象
+        for (int i = 0; i < M; ++i) {
+            y0[i] = other.y0[i];
+            inB[i] = other.inB[i];
+        }
+        for (int i = 0; i < N; ++i) {
+            e[i] = other.e[i];
+        }
+        iters = other.iters;
+        errout = other.errout;
+    }
+};
+
+
+// 定义函数模板，修正单纯形算法实现。要求A行满秩，求解问题前已知inB和e，即需要找到一个初始基本可行解开始算法迭代。e=0表示该初始解在上限h上，否则就是0
+// see A.6.3 Simplex Method[1]. this function reimplement the simplxuprevsol of this book:
+// [1] W. Durham, K. A. Bordignon, and R. Beck, Aircraft control allocation. none: John Wiley & Sons, 2017.
+// and you can download the code on:
+template<int M, int N>
+LinearProgrammingResult<M, N> BoundedRevisedSimplex(LinearProgrammingProblem<M, N> problem) {
+    // Bounded Revised Simplex
+
+    // function [yout, inBout,eout, itout,errout] = simplxuprevsol(A,ct,b,inB,inD,h,e,m,n,itlim)
+
+    // Solves the linear program:
+    //         minimize c'y
+    //         subject to
+    //         Ay = b
+    //         0<= y <= h
+
+    // Inputs:
+    //         A [m,n]   = lhs Matrix of equaltity constraints
+    //         ct [1,n]  = transpose of cost vector
+    //         b [m,1]   = rhs vector for equality constraint
+    //         inB [m]   = Vector of indices of unknowns in the initial basic set
+    //         inD [n-m] = Vector of indices of unknowns not in the initial basic set
+    //         h[n,1]    = Upper Bound for unknowns
+    //         e[n,1]    = Sign for unknown variables (+ lower bound, - upper bound)
+    // Optional inputs:
+    //         m,n       = number of constraints, unknowns (Opposite standard
+    //                     CA convention
+    //         itlim     = Upper bound on the allowed iterations
+
+    // Outputs:
+    //         yout[n,1]  = Optimal output variable
+    //         inBout     = indices of Basic vectors in output
+    //         eout       = sign associate with output unknowns
+    //         itout      = number of iterations remaining out of itlim
+    //         errout     = Flag (=true) if unbounded is set
+
+    // Modification History
+    // 2002      Roger Beck  Original
+    // 8/2014    Roger Beck  Update for use
+    // 9/2014    Roger Beck  Added anti-cycling rule
+    // 4/2024
+
+    LinearProgrammingResult<M, N> result;
+    // 使用 problem.inB, problem.inD, problem.itlim, problem.A, problem.b, problem.c, problem.h, problem.e, problem.tol
+    const int n_m=N-M;
+    // Index list for non-basic variables, that is 1 2 3 4 ... n
+    int nind[n_m];
+    for (int num = 0, index = 0; num < n_m; ++num, ++index) {
+        nind[index] = num;
+    }
+    // Index list for all variables
+    int ind_all[N];
+    for (int num = 0, index = 0; num < N; ++num, ++index) {
+        ind_all[index] = num;
+    }
+    // Partition A, we have inD, which the element in ind_all but not in inB
+    setdiff(ind_all, N, problem.inB, M, problem.inD);
+    //djust signs problem if variables are initialized at upper bounds.
+    for(int i=0; i<M; ++i)
+    {
+        for(int j=0; j<N; ++j)
+        {
+            if(!problem.e[j])
+            {
+                problem.A[i][j] *=-1;
+                problem.b[i]+=problem.A[i][j]*problem.h[j];
+            }
+        }
+    }
+    for(int j=0; j<N; ++j)
+    {
+        if(!problem.e[j])
+        {
+            problem.c[j] *=-1;
+        }
+    }
+    //==============================
+    matrix::SquareMatrix<float, M> A_inB;
+    matrix::Matrix<float, M, n_m> A_inD;
+    matrix::Vector<float, M> c_inB;
+    matrix::Vector<float, n_m> c_inD;
+    //===============use inB and inD to inital==============
+    for(int i=0; i<M; ++i)
+    {
+        for(int j=0; j<M; ++j)
+        {
+            A_inB(i,j)=problem.A[i][problem.inB[j]];
+        }
+        c_inB(i)=problem.c[problem.inB[i]];
+    }
+    for(int i=0; i<M; ++i)
+    {
+        for(int j=0; j<N-M; ++j)
+        {
+            A_inD(i,j)=problem.A[i][problem.inD[j]];
+        }
+    }
+    for(int i=0; i<N-M; ++i)
+    {
+        c_inD(i)=problem.c[problem.inD[i]];
+    }
+    matrix::Vector<float, M> b_vec(problem.b);
+    // inital some value
+    Matrix<float, 1, M> lamt;
+    lamt.setZero();
+    Matrix<float, 1, n_m> rdt;
+    rdt.setZero();
+    matrix::Vector<float, M> A_qel;
+    A_qel.setZero();
+    matrix::Vector<float, M> yq;
+    yq.setZero();
+    matrix::Vector<float, M> rat;
+    rat.setZero();
+    //==============================
+    //  %Initial Solution
+    matrix::LeastSquaresSolver<float, M,M> LSsolver0(A_inB);
+    matrix::Vector<float, M> y0 = LSsolver0.solve(b_vec);
+    // Initialize Loop Termination Conditionss
+    bool done = false;
+    bool unbounded = false;
+    int iters =0;
+     while ((!done  || !unbounded ) && (iters <= problem.itlim))
+    {
+        iters = iters+1;
+        // Calculate transpose of relative cost vector based on current basis
+        matrix::LeastSquaresSolver<float, M,M> LSsolver_lamt(A_inB.transpose());
+        lamt = LSsolver_lamt.solve(c_inB).transpose();
+        rdt = c_inD.transpose()-lamt*A_inD;
+        float minr;
+        size_t qind;
+        // Find minimum relative cost
+        min_user(rdt.transpose(), minr, qind);
+        if(minr >=0)  // If all relative costs are positive then the solution is optimal. have to compare with 0 !
+        {
+            done = true;
+            break;
+        }
+        int qel = problem.inD[qind];  // Unknown to Enter the basis minimizes relative cost
+        for(int i=0;i<problem.m;++i){
+            A_qel(i)=problem.A[i][qel];
+        }
+        matrix::LeastSquaresSolver<float, M,M> LSsolver1(A_inB);
+        yq = LSsolver1.solve(A_qel); // Vector to enter in terms of the current Basis vector
+         // Check wether all the abs of yq[i] is greater than tol.
+        bool flag=false;
+        for(int i=0;i<M;++i){
+            if(fabs(yq(i)) > problem.tol)
+            {
+                flag = true;
+                break;
+            }
+        }
+        if(!flag)
+        {
+            unbounded = true; // Check this condition
+            break;
+        }
+        // Compute ratio how much each current basic variable will have to move for the entering variable.
+        // careful here
+        float hinB[M];
+        for(int i=0;i<M;++i)
+        {
+            if(fabs(yq(i))>problem.tol)
+            {
+                rat(i)=y0(i)/yq(i);
+                hinB[i]=problem.h[problem.inB[i]];
+                // If yq < 0 then increasing variable when it leaves the basis will minimize cost
+                if(yq(i)<0 ) // have to be compare with 0!!!
+                {
+                    rat(i)-=hinB[i]/yq(i);
+                }
+            }
+            else // If an element yq ~=0 then it doesn't change for the entering variable and shouldn't be chosen
+            {
+                rat(i)=INFINITY;
+            }
+        }
+         // Variable to exit is moving to its minimum value--Note that min_user returns the lowest index minimum
+        float minrat=rat(0);
+        size_t p=0;
+        min_user(rat, minrat, p);
+        // If the minimum ratio is zero, then the solution is degenerate and the entering
+        // variable will not change the basis---invoke Bland's selection rule to avoid
+        // cycling.
+        if (fabs(minrat) <= problem.tol)
+        {
+            // Find negative relative cost
+            for(int i=0;i<N-M;++i)
+            {
+                // indm is the index of rdt < 0, qind is the fisrt one.
+                if(rdt(0,i)<0){ // Note that since minr <0 indm is not empty
+                    qind=nind[i];
+                    qel = problem.inD[qind];// Unknown to Enter the basis is first indexed to avoid cycling
+                    break;
+                }
+            }
+            for(int i=0;i<problem.m;++i){
+                A_qel(i)=problem.A[i][qel];
+            }
+            matrix::LeastSquaresSolver<float, M,M> LSsolver2(A_inB);
+            yq = LSsolver2.solve(A_qel); // Vector to enter in terms of the current Basis vector
+            bool flag1=false;
+            for(int i=0;i<M;++i){
+                if(fabs(yq(i)) > problem.tol)
+                {
+                    flag1 = true;
+                    break;
+                }
+            }
+            if(!flag1)
+            {
+                unbounded = true; // Check this condition
+                break;
+            }
+            // Recompute rations and determine variable to leave
+            float hinB1[M];
+            for(int i=0;i<M;++i)
+            {
+                hinB1[i]=problem.h[problem.inB[i]];
+                if(fabs(yq(i))>problem.tol)
+                {
+                    rat(i)=y0(i)/yq(i);
+                    if(yq(i)<0) // If yq < 0 then increasing variable when it leaves the basis will minimize cost
+                    {
+                        rat(i)-=hinB1[i]/yq(i);
+                    }
+                }
+                else
+                {
+                    rat(i)=INFINITY; // If an element yq ~=0 then it doesn't change for the entering variable and shouldn't be chosen
+                }
+            }
+            // Variable to exit is moving to its minimum value--Note that min_user returns the lowest index minimum
+            minrat=rat(0);
+            p=0;
+            min_user(rat, minrat, p);
+        }
+        // Maintain the bounded simplex as only having lower bounds by recasting any variable that needs to move to its opposite bound.
+        if (minrat >= problem.h[qel])
+        {
+            // Case 1: Entering variable goes to opposite bound and current basis is maintained
+            problem.e[qel] =!problem.e[qel];
+            for(int i=0; i<M; ++i)
+            {
+                problem.A[i][qel] *= -1;
+                b_vec(i)+=problem.A[i][qel]*problem.h[qel];
+            }
+            problem.c[qel] *= -1;
+
+            for(int i=0; i<M; ++i)
+            {
+                A_inD(i,qind)=problem.A[i][qel];
+            }
+            c_inD(qind)=problem.c[qel];
+
+
+        }
+        else if(yq(p) > 0)
+        {
+            // Case 2: Leaving variable returns to lower bound (0)
+            int pel = problem.inB[p];
+            problem.inB[p]= qel;
+            problem.inD[qind]= pel;
+            // update x_inX
+            for(int i=0; i<M; ++i)
+            {
+                A_inB(i,p)=problem.A[i][qel];
+            }
+            for(int i=0; i<n_m; ++i)
+            {
+                c_inB(p)=problem.c[qel];
+            }
+            for(int i=0; i<M; ++i)
+            {
+                A_inD(i,qind)=problem.A[i][pel];
+            }
+            for(int i=0; i<n_m; ++i)
+            {
+                c_inD(qind)=problem.c[pel];
+            }
+        }
+        else
+        {
+            // Case 2: Leaving variable moves to upper bound
+            int pel = problem.inB[p];
+            problem.e[pel]=!problem.e[pel];
+            for(int i=0; i<M; ++i)
+            {
+                problem.A[i][pel] *= -1;
+                b_vec(i)+=problem.A[i][pel]*problem.h[pel];
+                problem.b[i]=b_vec(i);
+
+            }
+            problem.inB[p]= qel;
+            problem.inD[qind]= pel;
+            problem.c[pel] *= -1;
+            // update x_inX
+            for(int i=0; i<M; ++i)
+            {
+                A_inB(i,p)=problem.A[i][qel];
+            }
+
+            for(int i=0; i<n_m; ++i)
+            {
+                c_inB(p)=problem.c[qel];
+            }
+            for(int i=0; i<M; ++i)
+            {
+                A_inD(i,qind)=problem.A[i][pel];
+            }
+            for(int i=0; i<n_m; ++i)
+            {
+                c_inD(qind)=problem.c[pel];
+            }
+
+        }
+        //  Compute new Basic solution;
+        matrix::LeastSquaresSolver<float, M,M> LSsolver(A_inB);
+        y0 = LSsolver.solve(b_vec);
+    }
+    result.errout = unbounded;
+    // 设置 result.y0, result.inB, result.e 等结果
+    for(int i=0; i<M; ++i)
+    {
+        result.y0[i]=y0(i);
+        result.inB[i]=problem.inB[i];
+    }
+    for(int i=0; i<N; ++i)
+    {
+        result.e[i]=problem.e[i];
+    }
+    result.iters=iters;
+    return result;
+}
+
+
+
+
+// 飞行器基类模板
+template <int ControlSize, int EffectorSize>
+class AircraftBase {
+public:
+    float controlVector[EffectorSize]; // 操纵向量
+    float controlEffectMatrix[ControlSize][EffectorSize]; // 控制效应矩阵 (generalizedMomentSize X controlVectorSize)
+    float upperLimits[EffectorSize]; // 操纵向量上限变量
+    float lowerLimits[EffectorSize]; // 操纵向量下限变量
+    float BuMin[ControlSize];
+    // 构造函数
+    // 拷贝构造函数
+    AircraftBase(const AircraftBase& other) {
+        // 复制 controlVector
+        for (int i = 0; i < EffectorSize; ++i) {
+            controlVector[i] = other.controlVector[i];
+            upperLimits[i] = other.upperLimits[i];
+            lowerLimits[i] = other.lowerLimits[i];
+        }
+
+        // 复制 controlEffectMatrix
+        for (int i = 0; i < ControlSize; ++i) {
+            for (int j = 0; j < EffectorSize; ++j) {
+                controlEffectMatrix[i][j] = other.controlEffectMatrix[i][j];
+            }
+            BuMin[i]=other.BuMin[i];
+        }
+    }
+    AircraftBase() {
+        // 初始化 controlVector, controlEffectMatrix, generalizedMoment, upperLimits, lowerLimits 等数组
+        // 可以使用默认初始化或者自定义初始化方式
+        // 例如：
+        for (int i = 0; i < EffectorSize; ++i) {
+            controlVector[i] = 0.0f;
+            upperLimits[i] = 0.0f;
+            lowerLimits[i] = 0.0f;
+            for (int j = 0; j < ControlSize; ++j) {
+                controlEffectMatrix[j][i] = 0.0f;
+            }
+            BuMin[i]=0;
+        }
+    }
+    // 析构函数
+    ~AircraftBase() {
+        // 不需要手动释放内存，因为数组是在栈上分配的，会在对象生命周期结束时自动释放
+    }
+};
+
+// 飞行器类模板, 不同飞机定义新的类继承基类
+template <int ControlSize, int EffectorSize>
+class Aircraft : public AircraftBase<ControlSize, EffectorSize> {
+private:
+    // 添加特定飞行器类型的模型参数
+public:
+    // 构造函数
+    // 拷贝构造函数
+    // 拷贝构造函数
+    Aircraft(const Aircraft& other) : AircraftBase<ControlSize, EffectorSize>(other) {
+        // 将其他对象的成员变量值复制到新对象中
+        l1 = other.l1;
+        l2 = other.l2;
+        k_v = other.k_v;
+        upper = other.upper;
+        lower = other.lower;
+    }
+    Aircraft() : AircraftBase<ControlSize, EffectorSize>() {
+        // 可选的初始化代码
+        l1=0;
+        l2=0;
+        k_v=0;
+    }
+    // 构造函数，接受对应于飞行器类模板参数的初始化参数
+    Aircraft(const float (&controlEffectMatrixInit)[ControlSize][EffectorSize],
+             const float (&upperLimitsInit)[EffectorSize],
+             const float (&lowerLimitsInit)[EffectorSize]) {
+        // 使用传入的初始化参数对飞行器的数组成员进行初始化
+        for (int i = 0; i < EffectorSize; ++i) {
+            this->controlVector[i] = 0;
+            this->upperLimits[i] = upperLimitsInit[i];
+            this->lowerLimits[i] = lowerLimitsInit[i];
+            for (int j = 0; j < ControlSize; ++j) {
+                this->controlEffectMatrix[j][i] = controlEffectMatrixInit[j][i];
+            }
+        }
+        for (int i = 0; i < ControlSize; ++i) {
+            float temp = 0.0f;
+            for (int j = 0; j < EffectorSize; ++j) {
+                temp +=  this->controlEffectMatrix[i][j]*this->lowerLimits[j];
+            }
+            this->BuMin[i] = temp; // 计算BuMin
+        }
+    }
+    // 构造函数，接受对应于飞行器类模板参数的初始化参数
+    Aircraft(const float (&upperLimitsInit)[EffectorSize],
+             const float (&lowerLimitsInit)[EffectorSize]) {
+        // 使用传入的初始化参数和飞行器
+        for (int i = 0; i < EffectorSize; ++i) {
+            this->controlVector[i] = 0;
+            this->upperLimits[i] = upperLimitsInit[i];
+            this->lowerLimits[i] = lowerLimitsInit[i];
+            for (int j = 0; j < ControlSize; ++j) {
+                this->controlEffectMatrix[j][i] = 0;
+            }
+        }
+        // and define other value manual to set B (controlEffectMatrix).
+        for (int i = 0; i < ControlSize; ++i) {
+            float temp = 0.0f;
+            for (int j = 0; j < EffectorSize; ++j) {
+                temp +=  this->controlEffectMatrix[i][j]*this->lowerLimits[j];
+            }
+            this->BuMin[i] = temp; // 计算BuMin
+        }
+    }
+    Aircraft(const float (&controlEffectMatrixInit)[ControlSize][EffectorSize], const float& lowerBound, const float& upperBound) : lower(lowerBound), upper(upperBound){
+        // 使用传入的初始化参数和飞行器
+        for (int i = 0; i < EffectorSize; ++i) {
+            this->controlVector[i] = 0;
+            this->upperLimits[i] = upper;
+            this->lowerLimits[i] = lower;
+            for (int j = 0; j < ControlSize; ++j) {
+                this->controlEffectMatrix[j][i] = controlEffectMatrixInit[j][i];
+            }
+        }
+        for (int i = 0; i < ControlSize; ++i) {
+            float temp = 0.0f;
+            for (int j = 0; j < EffectorSize; ++j) {
+                temp +=  this->controlEffectMatrix[i][j]*this->lowerLimits[j];
+            }
+            this->BuMin[i] = temp; // 计算BuMin
+        }
+    }
+
+    // 设置模型参数函数
+    int num_control=ControlSize;
+    int num_effector=EffectorSize;
+    float l1;
+    float l2;
+    float k_v;
+    float lower;
+    float upper;
+
+    // 析构函数
+    ~Aircraft() {
+        // 如果有需要释放的资源，可以在这里添加代码
+    }
+
+    // 其他成员函数和成员变量定义
+};
+// 控制分配基类模板
+template <int ControlSize, int EffectorSize>
+class ControlAllocatorBase {
+public:
+    // 构造函数
+    ControlAllocatorBase() : aircraft() {
+        // 在此初始化成员变量，或者留空
+    }
+    // 参数列表构造函数
+    ControlAllocatorBase(const Aircraft<ControlSize, EffectorSize>& ac)
+        : aircraft(ac) {
+        // 使用传入的aircraft对象初始化aircraft成员
+    }
+
+    virtual void allocateControl(float input[ControlSize], float output[EffectorSize], int& err) = 0;
+
+    // 其他数学函数和成员变量定义
+    Aircraft<ControlSize, EffectorSize> aircraft; // 构造函数设置
+
+};
+// 控制分配类模板
+template <int ControlSize, int EffectorSize>
+class DP_LP_ControlAllocator : public ControlAllocatorBase<ControlSize, EffectorSize> {
+private:
+    // 添加算法设置参数
+public:
+    // 构造函数, 利用aircraft 预设置LinearProgrammingProblem
+    // 构造函数
+    DP_LP_ControlAllocator(const Aircraft<ControlSize, EffectorSize>& ac)
+        : ControlAllocatorBase<ControlSize, EffectorSize>(ac){
+        // 在此处用aircraft, generalizedMoment初始化 成员变量 DP_LPCA_problem 和 Pre_DP_LPCA_problem
+        // 线性规划数据
+        //=====================================DP_LPCA_problem================================
+        // float cs_max=this->aircraft.upperLimits[0]-this->aircraft.lowerLimits[0]; // 存储最大的绝对值
+        // for (int i = 0; i < ControlSize; ++i) {
+        //     float absValue = fabs(this->aircraft.upperLimits[i]-this->aircraft.lowerLimits[i]); // 计算 yd 中第 i 个元素的绝对值
+        //     if (absValue > cs_max) { // 如果当前绝对值大于 my，则更新 my 和 iy
+        //         cs_max = absValue;
+        //     }
+        // }
+        // upper_lam = cs_max/std::numeric_limits<float>::epsilon();
+        DP_LPCA_problem.itlim = 10;
+        for(int i=0; i<DP_LPCA_problem.n-1; ++i)
+        {
+            DP_LPCA_problem.c[i] = 0;
+        }
+        DP_LPCA_problem.c[DP_LPCA_problem.n-1] = -1;
+
+        DP_LPCA_problem.h[DP_LPCA_problem.n-1] = upper_lam;
+        // update A b h every time
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            for(int j=0; j<DP_LPCA_problem.n-1; ++j)
+            {
+                DP_LPCA_problem.A[i][j] = this->aircraft.controlEffectMatrix[i][j];
+            }
+            DP_LPCA_problem.A[i][DP_LPCA_problem.n-1] = 0;
+            DP_LPCA_problem.b[i] = -this->aircraft.BuMin[i];
+        }
+        for(int i=0; i<DP_LPCA_problem.n-1; ++i)
+        {
+            DP_LPCA_problem.h[i] = this->aircraft.upperLimits[i]-this->aircraft.lowerLimits[i];
+        }
+        //==================================PreDP_LPCA_problem================================
+        Pre_DP_LPCA_problem.itlim = 10;
+
+        //ci
+        for(int i=0; i<DP_LPCA_problem.n; ++i)
+        {
+            Pre_DP_LPCA_problem.c[i] =0;
+        }
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            Pre_DP_LPCA_problem.c[i+DP_LPCA_problem.n] = 1;
+        }
+        // inBi
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            Pre_DP_LPCA_problem.inB[i] = DP_LPCA_problem.n+i;
+        }
+        // ei
+        for(int i=0; i<DP_LPCA_problem.m+DP_LPCA_problem.n; ++i)
+        {
+            Pre_DP_LPCA_problem.e[i] = true;
+        }
+        //Ai bi=b
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            for(int j=0; j<DP_LPCA_problem.n; ++j)
+            {
+                Pre_DP_LPCA_problem.A[i][j] = DP_LPCA_problem.A[i][j];
+            }
+            Pre_DP_LPCA_problem.b[i] = DP_LPCA_problem.b[i]; // the same as DP_LPCA_problem
+
+        }
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            Pre_DP_LPCA_problem.A[i][i + DP_LPCA_problem.n] = (DP_LPCA_problem.b[i] > 0) ? 1 : -1; // sb = 2*(b > 0)-1; Ai = [A diag(sb)];
+        }
+        // hi
+        for(int i=0; i<DP_LPCA_problem.n; ++i)
+        {
+            Pre_DP_LPCA_problem.h[i] = DP_LPCA_problem.h[i];
+        }
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            Pre_DP_LPCA_problem.h[i+DP_LPCA_problem.n] = 2*fabs(DP_LPCA_problem.b[i]);
+        }
+        //================================== DPscaled_LPCA_problem ================================
+        DPscaled_LPCA_problem.itlim = 10;
+        float yd[3]={0.1,0.2,-0.1}; // random value for inital.
+        // update A b c h every time
+        float my=yd[0]; // 存储最大的绝对值
+        int iy=0; // 存储最大绝对值的索引
+        for (int i = 0; i < ControlSize; ++i) {
+            float absValue = fabs(yd[i]); // 计算 yd 中第 i 个元素的绝对值
+            if (absValue > my) { // 如果当前绝对值大于 my，则更新 my 和 iy
+                my = absValue;
+                iy = i;
+            }
+        }
+        // copy firstly !!!
+        float Bt[ControlSize][EffectorSize];
+        float ydt[ControlSize];
+
+        for(int i=0;i<ControlSize;++i){
+            for (int j = 0; j <EffectorSize; ++j) {
+                Bt[i][j] = this->aircraft.controlEffectMatrix[i][j];
+            }
+        }
+        for(int i=0;i<ControlSize;++i){
+            ydt[i]=yd[i];
+        }
+
+        // move
+        for(int j=0;j<EffectorSize;++j){
+            Bt[0][j] = this->aircraft.controlEffectMatrix[iy][j];
+            for (int i = iy; i >0; i--) {
+                Bt[i][j] = this->aircraft.controlEffectMatrix[i-1][j];
+            }
+        }
+        ydt[0] = yd[iy];
+        for (int j = iy; j >0; j--) {
+            ydt[j] = yd[j-1];
+        }
+        // swap 2 3 row of ydt
+        float ydt2=ydt[1];
+        ydt[1]=ydt[2];
+        ydt[2]=ydt2;
+        // swap 2 3 col of Bt
+        for(int i=0;i<EffectorSize;++i){
+            float Bt2=Bt[1][i];
+            Bt[1][i]=Bt[2][i];
+            Bt[2][i]=Bt2;
+        }
+        // M = [ydt(2:ControlSize) -ydt(1)*eye(ControlSize-1)];
+        float M[ControlSize-1][ControlSize];
+        // M[0][0]=ydt[1];
+        // M[1][0]=ydt[2];
+        // M[0][1]=-ydt[0];
+        // M[1][1]=0;
+        // M[0][2]=0;
+        // M[1][2]=-ydt[0];
+        // or
+        // 将 M 的所有元素初始化为0，并同时填充 M 的第一列和对角线元素
+        for (int i = 0; i < ControlSize - 1; ++i) {
+            for (int j = 0; j < ControlSize; ++j) {
+                if (j == 0) {
+                    // 填充 M 的第一列
+                    M[i][0] = ydt[i + 1];
+                } else if (j == i + 1) {
+                    // 填充对角线元素
+                    M[i][j] = -ydt[0];
+                } else {
+                    // 初始化其他元素为0
+                    M[i][j] = 0.0f;
+                }
+            }
+        }
+        for (int i = 0; i < ControlSize-1; ++i) {
+            for (int j = 0; j < EffectorSize; ++j) {
+                DPscaled_LPCA_problem.A[i][j] = 0;
+                for (int k = 0; k < ControlSize; ++k) {
+                    DPscaled_LPCA_problem.A[i][j] += M[i][k] * Bt[k][j];
+                }
+            }
+        }
+        for(int i=0; i<ControlSize-1; ++i)
+        {
+            float temp=0;
+            for(int j=0; j<EffectorSize; ++j)
+            {
+                temp += -DPscaled_LPCA_problem.A[i][j]*this->aircraft.lowerLimits[j];
+            }
+            DPscaled_LPCA_problem.b[i] = temp;
+        }
+        for (int i = 0; i < EffectorSize; ++i) {
+            DPscaled_LPCA_problem.c[i] = 0;
+            for (int j = 0; j < ControlSize; ++j) {
+                DPscaled_LPCA_problem.c[i] += -Bt[j][i] * ydt[j];
+            }
+        }
+        for (int i = 0; i < EffectorSize; ++i) {
+            DPscaled_LPCA_problem.h[i] = this->aircraft.upperLimits[i]-this->aircraft.lowerLimits[i];
+        }
+        //==================================Pre_DPscaled_LPCA_problem================================
+        Pre_DPscaled_LPCA_problem.itlim = 10;
+        for(int i=0; i<DPscaled_LPCA_problem.n; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.c[i] =0;
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.m; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.c[i+DPscaled_LPCA_problem.n] = 1;
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.m; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.inB[i] = DPscaled_LPCA_problem.n+i;
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.m+DPscaled_LPCA_problem.n; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.e[i] = true;
+        }
+        // update Ai bi hi every time
+        for(int i=0; i<DPscaled_LPCA_problem.m; ++i)
+        {
+            for(int j=0; j<DPscaled_LPCA_problem.n; ++j)
+            {
+                Pre_DPscaled_LPCA_problem.A[i][j] = DPscaled_LPCA_problem.A[i][j];
+            }
+            Pre_DPscaled_LPCA_problem.b[i] = DPscaled_LPCA_problem.b[i]; // the same as DPscaled_LPCA_problem
+
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.m; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.A[i][i + DPscaled_LPCA_problem.n] = (DPscaled_LPCA_problem.b[i] > 0) ? 1 : -1; // sb = 2*(b > 0)-1; Ai = [A diag(sb)];
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.n; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.h[i] = DPscaled_LPCA_problem.h[i];
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.m; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.h[i+DPscaled_LPCA_problem.n] = 2*fabs(DPscaled_LPCA_problem.b[i]);
+        }
+        //   for restoring
+        B_aug.setZero();
+        B.setZero();
+        for (int i = 0; i < ControlSize; ++i) {
+            for (int j = 0; j < EffectorSize; ++j) {
+                B_aug(i,j) = this->aircraft.controlEffectMatrix[i][j];
+                B(i,j) = this->aircraft.controlEffectMatrix[i][j];
+            }
+        }
+        v_aug.setZero();
+        v_aug(ControlSize)=a_constant;
+        u_null.setZero();
+    }
+    // 设置算法参数函数
+    // 析构函数
+    ~DP_LP_ControlAllocator() {
+        // 如果有需要释放的资源，可以在这里添加代码
+    }
+    // 最初测试算法使用本函数，由于DP_LPCA和4片舵涵道的特殊性，初始基本解是可以预先确定且不变的。所以可以省略第一步寻找基本初始解。后续可以将本函数改为切换使用DP_LPCA和DPscaled_LPCA。
+    void allocateControl(float input[ControlSize], float output[EffectorSize], int& err) override {
+        // 重写控制分配器函数
+        // 实现控制分配算法
+        // DP_LPCA（generalizedMoment, aircraft）
+        // DP_LPCA函数利用飞行器数据，将分配问题描述为DP_LP问题并用BoundedRevisedSimplex求解
+        // 使用模版函数result = BoundedRevisedSimplex(problem);
+        //=======================
+        bool flag=false;
+        for(int i=0;i<ControlSize;++i){
+            if(fabs(input[i]) > DP_LPCA_problem.tol)
+            {
+                flag = true; // Check this condition
+                break;
+            }
+        }
+        if(!flag){
+            for(int i=0;i<EffectorSize;++i){
+                output[i]=0;
+            }
+            err=-1;
+            return;
+        }
+        //=======================
+        //===========just for df4, we alway have to calc this by a new problem================
+        // we can call BoundedRevisedSimplex direct in allocationControl
+        DP_LPCA_problem.inB[0]=0;
+        DP_LPCA_problem.inB[1]=1;
+        DP_LPCA_problem.inB[2]=3;
+        DP_LPCA_problem.e[0] = true;
+        DP_LPCA_problem.e[1] = true;
+        DP_LPCA_problem.e[2] = false;
+        DP_LPCA_problem.e[3] = true;
+        DP_LPCA_problem.e[4] = true;
+        //=======================
+        // update A b h every time
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            float temp=0;
+            for(int j=0; j<DP_LPCA_problem.n-1; ++j)
+            {
+                DP_LPCA_problem.A[i][j] = this->aircraft.controlEffectMatrix[i][j];
+                temp += -this->aircraft.controlEffectMatrix[i][j]*this->aircraft.lowerLimits[j];
+            }
+            DP_LPCA_problem.A[i][DP_LPCA_problem.n-1] = -input[i];
+            this->generalizedMoment[i] = input[i]; // just record.
+            DP_LPCA_problem.b[i] = temp;
+        }
+        for(int i=0; i<DP_LPCA_problem.n-1; ++i)
+        {
+            DP_LPCA_problem.h[i] = this->aircraft.upperLimits[i]-this->aircraft.lowerLimits[i];
+        }
+
+        auto result = BoundedRevisedSimplex(DP_LPCA_problem);
+        // 使用结果
+        // result.y0, result.inB, result.e, result.errout
+        float xout[DP_LPCA_problem.n];
+        for(int i=0;i<DP_LPCA_problem.n;++i){
+            xout[i]=0;
+        }
+        for(int i=0;i<ControlSize;++i){
+            xout[result.inB[i]]=result.y0[i];
+        }
+        for(int i=0;i<DP_LPCA_problem.n;++i){
+            if(!result.e[i]){
+                xout[i]=-xout[i]+DP_LPCA_problem.h[i];
+            }
+        }
+        if(result.iters>=DP_LPCA_problem.itlim){
+            err = 3;
+        }
+        if(result.errout)
+        {
+            err = 1;
+        }
+        for(int i=0;i<EffectorSize;++i){
+            output[i]=xout[i]+this->aircraft.lowerLimits[i];
+        }
+        if(xout[EffectorSize]>1){
+            for(int i=0;i<EffectorSize;++i){
+                output[i]/=xout[EffectorSize];
+            }
+        }
+        return;
+    }
+    // To find an initial condition, many linear programming solvers treat the solution in two phases. Phase one solves a specially constructed problem designed to yield a basic feasible solution that is used to initialize the original problem in phase two.
+    // So we have DP_LPCA and DPscaled_LPCA
+    void DP_LPCA(float input[ControlSize], float output[EffectorSize], int& err, float & rho){
+        // Direction Preserving Control Allocation Linear Program
+
+        // function [u, errout] = DP_LPCA(yd,B,uMin,uMax,itlim,upper_lam);
+
+        // Solves the control allocation problem while preserving the
+        // objective direction for unattainable commands. The solution
+        // is found by solving the problem,
+        // min -lambda,
+        // s.t. B*u = lambda*yd, uMin<=u<=uMax, 0<= lambda <=1
+
+        // For yd outside the AMS, the solution returned is that the
+        // maximum in the direction of yd.
+
+        // For yd strictly inside the AMS, the solution achieves
+        // Bu=yd and m-n controls will be at their limits; but there
+        // is no explicit preference to which solution will be
+        // returned. This limits the usefulness of this routine as
+        // a practical allocator unless preferences for attainable solutions
+        // are handled externally.
+
+        // (For derivation of a similar formulation see A.1.2 and A.2.3 in the
+        // text)
+
+
+        // Inputs:
+        //         yd [n]    = Desired objective
+        //         B [n,m]   = Control Effectiveness matrix
+        //         uMin[m,1] = Lower bound for controls
+        //         uMax[m,1] = Upper bound for controls
+        //         itlim     = Number of allowed iterations limit
+        //                         (Sum of iterations in both branches)
+
+        // Outputs:
+        //         u[m,1]     = Control Solution
+        //         errout     = Error Status code
+        //                         0 = found solution
+        //                         <0 = Error in finding initial basic feasible solution
+        //                         >0 = Error in finding final solution
+        //                         -1,1 = Solver error (unbounded solution)
+        //                         -2   = Initial feasible solution not found
+        //                         -3,3 = Iteration limit exceeded
+        //         itlim      = Number of iterations remaining after solution found
+        //         upper_lam  = the upper limit of lambda
+
+        // Calls:
+        //         simplxuprevsol = Bounded Revised Simplex solver (simplxuprevsol.m)
+
+        // Notes:
+        // If errout ~0 there was a problem in the solution. %
+
+        // Error code < 0 implies an error in the initialization and there is no guarantee on
+        // the quality of the output solution other than the control limits.
+        // Error code > 0 for errors in final solution--B*u is in the correct direction and has
+        // magnitude < yd, but B*u may not equal yd (for yd attainable)
+        // or be maximized (for yd unattainable)
+
+        // Modification History
+        // 2002      Roger Beck  Original (DPcaLP8.m)
+        // 8/2014    Roger Beck  Update for use in text
+        // 4/2024       Implement in cpp
+
+        // DP_LPCA函数利用飞行器数据，将分配问题描述为DP_LP问题并用BoundedRevisedSimplex求解
+        //=======================
+        // Figure out how big the problem is (use standard CA definitions for m & n)
+        // but in here we use [m,k] = size(B) instead of [n,m] = size(B) in matlab. just for adapt to BoundedRevisedSimplex
+        // we use [m,n] = size(A) in BoundedRevisedSimplex, that is, k + 1 = n.
+        // Check to see if yd == 0
+        // May want to adjust the tolerance to improve numerics of later steps
+        bool flag=false;
+        for(int i=0;i<ControlSize;++i){
+            if(fabs(input[i]) > DP_LPCA_problem.tol)
+            {
+                flag = true; // Check this condition
+                break;
+            }
+        }
+        if(!flag){
+            for(int i=0;i<EffectorSize;++i){
+                output[i]=0;
+            }
+            err=-1;
+            return;
+        }
+        //=======================
+        // We inital this problem in constructor.
+        // Construct an LP using scaling parameter to enforce direction preserving
+        // To find Feasible solution construct problem with appended slack variables
+        // ref. is A.6.4 Initialization of the Simplex Algorithm of <Aircraft control allocation>
+
+        // now we update the problem by input data.
+        if(isupdate){
+            Update();
+            isupdate = false; // only update once.
+        }
+        // update A b h by input data.
+        // update sb(since b is update) Ai bi hi every time
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            DP_LPCA_problem.A[i][DP_LPCA_problem.n-1] = -input[i];
+            DP_LPCA_problem.b[i] = -this->aircraft.BuMin[i]; //
+
+            Pre_DP_LPCA_problem.A[i][DP_LPCA_problem.n-1] = -input[i]; // the same as DP_LPCA_problem.A[i][DP_LPCA_problem.n-1]
+            Pre_DP_LPCA_problem.b[i] = -this->aircraft.BuMin[i]; // the same as DP_LPCA_problem
+
+            Pre_DP_LPCA_problem.A[i][i + DP_LPCA_problem.n] = (DP_LPCA_problem.b[i] > 0) ? 1 : -1; // sb = 2*(b > 0)-1; Ai = [A diag(sb)];
+            Pre_DP_LPCA_problem.h[i+DP_LPCA_problem.n] = 2*fabs(DP_LPCA_problem.b[i]);
+        }
+
+        // Use Bounded Revised Simplex to find initial basic feasible point of original program
+        auto result_init = BoundedRevisedSimplex(Pre_DP_LPCA_problem);
+
+        // Check that Feasible Solution was found
+        if(result_init.iters>=Pre_DP_LPCA_problem.itlim){
+            err = -3;
+        }
+        for(int i=0;i<ControlSize;++i){
+            if(result_init.inB[i]> EffectorSize) // DP_LPCA_problem is origin problem, k=DP_LPCA_problem.n-1 = EffectorSize
+            {
+                // which mean inital basic index is out of the origin problem.
+                err = -2;
+                break;
+            }
+        }
+        if(result_init.errout){
+            err = -1;
+        }
+        // solve Pre_DP_LPCA_problem but proccess DP_LPCA_problem
+        float xout[DP_LPCA_problem.n];
+        for(int i=0;i<DP_LPCA_problem.n;++i){
+            xout[i]=0;
+        }
+        if(err!=0) // Construct an incorrect solution to accompany error flags
+        {
+            // use result_init data
+            // matlab: indv = inB1<=(k+1); xout(inB1(indv)) = y1(indv); % in matlab the index from 1 to k, but cpp is 0 to k-1
+            for(int i=0;i<ControlSize;++i){
+                if(result_init.inB[i] <= EffectorSize)
+                {
+                    xout[result_init.inB[i]]=result_init.y0[i];
+                }
+            }
+            // xout(~e1(1:k+1)) = -xout(~e1(1:k+1))+h(~e1(1:k+1));
+            for(int i=0;i<DP_LPCA_problem.n;++i){
+                if(!result_init.e[i]){
+                    xout[i] = -xout[i] + DP_LPCA_problem.h[i];
+                }
+            }
+        }
+        else //No Error continue to solve problem
+        {
+            // Solve using initial problem from above
+            // Construct solution to original LP problem from bounded simplex output
+            // Set non-basic variables to 0 or h based on result_init.e
+            // Set basic variables to result_init.y0 or h-result_init.y0.
+
+            // update DP_LPCA_problem.inB and DP_LPCA_problem.e by result_init.inB and result_init.e[0 to k=EffectorSize] that is e1(1:k+1) in matlab.  k+1 at all, so int (i=0;i<EffectorSize+1;++i) or (int i=0;i<DP_LPCA_problem.n;++i)
+            for(int i=0;i<ControlSize;++i){
+                DP_LPCA_problem.inB[i]=result_init.inB[i];
+            }
+            for(int i=0;i<DP_LPCA_problem.n;++i){
+                DP_LPCA_problem.e[i]=result_init.e[i];
+            }
+            auto result = BoundedRevisedSimplex(DP_LPCA_problem);
+
+            for(int i=0;i<ControlSize;++i){
+                xout[result.inB[i]]=result.y0[i];
+            }
+            for(int i=0;i<DP_LPCA_problem.n;++i){
+                if(!result.e[i]){
+                    xout[i]=-xout[i]+DP_LPCA_problem.h[i];
+                }
+            }
+
+            if(result.iters>=DP_LPCA_problem.itlim){
+                err = 3;
+            }
+            if(result.errout)
+            {
+                err = 1;
+            }
+        }
+        // Transform back to control variables
+        for(int i=0;i<EffectorSize;++i){
+            output[i]=xout[i]+this->aircraft.lowerLimits[i];
+        }
+        // Use upper_lam to prevent control surfaces from approaching position limits
+        rho = xout[EffectorSize];
+        if(rho>1){
+            for(int i=0;i<EffectorSize;++i){
+                output[i]/=rho;
+            }
+        }
+        return;
+    }
+    void DPscaled_LPCA(float input[ControlSize], float output[EffectorSize], int& err, float & rho){
+        // Direction Preserving Control Allocation Linear Program
+        //     Reduced formulation (Solution Scaled from Boundary)
+
+        // function [u,errout] = DPscaled_LPCA(yd,B,uMin,uMax,itlim);
+
+        // Solves the control allocation problem while preserving the
+        // objective direction for unattainable commands. The reduced
+        // dimension of the linear program passed to the Bounded Revised
+        // Simplex solver is formed by forcing the solution to be on the
+        // boundary of the AMS and eliminating the highest magnitude
+        // objective by solving the other constraints in terms of it.
+
+        // For yd outside the AMS, the solution returned is that the
+        // maximum in the direction of yd
+        // B*u= lamda*yd
+        // max lamda s.t. uMin <= u <= uMax
+
+        // Reducing the degrees of freedom elminates the problems of redundant
+        // solutions for attainable objectives. If the desired objective is on the
+        // interior of the AMS the solution is scaled from the solution on the
+        // boundary, yielding the same controls as the Direct Allocation solution.
+
+        // (In the text this solution is discussed in section A.5.3)
+
+        // (See Bodson, M., "Evaluation of Optimization Methods for
+        //         Control Allocation",  AIAA 2001-4223).
+
+        // Inputs:
+        //         yd [n]    = Desired objective
+        //         B [n,m]   = Control Effectiveness matrix
+        //         uMin[m,1] = Lower bound for controls
+        //         uMax[m,1] = Upper bound for controls
+        //         itlim     = Number of allowed iterations limit
+        //                         (Sum of iterations in both branches)
+
+        // Outputs:
+        //         u[m,1]     = Control Solution
+        //         errout     = Error Status code
+        //                         0 = found solution
+        //                         <0 = Error in finding initial basic feasible solution
+        //                         >0 = Error in finding final solution
+        //                         -1,1 = Solver error (unbounded solution)
+        //                         -2   = Initial feasible solution not found
+        //                         -3,3 = Iteration limit exceeded
+
+        // Calls:
+        //         simplxuprevsol = Bounded Revised Simplex solver (simplxuprevsol.m)
+
+        // Notes:
+        // If yd is close to zero, u = 0;
+
+        // Error code < 0 implies an error in the initialization and there is no guarantee on
+        // the quality of the output solution other than the control limits.
+        // Error code > 0 for errors in final solution.
+
+        // Modification History
+        // 2002      Roger Beck  Original ( DPcaLP2.m)
+        // 8/2014    Roger Beck  Update
+        // 4/2024       Implement in cpp
+
+        // DPscaled_LPCA函数利用飞行器数据，将分配问题描述为DP_LP问题并用BoundedRevisedSimplex求解
+        //=======================
+        // Figure out how big the problem is (use standard CA definitions for m & n)
+        // but in here we use [m,k] = size(B) instead of [n,m] = size(B) in matlab. just for adapt to BoundedRevisedSimplex
+        // we use [m,n] = size(A) in BoundedRevisedSimplex, that is, k + 1 = n.
+        // Check to see if yd == 0
+        // May want to adjust the tolerance to improve numerics of later steps
+        bool flag=false;
+        for(int i=0;i<ControlSize;++i){
+            if(fabs(input[i]) > DPscaled_LPCA_problem.tol)
+            {
+                flag = true; // Check this condition
+                break;
+            }
+        }
+        if(!flag){
+            for(int i=0;i<EffectorSize;++i){
+                output[i]=0;
+            }
+            err = -1;
+            return;
+        }
+        //=======================
+        // We inital this problem in constructor.
+        // Construct an LP using scaling parameter to enforce direction preserving
+        // To find Feasible solution construct problem with appended slack variables
+        // ref. is A.6.4 Initialization of the Simplex Algorithm of <Aircraft control allocation>
+
+        // now we update the problem by input data.
+        // update A b c but not h, h = uMax-uMin is assumpt always the same.
+        // float yd[3]={0.1,0.1,0.2}; // random value for inital.
+        //================================== DPscaled_LPCA_problem ================================
+        // update A b c h every time
+        float my=input[0]; // 存储最大的绝对值
+        int iy=0; // 存储最大绝对值的索引
+        for (int i = 0; i < ControlSize; ++i) {
+            float absValue = fabs(input[i]); // 计算 yd 中第 i 个元素的绝对值
+            if (absValue > my) { // 如果当前绝对值大于 my，则更新 my 和 iy
+                my = absValue;
+                iy = i;
+            }
+        }
+        // copy firstly !!!
+        float Bt[ControlSize][EffectorSize];
+        float ydt[ControlSize];
+
+        for(int i=0;i<ControlSize;++i){
+            for (int j = 0; j <EffectorSize; ++j) {
+                Bt[i][j] = this->aircraft.controlEffectMatrix[i][j];
+            }
+        }
+        for(int i=0;i<ControlSize;++i){
+            ydt[i]=input[i];
+            this->generalizedMoment[i] = input[i]; // just record.
+        }
+
+        // move
+        for(int j=0;j<EffectorSize;++j){
+            Bt[0][j] = this->aircraft.controlEffectMatrix[iy][j];
+            for (int i = iy; i >0; i--) {
+                Bt[i][j] = this->aircraft.controlEffectMatrix[i-1][j];
+            }
+        }
+        ydt[0] = input[iy];
+        for (int j = iy; j >0; j--) {
+            ydt[j] = input[j-1];
+        }
+        // swap 2 3 row of ydt
+        float ydt2=ydt[1];
+        ydt[1]=ydt[2];
+        ydt[2]=ydt2;
+        // swap 2 3 col of Bt
+        for(int i=0;i<EffectorSize;++i){
+            float Bt2=Bt[1][i];
+            Bt[1][i]=Bt[2][i];
+            Bt[2][i]=Bt2;
+        }
+        // M = [ydt(2:ControlSize) -ydt(1)*eye(ControlSize-1)];
+        float M[ControlSize-1][ControlSize];
+        // M[0][0]=ydt[1];
+        // M[1][0]=ydt[2];
+        // M[0][1]=-ydt[0];
+        // M[1][1]=0;
+        // M[0][2]=0;
+        // M[1][2]=-ydt[0];
+        // or
+        // 将 M 的所有元素初始化为0，并同时填充 M 的第一列和对角线元素
+        for (int i = 0; i < ControlSize - 1; ++i) {
+            for (int j = 0; j < ControlSize; ++j) {
+                if (j == 0) {
+                    // 填充 M 的第一列
+                    M[i][0] = ydt[i + 1];
+                } else if (j == i + 1) {
+                    // 填充对角线元素
+                    M[i][j] = -ydt[0];
+                } else {
+                    // 初始化其他元素为0
+                    M[i][j] = 0.0f;
+                }
+            }
+        }
+        for (int i = 0; i < ControlSize-1; ++i) {
+            for (int j = 0; j < EffectorSize; ++j) {
+                DPscaled_LPCA_problem.A[i][j] = 0;
+                for (int k = 0; k < ControlSize; ++k) {
+                    DPscaled_LPCA_problem.A[i][j] += M[i][k] * Bt[k][j];
+                }
+            }
+        }
+        for(int i=0; i<ControlSize-1; ++i)
+        {
+            float temp=0;
+            for(int j=0; j<EffectorSize; ++j)
+            {
+                temp += -DPscaled_LPCA_problem.A[i][j]*this->aircraft.lowerLimits[j];
+            }
+            DPscaled_LPCA_problem.b[i] = temp;
+        }
+        for (int i = 0; i < EffectorSize; ++i) {
+            DPscaled_LPCA_problem.c[i] = 0;
+            for (int j = 0; j < ControlSize; ++j) {
+                DPscaled_LPCA_problem.c[i] += -Bt[j][i] * ydt[j];
+            }
+        }
+        for (int i = 0; i < EffectorSize; ++i) {
+            DPscaled_LPCA_problem.h[i] = this->aircraft.upperLimits[i]-this->aircraft.lowerLimits[i];
+        }
+        //==================================Pre_DPscaled_LPCA_problem================================
+        // update Ai bi hi every time
+        for(int i=0; i<DPscaled_LPCA_problem.m; ++i)
+        {
+            for(int j=0; j<DPscaled_LPCA_problem.n; ++j)
+            {
+                Pre_DPscaled_LPCA_problem.A[i][j] = DPscaled_LPCA_problem.A[i][j];
+            }
+            Pre_DPscaled_LPCA_problem.b[i] = DPscaled_LPCA_problem.b[i]; // the same as DPscaled_LPCA_problem
+
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.m; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.A[i][i + DPscaled_LPCA_problem.n] = (DPscaled_LPCA_problem.b[i] > 0) ? 1 : -1; // sb = 2*(b > 0)-1; Ai = [A diag(sb)];
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.n; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.h[i] = DPscaled_LPCA_problem.h[i];
+        }
+        for(int i=0; i<DPscaled_LPCA_problem.m; ++i)
+        {
+            Pre_DPscaled_LPCA_problem.h[i+DPscaled_LPCA_problem.n] = 2*fabs(DPscaled_LPCA_problem.b[i]);
+        }
+
+        // Use Bounded Revised Simplex to find initial basic feasible point of original program
+        auto result_init = BoundedRevisedSimplex(Pre_DPscaled_LPCA_problem);
+
+        // Check that Feasible Solution was found
+        if(result_init.iters>=Pre_DPscaled_LPCA_problem.itlim){
+            err = -3;
+            // std::cout << "Pre Too Many Iterations Finding Final Solution"<< std::endl;
+            // for (int i = 0; i < ControlSize; ++i) {
+            //     std::cout << this->generalizedMoment[i] << std::endl;
+            // }
+        }
+        for(int i=0;i<ControlSize-1;++i){
+            if(result_init.inB[i]> EffectorSize-1) // DPscaled_LPCA_problem is origin problem, k=DPscaled_LPCA_problem.n-1 = EffectorSize
+            {
+                // which mean inital basic index is out of the origin problem.
+                err = -2;
+                break;
+            }
+        }
+        if(result_init.errout){
+            err = -1;
+        }
+        // solve Pre_DPscaled_LPCA_problem but proccess DPscaled_LPCA_problem
+        float xout[EffectorSize];
+        for(int i=0;i<DPscaled_LPCA_problem.n;++i){
+            xout[i]=0;
+        }
+        if(err!=0) // Construct an incorrect solution to accompany error flags
+        {
+            // use result_init data
+            // matlab: indv = inB1<=(k+1); xout(inB1(indv)) = y1(indv); % in matlab the index from 1 to k, but cpp is 0 to k-1
+            for(int i=0;i<ControlSize-1;++i){
+                xout[result_init.inB[i]]=result_init.y0[i];
+
+            }
+            // xout(~e1(1:k+1)) = -xout(~e1(1:k+1))+h(~e1(1:k+1));
+            for(int i=0;i<EffectorSize;++i){
+                if(!result_init.e[i]){
+                    xout[i] = -xout[i] + DPscaled_LPCA_problem.h[i];
+                }
+            }
+        }
+        else //No Error continue to solve problem
+        {
+            // Solve using initial problem from above
+            // Construct solution to original LP problem from bounded simplex output
+            // Set non-basic variables to 0 or h based on result_init.e
+            // Set basic variables to result_init.y0 or h-result_init.y0.
+
+            // update DPscaled_LPCA_problem.inB and DPscaled_LPCA_problem.e by result_init.inB and result_init.e[0 to k=EffectorSize] that is e1(1:k+1) in matlab.  k+1 at all, so int (i=0;i<EffectorSize+1;++i) or (int i=0;i<DPscaled_LPCA_problem.n;++i)
+            for(int i=0;i<DPscaled_LPCA_problem.m;++i){
+                DPscaled_LPCA_problem.inB[i]=result_init.inB[i];
+            }
+            for(int i=0;i<DPscaled_LPCA_problem.n;++i){
+                DPscaled_LPCA_problem.e[i]=result_init.e[i];
+            }
+
+            auto result = BoundedRevisedSimplex(DPscaled_LPCA_problem);
+
+            for(int i=0;i<ControlSize-1;++i){
+                xout[result.inB[i]]=result.y0[i];
+            }
+            for(int i=0;i<EffectorSize;++i){
+                if(!result.e[i]){
+                    xout[i]=-xout[i]+DPscaled_LPCA_problem.h[i];
+                }
+            }
+
+            if(result.iters>=DPscaled_LPCA_problem.itlim){
+                err = 3;
+            }
+            if(result.errout)
+            {
+                err = 1;
+            }
+        }
+        // Transform back to control variables
+        for(int i=0;i<EffectorSize;++i){
+            output[i]=xout[i]+this->aircraft.lowerLimits[i];
+        }
+        rho = calculateRho(ydt, output, Bt, DPscaled_LPCA_problem.tol);
+        if(rho>1){
+            for(int i=0;i<EffectorSize;++i){
+                output[i]/=rho;
+            }
+        }
+        return;
+    }
+    void DP_LPCA_copy(float input_higher[ControlSize],float input_lower[ControlSize], float output[EffectorSize], int& err, float & rho){
+        // yd=input_lower
+        // % Prioritizing Commands by DP_LPCA
+        // % Direction Preserving Control Allocation Linear Program
+        // % For the DP_LPCA_prio:
+        // % function [u, errout,lambda] = DP_LPCA_prio(m_higher,m_lower,B,uMin,uMax,itlim)
+        // % A.5 Building a Control Allocator for Feasible and Infeasible Solutions
+        // %
+        // % This DP_LPCA_copy:
+        // %  Inputs:
+        // %          input_higher [n]    = higher objective
+        // %          input_lower [n]    = lower objective
+        // %          B [n,m]   = Control Effectiveness matrix
+        // %          uMin[m,1] = Lower bound for controls
+        // %          uMax[m,1] = Upper bound for controls
+        // %          itlim     = Number of allowed iterations limit
+        // %                         (Sum of iterations in both branches)
+        // %
+        // % Outputs:
+        // %         u[m,1]     = Control Solution
+        // %         errout     = Error Status code
+        // %                         0 = found solution
+        // %                         <0 = Error in finding initial basic feasible solution
+        // %                         >0 = Error in finding final solution
+        // %                         -1,1 = Solver error (unbounded solution)
+        // %                         -2   = Initial feasible solution not found
+        // %                         -3,3 = Iteration limit exceeded
+        // %         itlim      = Number of iterations remaining after solution found
+        // %
+        // % Calls:
+        // %         simplxuprevsol = Bounded Revised Simplex solver (simplxuprevsol.m)
+        // %
+        // 4/2024       Implement in cpp
+
+        // DP_LPCA函数利用飞行器数据，将分配问题描述为DP_LP问题并用BoundedRevisedSimplex求解
+        //=======================
+        // Figure out how big the problem is (use standard CA definitions for m & n)
+        // but in here we use [m,k] = size(B) instead of [n,m] = size(B) in matlab. just for adapt to BoundedRevisedSimplex
+        // we use [m,n] = size(A) in BoundedRevisedSimplex, that is, k + 1 = n.
+        // Check to see if yd == 0
+        // May want to adjust the tolerance to improve numerics of later steps
+        bool flag=false;
+        for(int i=0;i<ControlSize;++i){
+            if(fabs(input_lower[i]) > DP_LPCA_problem.tol)
+            {
+                flag = true; // Check this condition
+                break;
+            }
+        }
+        if(!flag){
+            for(int i=0;i<EffectorSize;++i){
+                output[i]=0;
+            }
+            err=-1;
+            return;
+        }
+        //=======================
+        // We inital this problem in constructor.
+        // Construct an LP using scaling parameter to enforce direction preserving
+        // To find Feasible solution construct problem with appended slack variables
+        // ref. is A.6.4 Initialization of the Simplex Algorithm of <Aircraft control allocation>
+
+        // now we update the problem by aircraft.
+        if(isupdate){
+            Update();
+            isupdate = false; // only update once.
+        }
+        // update A b h by input data.
+        // update sb(since b is update) Ai bi hi every time
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            DP_LPCA_problem.A[i][DP_LPCA_problem.n-1] = -input_lower[i];
+            DP_LPCA_problem.b[i] = input_higher[i]-this->aircraft.BuMin[i]; //
+
+            Pre_DP_LPCA_problem.A[i][DP_LPCA_problem.n-1] = -input_lower[i]; // the same as DP_LPCA_problem.A[i][DP_LPCA_problem.n-1]
+            Pre_DP_LPCA_problem.b[i] = input_higher[i]-this->aircraft.BuMin[i]; // the same as DP_LPCA_problem
+
+            Pre_DP_LPCA_problem.A[i][i + DP_LPCA_problem.n] = (DP_LPCA_problem.b[i] > 0) ? 1 : -1; // sb = 2*(b > 0)-1; Ai = [A diag(sb)];
+            Pre_DP_LPCA_problem.h[i+DP_LPCA_problem.n] = 2*fabs(DP_LPCA_problem.b[i]);
+        }
+
+        // Use Bounded Revised Simplex to find initial basic feasible point of original program
+        auto result_init = BoundedRevisedSimplex(Pre_DP_LPCA_problem);
+
+        // Check that Feasible Solution was found
+        if(result_init.iters>=Pre_DP_LPCA_problem.itlim){
+            err = -3;
+        }
+        for(int i=0;i<ControlSize;++i){
+            if(result_init.inB[i]> EffectorSize) // DP_LPCA_problem is origin problem, k=DP_LPCA_problem.n-1 = EffectorSize
+            {
+                // which mean inital basic index is out of the origin problem.
+                err = -2;
+                break;
+            }
+        }
+        if(result_init.errout){
+            err = -1;
+        }
+        // solve Pre_DP_LPCA_problem but proccess DP_LPCA_problem
+        float xout[DP_LPCA_problem.n];
+        for(int i=0;i<DP_LPCA_problem.n;++i){
+            xout[i]=0;
+        }
+        if(err!=0) // Construct an incorrect solution to accompany error flags
+        {
+            // use result_init data
+            // matlab: indv = inB1<=(k+1); xout(inB1(indv)) = y1(indv); % in matlab the index from 1 to k, but cpp is 0 to k-1
+            for(int i=0;i<ControlSize;++i){
+                if(result_init.inB[i] <= EffectorSize)
+                {
+                    xout[result_init.inB[i]]=result_init.y0[i];
+                }
+            }
+            // xout(~e1(1:k+1)) = -xout(~e1(1:k+1))+h(~e1(1:k+1));
+            for(int i=0;i<DP_LPCA_problem.n;++i){
+                if(!result_init.e[i]){
+                    xout[i] = -xout[i] + DP_LPCA_problem.h[i];
+                }
+            }
+        }
+        else //No Error continue to solve problem
+        {
+            // Solve using initial problem from above
+            // Construct solution to original LP problem from bounded simplex output
+            // Set non-basic variables to 0 or h based on result_init.e
+            // Set basic variables to result_init.y0 or h-result_init.y0.
+
+            // update DP_LPCA_problem.inB and DP_LPCA_problem.e by result_init.inB and result_init.e[0 to k=EffectorSize] that is e1(1:k+1) in matlab.  k+1 at all, so int (i=0;i<EffectorSize+1;++i) or (int i=0;i<DP_LPCA_problem.n;++i)
+            for(int i=0;i<ControlSize;++i){
+                DP_LPCA_problem.inB[i]=result_init.inB[i];
+            }
+            for(int i=0;i<DP_LPCA_problem.n;++i){
+                DP_LPCA_problem.e[i]=result_init.e[i];
+            }
+            auto result = BoundedRevisedSimplex(DP_LPCA_problem);
+
+            for(int i=0;i<ControlSize;++i){
+                xout[result.inB[i]]=result.y0[i];
+            }
+            for(int i=0;i<DP_LPCA_problem.n;++i){
+                if(!result.e[i]){
+                    xout[i]=-xout[i]+DP_LPCA_problem.h[i];
+                }
+            }
+
+            if(result.iters>=DP_LPCA_problem.itlim){
+                err = 3;
+            }
+            if(result.errout)
+            {
+                err = 1;
+            }
+        }
+        // Transform back to control variables
+        for(int i=0;i<EffectorSize;++i){
+            output[i]=xout[i]+this->aircraft.lowerLimits[i];
+        }
+        rho = xout[EffectorSize];
+        if(rho>1){
+            for(int i=0;i<EffectorSize;++i){
+                output[i]/=rho;
+            }
+        }
+        return;
+    }
+    void restoring(float u[EffectorSize], float u_rest[EffectorSize]){
+        Vector<float, EffectorSize> u_current(u);
+        if(u_current.norm()<FLT_EPSILON){
+            for(int i=0;i<EffectorSize;++i){
+                u_rest[i]=u[i];
+            }
+            return;
+        }
+        // update B_aug
+        B_aug.setRow(ControlSize, u_current);
+        //u_null=pinv(B_aug)*v_aug;
+        matrix::LeastSquaresSolver<float, ControlSize+1,EffectorSize> LSsolver(B_aug);
+        u_null = LSsolver.solve(v_aug);
+        // % R=rank(B_aug) = k
+        // % by all(abs(null(B)'*u)) < eps or norm(null(B)'*u)<100*eps or rank([B_aug v_aug]) ~= rank(B_aug)
+        // % for cpp is difficult to calc null(B) but we can calc
+        // % norm(B*u_null)>0.00001
+        matrix::Vector<float, ControlSize> tmp= B*u_null;
+        if(tmp.norm()> 0.001f){ // a=0
+            for(int i=0;i<EffectorSize;++i){
+                u_rest[i]=u[i];
+            }
+            return;
+        }
+        float K_opt=-a_constant/u_null.norm_squared();
+        //% update limits
+        float uMax_new[EffectorSize]; // 操纵向量上限变量
+        float uMin_new[EffectorSize]; // 操纵向量下限变量
+        for(int i=0;i<EffectorSize;++i){
+            uMax_new[i]=this->aircraft.upperLimits[i]-u[i];
+            uMin_new[i]=this->aircraft.lowerLimits[i]-u[i];
+        }
+        float K_max=FLT_MAX; // 1.0/FLT_EPSILON; or FLT_MAX
+        for(int i=0;i<EffectorSize;++i){
+            if(fabs(u_null(i))<FLT_EPSILON){
+                continue; // if u_null(i) is zero, then skip;
+            }
+            float tmpu=0.0f;
+            if(u_null(i)>0){
+                tmpu=uMax_new[i]/u_null(i);
+            }else{
+                tmpu=uMin_new[i]/u_null(i);
+            }
+            if(tmpu<K_max){ // find smaller
+                K_max=tmpu;
+            }
+        }
+        for(int i=0;i<EffectorSize;++i){
+            u_rest[i]=u[i] + matrix::typeFunction::min(K_max,K_opt) *u_null(i);
+        }
+    }
+    void Update(){
+        //for DP_LPCA and DP_LPCA_copy.   A b h
+
+        // B*uMin of aircraft， b
+        for (int i = 0; i < ControlSize; ++i) {
+            float temp = 0.0f;
+            for (int j = 0; j < EffectorSize; ++j) {
+                temp +=  this->aircraft.controlEffectMatrix[i][j]*this->aircraft.lowerLimits[j];
+            }
+            this->aircraft.BuMin[i] = temp; // 计算BuMin
+            DP_LPCA_problem.b[i]=-temp; //暂时。还需要重新计算
+
+        }
+
+        // A  h  (c is fixed)
+        for(int i=0; i<DP_LPCA_problem.m; ++i)
+        {
+            for(int j=0; j<DP_LPCA_problem.n-1; ++j)
+            {
+                DP_LPCA_problem.A[i][j] = this->aircraft.controlEffectMatrix[i][j]; // [n-1] will update every time
+
+                Pre_DP_LPCA_problem.A[i][j] = this->aircraft.controlEffectMatrix[i][j]; // the same as DP_LPCA_problem.A[i][j]
+            }
+            Pre_DP_LPCA_problem.b[i] = DP_LPCA_problem.b[i];
+
+            Pre_DP_LPCA_problem.A[i][i + DP_LPCA_problem.n] = (DP_LPCA_problem.b[i] > 0) ? 1 : -1; // sb = 2*(b > 0)-1; Ai = [A diag(sb)];
+            Pre_DP_LPCA_problem.h[i+DP_LPCA_problem.n] = 2*fabs(DP_LPCA_problem.b[i]);
+        }
+        for(int i=0; i<DP_LPCA_problem.n-1; ++i)
+        {
+            DP_LPCA_problem.h[i] = this->aircraft.upperLimits[i]-this->aircraft.lowerLimits[i];  //[n] is fixed 1
+            Pre_DP_LPCA_problem.h[i] = DP_LPCA_problem.h[i];
+        }
+        // for DPscaled_LPCA is update every time
+        //   for restoring
+        B_aug.setZero();
+        B.setZero();
+        for (int i = 0; i < ControlSize; ++i) {
+            for (int j = 0; j < EffectorSize; ++j) {
+                B_aug(i,j) = this->aircraft.controlEffectMatrix[i][j];
+                B(i,j) = this->aircraft.controlEffectMatrix[i][j];
+            }
+        }
+        v_aug.setZero();
+        v_aug(ControlSize)=a_constant;
+
+        // std::cout << "is updated" << std::endl;
+        isupdate = false;
+    }
+    // 其他成员函数和成员变量定义
+    float generalizedMoment[ControlSize]; // 构造函数设置
+    // 线性规划相关
+    LinearProgrammingProblem<ControlSize, EffectorSize+1> DP_LPCA_problem;// 提前设置 inital by  aircraft data
+    LinearProgrammingProblem<ControlSize, (EffectorSize+1) + ControlSize> Pre_DP_LPCA_problem;// 提前设置 inital by aircraft data
+    LinearProgrammingProblem<ControlSize-1, EffectorSize> DPscaled_LPCA_problem;// 提前设置 inital by  aircraft data
+    LinearProgrammingProblem<ControlSize-1, EffectorSize + (ControlSize-1)> Pre_DPscaled_LPCA_problem;// 提前设置 inital by aircraft data
+    float upper_lam=1; // 2024-10-18 upper_lam=1
+    // for restoring
+    matrix::Matrix<float, ControlSize+1, EffectorSize> B_aug;
+    matrix::Vector<float, ControlSize+1> v_aug;
+    matrix::Vector<float, EffectorSize> u_null;
+    float a_constant=-2; //arbitrary a<0 (if null(B)'*u = 0, rank([B_aug v_aug]) ~= rank(B_aug), it have to be a=0)
+    matrix::Matrix<float, ControlSize, EffectorSize> B;
+    bool isupdate{false}; //if update aircraft data, then set isupdate = true.
+
+};
+// and user can define more...
+// template <int ControlSize, int EffectSize>
+// class XX_ControlAllocator : public ControlAllocatorBase<ControlSize, EffectSize> {}
diff --git a/src/lib/mixer_module/mixer_module.cpp b/src/lib/mixer_module/mixer_module.cpp
index e1eff51dc3..5e6c05b462 100644
--- a/src/lib/mixer_module/mixer_module.cpp
+++ b/src/lib/mixer_module/mixer_module.cpp
@@ -57,7 +57,11 @@ _scheduling_policy(scheduling_policy),
 _support_esc_calibration(support_esc_calibration),
 _max_num_outputs(max_num_outputs < MAX_ACTUATORS ? max_num_outputs : MAX_ACTUATORS),
 _interface(interface),
-_control_latency_perf(perf_alloc(PC_ELAPSED, "control latency"))
+_control_latency_perf(perf_alloc(PC_ELAPSED, "control latency")),
+df_4(_B, lower, upper),
+Allocator_INDI(df_4),
+df_4_PID(_B_PID, lower_PID, upper_PID),
+Allocator_PID(df_4_PID)
 {
 	output_limit_init(&_output_limit);
 	_output_limit.ramp_up = ramp_up;
@@ -77,6 +81,74 @@ _control_latency_perf(perf_alloc(PC_ELAPSED, "control latency"))
 	uORB::Publication<test_motor_s> test_motor_pub{ORB_ID(test_motor)};
 	test_motor_pub.publish(test);
 	_motor_test.test_motor_sub.subscribe();
+
+	// filter init
+	// last_delta_cmd_rad
+	for (size_t i = 0; i < 4; ++i) {
+		_lp_filter_actuator[i].set_cutoff_frequency(_sample_freq, _param_cs_cutoff.get());
+		_lp_filter_actuator[i].reset(0);
+	}
+	Allocator_INDI.aircraft.controlEffectMatrix[0][0]= -_L_1*_k/_I_x;
+	Allocator_INDI.aircraft.controlEffectMatrix[0][2]= _L_1*_k/_I_x;
+	Allocator_INDI.aircraft.controlEffectMatrix[1][1]= -_L_1*_k/_I_y;
+	Allocator_INDI.aircraft.controlEffectMatrix[1][3]= _L_1*_k/_I_y;
+	Allocator_INDI.aircraft.controlEffectMatrix[2][0]= _L_2*_k/_I_z;
+	Allocator_INDI.aircraft.controlEffectMatrix[2][1]= _L_2*_k/_I_z;
+	Allocator_INDI.aircraft.controlEffectMatrix[2][2]= _L_2*_k/_I_z;
+	Allocator_INDI.aircraft.controlEffectMatrix[2][3]= _L_2*_k/_I_z;
+	Allocator_INDI.isupdate = true;
+
+	_B[0][0]= -_L_1*_k/_I_x;
+	_B[0][2]= _L_1*_k/_I_x;
+	_B[1][1]= -_L_1*_k/_I_y;
+	_B[1][3]= _L_1*_k/_I_y;
+	_B[2][0]= _L_2*_k/_I_z;
+	_B[2][1]= _L_2*_k/_I_z;
+	_B[2][2]= _L_2*_k/_I_z;
+	_B[2][3]= _L_2*_k/_I_z;
+
+	for (int i = 0; i < 3; i++)
+	{
+		for(int j=0;j<4;j++)
+		{
+			_B_array[i+3*j] = _B[i][j];
+			_B_PID_array[i+3*j] = _B_PID[i][j];
+		}
+	}
+	// B^{\dagger}=P^{\dagger} K^{-1}=[-0.5000   -0.0000    0.2500;0   -0.5000    0.2500;0.5000   -0.0000    0.2500;0    0.5000    0.2500]*diag([ I_x/(k*l1)  I_y/(k*l1)  I_z/(k*l2)  ])
+	B_inv.setZero();
+	B_inv(0, 0)=-0.5f* _I_x/(_k*_L_1);
+	B_inv(0, 2)=0.25f* _I_z/(_k*_L_2);
+
+	B_inv(1, 1)=-0.5f* _I_y/(_k*_L_1);
+	B_inv(1, 2)=0.25f* _I_z/(_k*_L_2);
+
+	B_inv(2, 0)=0.5f* _I_x/(_k*_L_1);
+	B_inv(2, 2)=0.25f* _I_z/(_k*_L_2);
+
+	B_inv(3, 1)=0.5f* _I_y/(_k*_L_1);
+	B_inv(3, 2)=0.25f* _I_z/(_k*_L_2);
+
+	B_inv_PID.setZero(); // k=1, I_x=1, I_y=1, I_z=1
+	B_inv_PID(0, 0)=-1.0f;
+	B_inv_PID(0, 2)=1.0f;
+
+	B_inv_PID(1, 1)=-1.0f;
+	B_inv_PID(1, 2)=1.0f;
+
+	B_inv_PID(2, 0)=1.0f;
+	B_inv_PID(2, 2)=1.0f;
+
+	B_inv_PID(3, 1)=1.0f;
+	B_inv_PID(3, 2)=1.0f;
+
+	for (size_t i = 0; i < 4; i++)
+	{
+		_uMin[i] = lower;
+		_uMax[i] = upper;
+		_uMin_PID[i] = lower_PID;
+		_uMax_PID[i] = upper_PID;
+	}
 }

 MixingOutput::~MixingOutput()
@@ -85,13 +157,24 @@ MixingOutput::~MixingOutput()
 	delete _mixers;
 	px4_sem_destroy(&_lock);
 }
-
 void MixingOutput::printStatus() const
 {
 	perf_print_counter(_control_latency_perf);
-	PX4_INFO("Switched to rate_ctrl work queue: %i", (int)_wq_switched);
 	PX4_INFO("Mixer loaded: %s", _mixers ? "yes" : "no");
+	PX4_INFO("Switched to rate_ctrl work queue: %i", (int)_wq_switched);
 	PX4_INFO("Driver instance: %i", _driver_instance);
+	PX4_INFO("_mixing_output.setMaxTopicUpdateRate(update_interval_in_us) in pwmout, that is:");
+	PX4_INFO("_max_topic_update_interval_us of mixing: %i", _max_topic_update_interval_us);// 发布pwm周期，和pwm_out参数有关。
+
+	PX4_INFO("_sample_freq of mixing: %f", (double) _sample_freq);//控制器控制频率，
+	PX4_INFO("allocation running time: %" PRIu64 "us \n", _allocation_runing_time_us);
+
+	PX4_INFO("allocator test running time: %" PRIu64 "us \n", _allocation_test_runing_time_us1);
+	PX4_INFO("DP_LPCA test running time: %" PRIu64 "us \n", _allocation_test_runing_time_us2);
+	PX4_INFO("DPscaled_LPCA test running time: %" PRIu64 "us \n", _allocation_test_runing_time_us3);
+	PX4_INFO("DP_LPCA_prio test running time: %" PRIu64 "us \n", _allocation_test_runing_time_us4);
+	PX4_INFO("WLS test running time: %" PRIu64 "us \n", _allocation_test_runing_time_us5);
+	PX4_INFO("INV test running time: %" PRIu64 "us \n", _allocation_test_runing_time_us6);

 	PX4_INFO("Channel Configuration:");

@@ -102,9 +185,109 @@ void MixingOutput::printStatus() const
 	}
 }

+void MixingOutput::CheckAndUpdateFilters()
+{
+	// update software low pass filters
+
+	// last_delta_cmd_rad
+	for (size_t i = 0; i < 4; ++i) {
+		if ( _sample_rate_changed || (fabsf(_lp_filter_actuator[i].get_cutoff_freq() - _param_cs_cutoff.get()) > 0.1f)) {
+			_lp_filter_actuator[i].set_cutoff_frequency(_sample_freq, _param_cs_cutoff.get());
+			_lp_filter_actuator[i].reset(_delta_prev[i]);
+		}
+	}
+	_sample_rate_changed = false;
+}
+
 void MixingOutput::updateParams()
 {
-	ModuleParams::updateParams();
+	ModuleParams::updateParams(); // only run when parameters are updated
+
+	CheckAndUpdateFilters();
+	_use_alloc = _param_use_alloc.get();
+	_alloc_method = _param_alloc_method.get();
+	_use_ac_test = _param_ac_test.get();
+	bool tmp=  _param_use_dist.get();
+	if(_use_dist!=tmp)
+	{
+		_use_dist = tmp;
+		if(_use_dist)
+		{
+			for (size_t i = 0; i < 4; i++)
+			{
+				_uMin[i] = lower+_dist_mag;
+				_uMax[i] = upper-_dist_mag;
+			}
+			for (int i = 0; i < 4; ++i) {
+				Allocator_INDI.aircraft.upperLimits[i] = _uMax[i];
+				Allocator_INDI.aircraft.lowerLimits[i] = _uMin[i];
+				Allocator_INDI.isupdate = true;
+			}
+			// PX4_INFO("using dist");
+		}
+		else
+		{
+			for (size_t i = 0; i < 4; i++)
+			{
+				_uMin[i] = lower;
+				_uMax[i] = upper;
+			}
+			for (int i = 0; i < 4; ++i) {
+				Allocator_INDI.aircraft.upperLimits[i] = _uMax[i];
+				Allocator_INDI.aircraft.lowerLimits[i] = _uMin[i];
+				Allocator_INDI.isupdate = true;
+			}
+		}
+
+	}
+	_dist_mag = _param_dist_mag.get();
+	_time_const=math::constrain(_param_time_const.get(), 1.0f/_sample_freq, 0.2f);// dt < _time_const  < epsilon^*=0.2 here.  dt小于执行器时间常数这是对本程序中模拟执行器行为的要求，见matlab。保守起见取下限1.0f/_sample_freq
+	//uopdate Allocator_INDI _B  B_inv
+	float tmp_k=_param_k.get();
+	if(fabsf(tmp_k - _k) > FLT_EPSILON){
+		// PX4_INFO("update model");
+		_k = tmp_k;
+		Allocator_INDI.aircraft.controlEffectMatrix[0][0]= -_L_1*_k/_I_x;
+		Allocator_INDI.aircraft.controlEffectMatrix[0][2]= _L_1*_k/_I_x;
+		Allocator_INDI.aircraft.controlEffectMatrix[1][1]= -_L_1*_k/_I_y;
+		Allocator_INDI.aircraft.controlEffectMatrix[1][3]= _L_1*_k/_I_y;
+		Allocator_INDI.aircraft.controlEffectMatrix[2][0]= _L_2*_k/_I_z;
+		Allocator_INDI.aircraft.controlEffectMatrix[2][1]= _L_2*_k/_I_z;
+		Allocator_INDI.aircraft.controlEffectMatrix[2][2]= _L_2*_k/_I_z;
+		Allocator_INDI.aircraft.controlEffectMatrix[2][3]= _L_2*_k/_I_z;
+		Allocator_INDI.isupdate = true; // set to true, so that the next time we call Allocator_INDI.Update(), it will update the B matrix and B_inv matrix.
+
+		_B[0][0]= -_L_1*_k/_I_x;
+		_B[0][2]= _L_1*_k/_I_x;
+		_B[1][1]= -_L_1*_k/_I_y;
+		_B[1][3]= _L_1*_k/_I_y;
+		_B[2][0]= _L_2*_k/_I_z;
+		_B[2][1]= _L_2*_k/_I_z;
+		_B[2][2]= _L_2*_k/_I_z;
+		_B[2][3]= _L_2*_k/_I_z;
+
+		for (int i = 0; i < 3; i++)
+		{
+			for(int j=0;j<4;j++)
+			{
+				_B_array[i+3*j] = _B[i][j];
+			}
+		}
+
+		B_inv(0, 0)=-0.5f* _I_x/(_k*_L_1);
+		B_inv(0, 2)=0.25f* _I_z/(_k*_L_2);
+
+		B_inv(1, 1)=-0.5f* _I_y/(_k*_L_1);
+		B_inv(1, 2)=0.25f* _I_z/(_k*_L_2);
+
+		B_inv(2, 0)=0.5f* _I_x/(_k*_L_1);
+		B_inv(2, 2)=0.25f* _I_z/(_k*_L_2);
+
+		B_inv(3, 1)=0.5f* _I_y/(_k*_L_1);
+		B_inv(3, 2)=0.25f* _I_z/(_k*_L_2);
+	}
+
+

 	// update mixer if we have one
 	if (_mixers) {
@@ -197,7 +380,7 @@ bool MixingOutput::updateSubscriptions(bool allow_wq_switch, bool limit_callback

 void MixingOutput::setMaxTopicUpdateRate(unsigned max_topic_update_interval_us)
 {
-	_max_topic_update_interval_us = max_topic_update_interval_us;
+	_max_topic_update_interval_us = max_topic_update_interval_us; //have been constrain from  0.5 - 100 ms (10 - 2000Hz) in PWMOut.cpp but not in PWMSim.cpp

 	for (unsigned i = 0; i < actuator_controls_s::NUM_ACTUATOR_CONTROL_GROUPS; i++) {
 		if (_groups_subscribed & (1 << i)) {
@@ -210,6 +393,7 @@ void MixingOutput::setAllMinValues(uint16_t value)
 {
 	for (unsigned i = 0; i < MAX_ACTUATORS; i++) {
 		_min_value[i] = value;
+		// PX4_INFO("value %d", value);
 	}
 }

@@ -258,6 +442,15 @@ void MixingOutput::updateOutputSlewrateSimplemixer()
 	const hrt_abstime now = hrt_absolute_time();
 	const float dt = math::constrain((now - _time_last_dt_update_simple_mixer) / 1e6f, 0.0001f, 0.02f);
 	_time_last_dt_update_simple_mixer = now;
+	float tmp=1.0f / dt; // (Hz)
+
+	if((fabsf(tmp - _sample_freq) / _sample_freq) > 0.01f){
+		// PX4_INFO("tmp: %f \n", (double)  tmp);
+		// PX4_INFO("_sample_freq: %f \n", (double)  _sample_freq);
+		_sample_freq = tmp;
+		_sample_rate_changed = true;
+		CheckAndUpdateFilters();
+	}

 	// set dt for slew rate limiter in SimpleMixer (is reset internally after usig it, so needs to be set on every update)
 	_mixers->set_dt_once(dt);
@@ -326,6 +519,26 @@ unsigned MixingOutput::motorTest()
 	return (_motor_test.in_test_mode || had_update) ? _max_num_outputs : 0;
 }

+// 一阶系统实时更新函数, Euler 前向差分（Forward Euler）,稳定性只在 dt/T < 1 时保持（否则不稳定）。离散化方法对比见matlab。
+float MixingOutput::first_order_update(float u_pre, float y_pre, float T, float dt)
+{
+    float y = y_pre + (dt / T) * (u_pre - y_pre);
+    return y;
+}
+
+float MixingOutput::first_order_update_zoh(float u_pre, float y_pre, float T, float dt)
+{
+    if (T < 1e-6f) {
+        // 若 T 很小，系统响应应为 y ≈ u
+        return u_pre;
+    }
+
+    float A = expf(-dt / T);           // 离散极点
+    float B = 1.0f - A;                // 输入系数
+
+    float y = A * y_pre + B * u_pre;   // ZOH差分更新
+    return y;
+}
 bool MixingOutput::update()
 {
 	if (!_mixers) {
@@ -373,7 +586,7 @@ bool MixingOutput::update()
 	updateOutputSlewrateSimplemixer(); // update dt for output slew rate in simple mixer

 	unsigned n_updates = 0;
-
+	//_controls is roll, pitch, yaw moment[-1, 1] and thrust[0, 1], which is output of rate_control
 	/* get controls for required topics */
 	for (unsigned i = 0; i < actuator_controls_s::NUM_ACTUATOR_CONTROL_GROUPS; i++) {
 		if (_groups_subscribed & (1 << i)) {
@@ -400,7 +613,346 @@ bool MixingOutput::update()
 	float outputs[MAX_ACTUATORS] {};
 	const unsigned mixed_num_outputs = _mixers->mix(outputs, _max_num_outputs);

-	/* the output limit call takes care of out of band errors, NaN and constrains */
+	// rc detection
+	// 上是-1
+	// channels[6]:  -1	0	1	= yaw step  // 7通道右上角
+	// 9-12通道在正面
+	// channels[8]:  -1	0       1	=servo disturb
+	// channels[9]:  -1	0       1	=
+	// channels[10]: -1	0       1	=
+	// channels[11]: -1	0       1	=pid or indi
+	if (_rc_channels_sub.update(&_rc_channels))
+	{
+		if (_rc_channels.channels[8] < 0.f)
+		{
+			_rc_dist_flag = false;
+			// PX4_INFO("no dist !");
+		}
+		else
+		{
+			_rc_dist_flag = true;
+			// PX4_INFO("dist !");
+		}
+	}
+	if(_pre_rc_dist_flag!=_rc_dist_flag)
+	{
+		_pre_rc_dist_flag = _rc_dist_flag;
+		if(_rc_dist_flag)
+		{
+			for (size_t i = 0; i < 4; i++)
+			{
+				_uMin[i] = lower+_dist_mag;
+				_uMax[i] = upper-_dist_mag;
+			}
+			for (int i = 0; i < 4; ++i) {
+				Allocator_INDI.aircraft.upperLimits[i] = _uMax[i];
+				Allocator_INDI.aircraft.lowerLimits[i] = _uMin[i];
+				Allocator_INDI.isupdate = true;
+			}
+			PX4_INFO("model update !");
+		}
+		else
+		{
+			for (size_t i = 0; i < 4; i++)
+			{
+				_uMin[i] = lower;
+				_uMax[i] = upper;
+			}
+			for (int i = 0; i < 4; ++i) {
+				Allocator_INDI.aircraft.upperLimits[i] = _uMax[i];
+				Allocator_INDI.aircraft.lowerLimits[i] = _uMin[i];
+				Allocator_INDI.isupdate = true;
+			}
+			PX4_INFO("model recover !");
+		}
+
+	}
+	// // "outputs" is the value alfter mix, range from [-1, 1]. _current_output_value is pwm value alfter output_limit_calc.
+	// // just using in ductedfan
+	// // PX4_INFO("dir_alloc_sim:\n");
+	hrt_abstime timestamp_ca_start=hrt_absolute_time();
+	hrt_abstime timestamp_ca_end=hrt_absolute_time();
+	allocation_value_s allocation_value{};
+
+	if(_use_ac_test==1){
+		// PX4_INFO("INDI test");
+		// =====================run test for allocation running time===========================================
+		float m_higher[3]={0.0,  0.0,  30.0f}; //
+		float m_lower[3]={20.0f,  10.0f,   0.0f};
+		float input[3]={m_lower[0]+m_higher[0],  m_lower[1]+m_higher[1],   m_lower[2]+m_higher[2]};
+		//==========================allocateControl===========================
+		float u1[4]; int err1=0;
+		timestamp_ca_start = hrt_absolute_time();
+		Allocator_INDI.allocateControl(input, u1, err1);
+		timestamp_ca_end = hrt_absolute_time();
+		_allocation_test_runing_time_us1=timestamp_ca_end - timestamp_ca_start;
+		// PX4_INFO("allocateControl: u1: %f, u2: %f, u3: %f, u4: %f. \n",(double) u1[0],(double) u1[1],(double) u1[2],(double) u1[3]);
+		// PX4_INFO("allocateControl time: %lld \n", (timestamp_ca_end - timestamp_ca_start) ); //nuttx
+		//========================DP_LPCA=============================
+		float u2[4];int err2=0;float rho2=0;float u2_tmp[4];
+		timestamp_ca_start = hrt_absolute_time();
+		Allocator_INDI.DP_LPCA(input, u2_tmp, err2, rho2);
+		Allocator_INDI.restoring(u2_tmp,u2);
+		timestamp_ca_end = hrt_absolute_time();
+		_allocation_test_runing_time_us2=timestamp_ca_end - timestamp_ca_start;
+		// PX4_INFO("DP_LPCA: u1: %f, u2: %f, u3: %f, u4: %f. \n",(double) u2[0],(double) u2[1],(double) u2[2],(double) u2[3]);
+		// PX4_INFO("DP_LPCA time: %lld \n", (timestamp_ca_end - timestamp_ca_start) ); //nuttx
+		//=========================DPscaled_LPCA============================INFO  [mixer_module] dir_alloc_sim time: 16
+		float u3[4];int err3=0;float rho3=0;float u3_tmp[4];
+		timestamp_ca_start = hrt_absolute_time();
+		Allocator_INDI.DPscaled_LPCA(input, u3_tmp, err3, rho3);
+		Allocator_INDI.restoring(u3_tmp,u3);
+		timestamp_ca_end = hrt_absolute_time();
+		_allocation_test_runing_time_us3=timestamp_ca_end - timestamp_ca_start;
+		// PX4_INFO("DPscaled_LPCA: u1: %f, u2: %f, u3: %f, u4: %f. \n",(double) u3[0],(double) u3[1],(double) u3[2],(double) u3[3]);
+		// PX4_INFO("DPscaled_LPCA time: %lld \n", (timestamp_ca_end - timestamp_ca_start) ); //nuttx
+		//========================DP_LPCA_prio=============================
+		float u4[4];int err4=0;float rho4=0;float u4_tmp[4];
+		// float m_lower[3]={30.0f,  0.0f,   -0.0f};
+		int err41=0;float rho41=0;float u4_tmp1[4]; float m_tmp[3]={0.0,  0.0,  0.0f};
+		timestamp_ca_start = hrt_absolute_time();
+		Allocator_INDI.DP_LPCA_copy(m_higher,m_lower, u4_tmp, err4, rho4);
+		if (err4<0){
+			Allocator_INDI.DP_LPCA_copy(m_tmp,m_higher, u4_tmp1, err41, rho41);// or (m_tmp,input, u4_tmp1, err41, rho41);
+			Allocator_INDI.restoring(u4_tmp1,u4);
+		}else{
+			Allocator_INDI.restoring(u4_tmp,u4);
+		}
+		timestamp_ca_end = hrt_absolute_time();
+		_allocation_test_runing_time_us4=timestamp_ca_end - timestamp_ca_start;
+		// PX4_INFO("DP_LPCA_prio: u1: %f, u2: %f, u3: %f, u4: %f. \n",(double) u4[0],(double) u4[1],(double) u4[2],(double) u4[3]);
+		// PX4_INFO("DP_LPCA_prio time: %lld \n", (timestamp_ca_end - timestamp_ca_start) ); //nuttx
+		// //========================allocator_dir_LPwrap_4 (generate by matlab) =============================
+		// float u5[4]={ 0.0,  0.0,   0.0,   0.0};
+		// float z_allocator_dir_LPwrap_4= 0.0;
+		// unsigned int iters_allocator_dir_LPwrap_4= 0;
+		// timestamp_ca_start = hrt_absolute_time();
+		// allocator_dir_LPwrap_4(_B_array, input, _uMin, _uMax, u5, &z_allocator_dir_LPwrap_4, &iters_allocator_dir_LPwrap_4); // allocator_dir_LPwrap_4 execution time: 7.08e-07s
+		// timestamp_ca_end = hrt_absolute_time();
+		// PX4_INFO("allocator_dir_LPwrap_4: u1: %f, u2: %f, u3: %f, u4: %f. \n",(double) u5[0],(double) u5[1],(double) u5[2],(double) u5[3]);
+		// PX4_INFO("allocator_dir_LPwrap_4 time: %lld \n", (timestamp_ca_end - timestamp_ca_start) ); //nuttx
+		//=========================WLS_alloc_gen (generate by matlab)===========================
+		float u6[4];float gam = 1e6f; float W0[4]={0.0f, 0.0f, 0.0f, 0.0f};  float u_d[4] = {0.0f, 0.0f, 0.0f, 0.0f};
+		timestamp_ca_start = hrt_absolute_time();
+		wls_alloc_gen(_B_array, input, _uMin, _uMax, _I3_array, _I4_array, u_d, gam, u6, W0, 100, 4);
+		timestamp_ca_end = hrt_absolute_time();
+		_allocation_test_runing_time_us5=timestamp_ca_end - timestamp_ca_start;
+		// PX4_INFO("wls_alloc_gen: u1: %f, u2: %f, u3: %f, u4: %f. \n",(double) u6[0],(double) u6[1],(double) u6[2],(double) u6[3]);
+		// PX4_INFO("wls_alloc_gen time: %lld \n", (timestamp_ca_end - timestamp_ca_start) ); //nuttx
+
+		//=========================inv ===========================
+		float u7[4];
+		timestamp_ca_start = hrt_absolute_time();
+		matrix::Matrix<float, 3, 1> desire (input);
+		matrix::Matrix<float, 4, 1> u_i = B_inv * desire;
+		for (size_t i = 0; i < 4; i++){
+			u7[i] =  math::constrain( u_i(i,0), _uMin[i], _uMax[i]);
+		}
+		timestamp_ca_end = hrt_absolute_time();
+		_allocation_test_runing_time_us6=timestamp_ca_end - timestamp_ca_start;
+		// PX4_INFO("wls_alloc_gen: u1: %f, u2: %f, u3: %f, u4: %f. \n",(double) u6[0],(double) u6[1],(double) u6[2],(double) u6[3]);
+		// PX4_INFO("wls_alloc_gen time: %lld \n", (timestamp_ca_end - timestamp_ca_start) ); //nuttx
+
+		_use_ac_test=0;
+	}
+
+	// indi have to use allocator, since it use the model for control value. all this CA and INDI just for ductedfan4 since we have to set B.
+	// dt < _time_const  < epsilon^*=0.2 here. 实际上也需要大于一定值，因为噪声，这里下界是0.01，这与噪声和滤波器都有关。按照实际情况，kst0.15秒转60度，时间常数取0.03.. for CA in first order update
+	timestamp_ca_start = hrt_absolute_time();
+	if(_controls[0].control_flag == 1){ //using INDI
+		_fb[0] = _controls[0].control[actuator_controls_s::INDEX_ROLL];
+		_fb[1] = _controls[0].control[actuator_controls_s::INDEX_PITCH];
+		_fb[2] = _controls[0].control[actuator_controls_s::INDEX_YAW];
+		if (_alloc_method==3){ // pca
+			// PX4_INFO("INDI pca");
+			_indi_fb[0] = _controls[0].indi_fb[actuator_controls_s::INDEX_ROLL];
+			_indi_fb[1] = _controls[0].indi_fb[actuator_controls_s::INDEX_PITCH];
+			_indi_fb[2] = _controls[0].indi_fb[actuator_controls_s::INDEX_YAW];
+			_error_fb[0] = _controls[0].error_fb[actuator_controls_s::INDEX_ROLL];
+			_error_fb[1] = _controls[0].error_fb[actuator_controls_s::INDEX_PITCH];
+			_error_fb[2] = _controls[0].error_fb[actuator_controls_s::INDEX_YAW];
+			float u_pca[4];int err_flag_1=0;float rho_1=0;float u_pca_tmp_1[4];
+			int err_flag_2=0;float rho_2=0;float u_pca_tmp_2[4]; float m_zero[3]={0.0,  0.0,  0.0f};
+			Allocator_INDI.DP_LPCA_copy(_indi_fb,_error_fb, u_pca_tmp_1, err_flag_1, rho_1);
+			if (err_flag_1<0){
+			    Allocator_INDI.DP_LPCA_copy(m_zero,_indi_fb, u_pca_tmp_2, err_flag_2, rho_2);
+			    Allocator_INDI.restoring(u_pca_tmp_2,u_pca);
+			    allocation_value.flag=4;
+			}else{
+			    Allocator_INDI.restoring(u_pca_tmp_1,u_pca);
+			    allocation_value.flag=3;
+			}
+			for (size_t i = 0; i < 4; i++){
+				_u[i] = math::constrain((float) (u_pca[i]), (float) (_uMin[i]), (float) (_uMax[i]));
+			}
+
+		}
+		else if(_alloc_method==2){  // dir
+			// PX4_INFO("INDI dir");
+			float u_dir[4];int err_flag=0;float rho=0;float u_dir_tmp[4];float m_zero[3]={0.0,  0.0,  0.0f};
+			Allocator_INDI.DP_LPCA_copy(m_zero, _fb, u_dir_tmp, err_flag, rho); //error,
+			Allocator_INDI.restoring(u_dir_tmp,u_dir);
+			// Allocator_INDI.DP_LPCA(_fb, u_dir_tmp, err_flag, rho);
+			// Allocator_INDI.restoring(u_dir_tmp,u_dir);
+			// Allocator_INDI.DPscaled_LPCA(_fb, u_dir_tmp, err_flag, rho);
+			// Allocator_INDI.restoring(u_dir_tmp,u_dir);
+			for (size_t i = 0; i < 4; i++){
+				_u[i] = math::constrain((float) (u_dir[i]), (float) (_uMin[i]), (float) (_uMax[i]));
+			}
+			allocation_value.flag=2;
+		}
+		else if(_alloc_method==1){ //wls
+			//=========================WLS_alloc_gen===========================
+			// Strictly speaking, restoring is not necessary because WLS itself guarantees the minimum norm.
+			// PX4_INFO("INDI wls");
+			float u_wls[4];float gam = 1e6f; float W0[4]={0.0f, 0.0f, 0.0f, 0.0f};  float u_d[4] = {0.0f, 0.0f, 0.0f, 0.0f};
+			wls_alloc_gen(_B_array, _fb, _uMin, _uMax, _I3_array, _I4_array, u_d, gam, u_wls, W0, 100, 4);
+			for (size_t i = 0; i < 4; i++){
+				_u[i] = math::constrain((float) (u_wls[i]), (float) (_uMin[i]), (float) (_uMax[i]));
+			}
+			allocation_value.flag=1;
+		}else{ //0 inv
+			// PX4_INFO("INDI inv");
+			matrix::Matrix<float, 3, 1> y_desire (_fb);
+			matrix::Matrix<float, 4, 1> u_inv = B_inv * y_desire;
+			for (size_t i = 0; i < 4; i++){
+				_u[i] =  math::constrain( u_inv(i,0), _uMin[i], _uMax[i]);
+			}
+			allocation_value.flag=0;
+			// PX4_INFO("indi: u_inv: %f, u2: %f, u3: %f, u4: %f. \n",(double) u_inv(0,0),(double) u_inv(1,0),(double) u_inv(2,0),(double) u_inv(3,0));
+		}
+		for (size_t i = 0; i < 3; i++){
+			float  temp = 0.0f;
+			for(int k = 0 ; k < 4 ; k++)
+			{
+				temp += _B[i][k] * _u[k];
+			}
+			allocation_value.error[i] =_fb[i] - temp;
+		}
+		for (size_t i = 0; i < 4; i++){
+			allocation_value.u[i] = _u[i];
+			allocation_value.umin[i] = _uMin[i];
+			allocation_value.umax[i] = _uMax[i];
+			//实际系统不使用额外执行器模拟。仿真中均可（默认使用，不使用时，为了估计值准确，时间常数置0）。
+			_u_estimate[i] = first_order_update_zoh(_u[i], _last_u[i], _time_const, 1.0f/_sample_freq);
+			if(_param_use_actuator.get() == 1){
+				// PX4_INFO("use actuator");
+				_u_cmd[i] = _u_estimate[i]; //仿真中执行器是即时的，观测值直接作为舵指令，也即为舵实际位置。仿真中使用执行器，则估计是完美估计，若不使用执行器，令一阶估计时间常数为零，_u_estimate=_u, ，此时也是完美估计。
+			}
+			else{
+				// PX4_INFO("not use actuator");
+				_u_cmd[i] = _u[i]; // 实际中，_u_cmd 为舵指令， _u_estimate 是舵实际值的估计。
+			}
+			_last_u[i] = _u_cmd[i]; // save last u for first order update
+			allocation_value.u_ultimate[i] = _u_cmd[i];
+		}
+
+		// // 两个标志位共同使能，要使遥控器控制，参数必须使用默认值。这里，遥控器和参数都是各自更新的。
+		// 实际飞行中，飞机实际配置总是使得滚转-10，俯仰+10.为了对照，调整1-4的舵扰动由++--为-++-。此时相当于有了6deg的舵扰动，只需要加2
+		if(_use_dist==1 || _rc_dist_flag){
+			outputs[0+4] = (_u_cmd[0]-_dist_mag)/0.3491f;
+			outputs[1+4] = (_u_cmd[1]+_dist_mag)/0.3491f;
+			outputs[2+4] = (_u_cmd[2]+_dist_mag)/0.3491f;
+			outputs[3+4] = (_u_cmd[3]-_dist_mag)/0.3491f;
+		}
+		else{
+			for (size_t i = 0; i < 4; i++){
+				outputs[i+4] = (_u_cmd[i])/0.3491f;
+			}
+		}
+
+	}
+	else{ //PID是没有加舵扰动，也没有模型的变化。分配参数不变，仅多对比基准。
+		if (_use_alloc == 1){ //_use_alloc only use for PID
+			// when using PID, >> B_inv_PID=[-1 0 1;0 -1 1;1 0 1;0 1 1], _B_PID=pinv(B_inv_PID)
+			// _B_PID =
+			//    -0.5000         0    0.5000         0
+			//    -0.0000   -0.5000   -0.0000    0.5000
+			//     0.2500    0.2500    0.2500    0.2500
+			_fb[0] = math::constrain(_controls[0].control[actuator_controls_s::INDEX_ROLL], -1.f, 1.f);
+			_fb[1] = math::constrain(_controls[0].control[actuator_controls_s::INDEX_PITCH], -1.f, 1.f);
+			_fb[2] = math::constrain(_controls[0].control[actuator_controls_s::INDEX_YAW], -1.f, 1.f);
+			if (_alloc_method==2 || _alloc_method==3){ // dir or pca
+				float u_all[4];
+				int err = 0;
+				float rho;
+
+				// Allocator_PID.DP_LPCA(_fb,u_all,err, rho); // The message "No Initial Feasible Solution found" will appear. change tol.
+				// Allocator_PID.DPscaled_LPCA(_fb, u_all, err, rho);
+				float u_pid_tmp[4]; float m_zero[3]={0.0,  0.0,  0.0f};
+				Allocator_PID.DP_LPCA_copy(m_zero,_fb, u_pid_tmp, err, rho);
+				Allocator_PID.restoring(u_pid_tmp,u_all);
+				// = dir
+				for (size_t i = 0; i < 4; i++){
+					_u[i] =  math::constrain( u_all[i], _uMin_PID[i], _uMax_PID[i]);
+				}
+				allocation_value.flag=2;
+				// PX4_INFO("PID PCA 1 == INV since higher is zro");
+			}
+			else if(_alloc_method==1){ // wls
+				// PX4_INFO("PID wls");
+				float u_wls[4];float gam = 1e6f; float W0[4]={0.0f, 0.0f, 0.0f, 0.0f};  float u_d[4] = {0.0f, 0.0f, 0.0f, 0.0f};
+				wls_alloc_gen(_B_PID_array, _fb, _uMin_PID, _uMax_PID, _I3_array, _I4_array, u_d, gam, u_wls, W0, 100, 4);
+				for (size_t i = 0; i < 4; i++){
+					_u[i] = math::constrain((float) (u_wls[i]), (float) (_uMin_PID[i]), (float) (_uMax_PID[i]));
+				}
+				allocation_value.flag=1;
+			}else{ // inv
+				// PX4_INFO("PID inv");
+				matrix::Matrix<float, 3, 1> y_desire (_fb);
+				matrix::Matrix<float, 4, 1> u_inv = B_inv_PID * y_desire;
+				for (size_t i = 0; i < 4; i++)
+				{
+					_u[i] =  math::constrain( u_inv(i,0), _uMin_PID[i], _uMax_PID[i]);
+				}
+				allocation_value.flag=0;
+				// PX4_INFO("pid: u_inv: %f, u2: %f, u3: %f, u4: %f. \n",(double) u_inv(0,0),(double) u_inv(1,0),(double) u_inv(2,0),(double) u_inv(3,0));
+			}
+			for (size_t i = 0; i < 3; i++){
+				float  temp = 0.0f;
+				for(int k = 0 ; k < 4 ; k++)
+				{
+					temp += _B_PID[i][k] * _u[k];
+				}
+				allocation_value.error[i] =_fb[i] - temp;
+			}
+			for (size_t i = 0; i < 4; i++){
+				allocation_value.u[i] = _u[i];
+				allocation_value.umin[i] = _uMin_PID[i];
+				allocation_value.umax[i] = _uMax_PID[i];
+				_u_estimate[i] = first_order_update_zoh(_u[i], _last_u[i], _time_const, 1.0f/_sample_freq);
+				if(_param_use_actuator.get() == 1){
+					// PX4_INFO("use actuator");
+					_u_cmd[i] = _u_estimate[i];
+				}
+				else{
+					// PX4_INFO("not use actuator");
+					_u_cmd[i] = _u[i];
+				}
+				_last_u[i] = _u_cmd[i]; // save last u for first order update
+				allocation_value.u_ultimate[i] = _u_cmd[i];
+			}
+			for (size_t i = 0; i < 4; i++){
+				outputs[i+4] = _u_cmd[i];// 限幅-1～+1，所以不需要改单位
+			}
+		}
+		else{ // origin system
+			for (size_t i = 0; i < 4; i++){
+				_u_cmd[i] = outputs[i+4]*0.3491f;
+				allocation_value.u[i] = _u_cmd[i];
+				allocation_value.u_ultimate[i] = _u_cmd[i];
+
+			}
+		}
+	}
+	timestamp_ca_end = hrt_absolute_time();
+	// PX4_INFO("alloc time: %lld \n", (timestamp_ca_end - timestamp_ca_start) ); //nuttx
+	_allocation_runing_time_us = (timestamp_ca_end - timestamp_ca_start); //us
+	allocation_value.timestamp = timestamp_ca_end;
+	allocation_value.timestamp_sample=_allocation_runing_time_us;
+	_allocation_value_pub.publish(allocation_value);
+
+	/* the output limit call takes care of out of band errors, NaN and constrains */ // [-1, 1] -> [min_rad, max_rad] == [min_pwm, max_pwm]
 	output_limit_calc(_throttle_armed, armNoThrottle(), mixed_num_outputs, _reverse_output_mask,
 			  _disarmed_value, _min_value, _max_value, outputs, _current_output_value, &_output_limit);

@@ -425,6 +977,12 @@ bool MixingOutput::update()
 	/* apply _param_mot_ordering */
 	reorderOutputs(_current_output_value);

+	//updateParams();
+	// _current_output_value[1] = _param_ductedfan_mid1.get();
+	//_current_output_value[2] = _param_ductedfan_mid2.get();
+
+
+
 	/* now return the outputs to the driver */
 	if (_interface.updateOutputs(stop_motors, _current_output_value, mixed_num_outputs, n_updates)) {
 		actuator_outputs_s actuator_outputs{};
@@ -434,6 +992,8 @@ bool MixingOutput::update()
 		updateLatencyPerfCounter(actuator_outputs);
 	}

+
+
 	handleCommands();

 	return true;
@@ -450,6 +1010,15 @@ MixingOutput::setAndPublishActuatorOutputs(unsigned num_outputs, actuator_output

 	actuator_outputs.timestamp = hrt_absolute_time();
 	_outputs_pub.publish(actuator_outputs);
+	// publish cs delta for indi controller
+	actuator_outputs_value_s actuator_outputs_value{};
+	for (size_t i = 0; i < 4; ++i) {
+		actuator_outputs_value.delta[i] = math::constrain(_lp_filter_actuator[i].apply(_u_estimate[i]), (float) (_uMin[i]), (float) (_uMax[i]));// indi使用的u总是基于估计值，仿真中即为真值，实际中是执行器位置的估计值。
+		_delta_prev[i] = actuator_outputs_value.delta[i];
+	}
+	actuator_outputs_value.timestamp = hrt_absolute_time();
+	_outputs_value_pub.publish(actuator_outputs_value);
+
 }

 void
@@ -532,10 +1101,8 @@ int MixingOutput::controlCallback(uintptr_t handle, uint8_t control_group, uint8
 	const MixingOutput *output = (const MixingOutput *)handle;

 	input = output->_controls[control_group].control[control_index];
-
 	/* limit control input */
 	input = math::constrain(input, -1.f, 1.f);
-
 	/* motor spinup phase - lock throttle to zero */
 	if (output->_output_limit.state == OUTPUT_LIMIT_STATE_RAMP) {
 		if (((control_group == actuator_controls_s::GROUP_INDEX_ATTITUDE ||
diff --git a/src/lib/mixer_module/mixer_module.hpp b/src/lib/mixer_module/mixer_module.hpp
index 7cddbc79ee..4b9fe4ce12 100644
--- a/src/lib/mixer_module/mixer_module.hpp
+++ b/src/lib/mixer_module/mixer_module.hpp
@@ -48,10 +48,20 @@
 #include <uORB/topics/actuator_armed.h>
 #include <uORB/topics/actuator_controls.h>
 #include <uORB/topics/actuator_outputs.h>
+#include <uORB/topics/actuator_outputs_value.h>
+#include <uORB/topics/allocation_value.h>
 #include <uORB/topics/multirotor_motor_limits.h>
 #include <uORB/topics/parameter_update.h>
 #include <uORB/topics/test_motor.h>
-
+#include <uORB/topics/rc_channels.h>
+#include <lib/mathlib/math/Limits.hpp>
+#include <lib/matrix/matrix/math.hpp>
+#include <mathlib/math/filter/LowPassFilter2p.hpp>
+#include <lib/mathlib/math/filter/NotchFilter.hpp>
+// #include <lib/ecl/EKF/RingBuffer.h>
+
+#include "ControlAllocation.h"
+#include "wls_alloc_gen.h"
 /**
  * @class OutputModuleInterface
  * Base class for an output module.
@@ -184,6 +194,8 @@ protected:
 	void updateParams() override;

 private:
+
+	void CheckAndUpdateFilters();
 	void handleCommands();

 	bool armNoThrottle() const
@@ -242,6 +254,8 @@ private:
 	uORB::SubscriptionCallbackWorkItem _control_subs[actuator_controls_s::NUM_ACTUATOR_CONTROL_GROUPS];

 	uORB::PublicationMulti<actuator_outputs_s> _outputs_pub{ORB_ID(actuator_outputs)};
+	uORB::PublicationMulti<allocation_value_s> _allocation_value_pub{ORB_ID(allocation_value)};
+	uORB::Publication<actuator_outputs_value_s> _outputs_value_pub{ORB_ID(actuator_outputs_value)};
 	uORB::PublicationMulti<multirotor_motor_limits_s> _to_mixer_status{ORB_ID(multirotor_motor_limits)}; 	///< mixer status flags

 	actuator_controls_s _controls[actuator_controls_s::NUM_ACTUATOR_CONTROL_GROUPS] {};
@@ -249,6 +263,14 @@ private:

 	hrt_abstime _time_last_dt_update_multicopter{0};
 	hrt_abstime _time_last_dt_update_simple_mixer{0};
+
+	float _delta_prev[4]={0.0, 0.0, 0.0, 0.0};
+	bool _sample_rate_changed = false;
+
+	// angular velocity filters
+	math::LowPassFilter2p<float> _lp_filter_actuator[4]={math::LowPassFilter2p<float>{250,20.f},math::LowPassFilter2p<float>{250,20.f},math::LowPassFilter2p<float>{250,20.f},math::LowPassFilter2p<float>{250,20.f}};
+
+
 	unsigned _max_topic_update_interval_us{0}; ///< max _control_subs topic update interval (0=unlimited)

 	bool _throttle_armed{false};
@@ -276,11 +298,101 @@ private:

 	perf_counter_t _control_latency_perf;

+	float _indi_fb[3] = {0.0, 0.0, 0.0};
+	float _error_fb[3] = {0.0, 0.0, 0.0};
+	float _fb[3] = {0.0, 0.0, 0.0};
+	float _sample_freq{200.0f}; // update rate of MixingOutput, also sample rate of lowpass filter (Hz).
+	bool _use_alloc{false};
+	uint16_t _alloc_method{0};
+	bool _use_dist{false};
+	bool _pre_rc_dist_flag{false};
+	uORB::Subscription _rc_channels_sub{ORB_ID(rc_channels)};
+	rc_channels_s		_rc_channels{};
+	bool _rc_dist_flag{false};
+
+	float _dist_mag{0.0f};
+	float pert_to_cs{0.0f};
+	float _uMin[4] {};
+	float _uMax[4] {};
+	float _u[4] {0.0f, 0.0f, 0.0f, 0.0f};
+	float _u_cmd[4] {0.0f, 0.0f, 0.0f, 0.0f};
+	float _u_estimate[4] {0.0f, 0.0f, 0.0f, 0.0f};
+	float _last_u[4] {0.0f, 0.0f, 0.0f, 0.0f};
+	// for _B _B_PID B_inv B_inv_PID .
+	// If B is full raw rank, The Moore–Penrose Pseudo-inverse B^+= B^T (B B^T)^{-1},since
+	// B=K*P, K=I\diag([l1 l1 l2])k, P=[-1     0     1     0; 0    -1     0     1; 1     1     1     1];   K=diag([ k*l1/I_x  k*l1/I_y  k*l2/I_z  ])
+        // B^{\dagger} = P^\top K K^{-1} (P P^\top)^{-1} K^{-1} = P^\top (P P^\top)^{-1} K^{-1}=P^{\dagger} K^{-1}
+	// P^{\dagger}=[-0.5000   -0.0000    0.2500;0   -0.5000    0.2500;0.5000   -0.0000    0.2500;0    0.5000    0.2500]
+	// B^{\dagger}=P^{\dagger} K^{-1}=[-0.5000   -0.0000    0.2500;0   -0.5000    0.2500;0.5000   -0.0000    0.2500;0    0.5000    0.2500]*diag([ I_x/(k*l1)  I_y/(k*l1)  I_z/(k*l2)  ])
+	//
+	float _I_x{0.01149f};//setting in the .sdf
+	float _I_y{0.01153f};//setting in the .sdf
+	float _I_z{0.00487f};//setting in the .sdf
+	float _L_1{0.167f}; //setting in the .sdf
+	float _L_2{0.069f}; //setting in the .sdf
+	float _k{3.0f};	// USER_OMEGA_2_F, k  =_k_cv*_k_v*_k_v, setting k in the gazebo
+
+
+	matrix::Matrix<float, 4, 3> B_inv;
+	// const float _B[3][4]       = { {-46.2254,0.0,46.2254,0.0}, {0.0,-46.0825,0.0,46.0825},{46.7411,46.7411,46.7411,46.7411}};
+	float _B[3][4]    = { {-43.6031,0.0,43.6031,0.0}, {0.0,-43.4519,0.0,43.4519},{42.5051,42.5051,42.5051,42.5051}}; // Use a larger value of tol of struct LinearProgrammingProblem
+	float lower{-0.3491f};
+    	float upper{0.3491f};
+	Aircraft<3, 4> df_4; // 创建一个具有 4 个操纵向量和 3 个广义力矩的飞行器对象
+	DP_LP_ControlAllocator<3, 4> Allocator_INDI; // 创建一个控制分配器对象，用于具有 4 个操纵向量和 3 个广义力矩的飞行器(转化为线性规划问题，其维数和参数 <3, 4> 有关。)
+	// for wls
+	float _B_array[12];
+	float _I4_array[16] = {
+	1.0f, 0.0f, 0.0f, 0.0f,
+	0.0f, 1.0f, 0.0f, 0.0f,
+	0.0f, 0.0f, 1.0f, 0.0f,
+	0.0f, 0.0f, 0.0f, 1.0f
+	};
+	float _I3_array[9] = {
+	1.0f, 0.0f, 0.0f,  // 第1行
+	0.0f, 1.0f, 0.0f,  // 第2行
+	0.0f, 0.0f, 1.0f   // 第3行
+	};
+
+	// for PX4 PID controller, k=1, I_x=1, I_y=1, I_z=1
+	matrix::Matrix<float, 4, 3> B_inv_PID;
+	const float _B_PID[3][4] = { {-0.5,0.0,0.5,0.0}, {0.0,-0.5,0.0,0.5},{0.25,0.25,0.25,0.25}};
+	float _B_PID_array[12];
+	float lower_PID{-1.0f};
+    	float upper_PID{1.0f};
+	float _uMin_PID[4] {};
+	float _uMax_PID[4] {};
+	Aircraft<3, 4> df_4_PID; // 创建一个具有 4 个操纵向量和 3 个广义力矩的飞行器对象
+	DP_LP_ControlAllocator<3, 4> Allocator_PID; // 创建一个控制分配器对象，用于具有 4 个操纵向量和 3 个广义力矩的飞行器(转化为线性规划问题，其维数和参数 <3, 4> 有关。)
+	// 然后可以使用飞行器对象和控制分配器对象进行操作
+
+	hrt_abstime _allocation_runing_time_us{0};
+	hrt_abstime _allocation_test_runing_time_us1{0};
+	hrt_abstime _allocation_test_runing_time_us2{0};
+	hrt_abstime _allocation_test_runing_time_us3{0};
+	hrt_abstime _allocation_test_runing_time_us4{0};
+	hrt_abstime _allocation_test_runing_time_us5{0};
+	hrt_abstime _allocation_test_runing_time_us6{0};
+	float first_order_update(float u, float u_pre, float T, float dt);
+	float first_order_update_zoh(float u_pre, float y_pre, float T, float dt);
+	float _time_const{0.01f};
+	uint16_t _use_ac_test{0};
 	DEFINE_PARAMETERS(
 		(ParamInt<px4::params::MC_AIRMODE>) _param_mc_airmode,   ///< multicopter air-mode
 		(ParamFloat<px4::params::MOT_SLEW_MAX>) _param_mot_slew_max,
 		(ParamFloat<px4::params::THR_MDL_FAC>) _param_thr_mdl_fac, ///< thrust to motor control signal modelling factor
-		(ParamInt<px4::params::MOT_ORDERING>) _param_mot_ordering
-
+		(ParamInt<px4::params::MOT_ORDERING>) _param_mot_ordering,
+		// (ParamInt<px4::params::USER_DF_MID1>) _param_ductedfan_mid1,
+		// (ParamInt<px4::params::USER_DF_MID2>) _param_ductedfan_mid2,
+		(ParamInt<px4::params::USER_AC_METHOD>) _param_alloc_method,
+		(ParamInt<px4::params::USER_PID_CA>) _param_use_alloc,
+		(ParamInt<px4::params::USER_USE_INDI>) _param_use_indi,
+		(ParamFloat<px4::params::USER_CS_CUTOFF>) _param_cs_cutoff,
+		(ParamInt<px4::params::USER_ADD_DIST>) _param_use_dist,
+		(ParamFloat<px4::params::USER_DIST_MAG>) _param_dist_mag,
+		(ParamFloat<px4::params::USER_TIME_CONST>) _param_time_const,
+		(ParamInt<px4::params::USER_ACTUATOR>) _param_use_actuator,
+		(ParamFloat<px4::params::USER_OMEGA_2_F>) _param_k,
+		(ParamInt<px4::params::USER_AC_TEST>) _param_ac_test
 	)
 };
diff --git a/src/lib/mixer_module/params.c b/src/lib/mixer_module/params.c
index 040c77b74b..87ff71e06d 100644
--- a/src/lib/mixer_module/params.c
+++ b/src/lib/mixer_module/params.c
@@ -33,3 +33,125 @@ PARAM_DEFINE_INT32(MC_AIRMODE, 0);
  * @group Mixer Output
  */
 PARAM_DEFINE_INT32(MOT_ORDERING, 0);
+
+/**
+ * PWM_DUCTEDFAN_MID1
+ *
+ * The PWM value of the midpoint of the servo.
+ *
+ * @min 1000
+ * @max 2000
+ * @group Mixer Output
+ */
+PARAM_DEFINE_INT32(USER_DF_MID1, 1500);
+
+/**
+ * PWM_DUCTEDFAN_MID2
+ *
+ * The PWM value of the midpoint of the servo.
+ *
+ * @min 1000
+ * @max 2000
+ * @group Mixer Output
+ */
+PARAM_DEFINE_INT32(USER_DF_MID2, 1500);
+
+/**
+ * USER_PID_CA
+ *
+ * use control allocation or not.
+ *
+ * @value 0 default mix=inv
+ * @value 1 PID CA
+ * @group Mixer Output
+ */
+PARAM_DEFINE_INT32(USER_PID_CA, 0);
+
+/**
+ * USER_AC_METHOD
+ *
+ * use priority control allocation or not.
+ *
+ * @value 0 inv
+ * @value 1 WLS
+ * @value 2 DIR
+ * @value 3 PCA
+ * @group Mixer Output
+ */
+PARAM_DEFINE_INT32(USER_AC_METHOD, 0);
+
+/**
+ * USER_ADD_DIST
+ *
+ * use disturbance or not.
+ *
+ * @value 0 without
+ * @value 1 add disturbance
+ * @group Mixer Output
+ */
+PARAM_DEFINE_INT32(USER_ADD_DIST, 0);
+
+/**
+* Low pass filter cutoff frequency for control surface
+*
+* The cutoff frequency for the 2nd order butterworth filter on the primary gyro.
+* This only affects the deflection angular sent to the controllers.
+*
+* A value of 0 disables the filter.
+*
+* @min 0
+* @max 1000
+* @unit Hz
+* @group Mixer Output
+*/
+PARAM_DEFINE_FLOAT(USER_CS_CUTOFF, 10.0f);
+
+/**
+* USER_DIST_MAG
+*
+* The magnitude of the disturbance added to the control surfaces.
+*
+* @min 0
+* @max 0.3491
+* @unit rad
+* @decimal 4
+* @increment 0.0001
+* @group Mixer Output
+*/
+PARAM_DEFINE_FLOAT(USER_DIST_MAG, 0.0f);
+
+/**
+* USER_TIME_CONST
+*
+* time Constant of actuator.
+*
+* @min 0.0001
+* @max 0.1
+* @unit s
+* @decimal 4
+* @increment 0.0001
+* @group Mixer Output
+*/
+PARAM_DEFINE_FLOAT(USER_TIME_CONST, 0.03f);
+
+/**
+ * USER_ACTUATOR
+ *
+ * use ACTUATOR simulate or not.
+ *
+ * @value 0 without
+ * @value 1 actuator simulation
+ * @group Mixer Output
+ */
+PARAM_DEFINE_INT32(USER_ACTUATOR, 0);
+
+/**
+ * USER_AC_TEST
+ *
+ * running test or not.
+ *
+ * @value 0 without
+ * @value 1 running test
+ * @group Mixer Output
+ */
+PARAM_DEFINE_INT32(USER_AC_TEST, 0);
diff --git a/src/lib/mixer_module/rtwtypes.h b/src/lib/mixer_module/rtwtypes.h
new file mode 100644
index 0000000000..b15ab7aa72
--- /dev/null
+++ b/src/lib/mixer_module/rtwtypes.h
@@ -0,0 +1,149 @@
+/*
+ * File: rtwtypes.h
+ *
+ * MATLAB Coder version            : 24.1
+ * C/C++ source code generated on  : 2025-06-16 11:03:22
+ */
+
+#ifndef RTWTYPES_H
+#define RTWTYPES_H
+
+/* Include Files */
+
+#ifndef __cplusplus
+#include <stdbool.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*=======================================================================*
+ * Target hardware information
+ *   Device type: ARM Compatible->ARM 9
+ *   Number of bits:     char:   8    short:   16    int:  32
+ *                       long:  32
+ *                       native word size:  32
+ *   Byte ordering: LittleEndian
+ *   Signed integer division rounds to: Zero
+ *   Shift right on a signed integer as arithmetic shift: on
+ *=======================================================================*/
+
+/*=======================================================================*
+ * Fixed width word size data types:                                     *
+ *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *
+ *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *
+ *   real32_T, real64_T           - 32 and 64 bit floating point numbers *
+ *=======================================================================*/
+typedef signed char int8_T;
+typedef unsigned char uint8_T;
+typedef short int16_T;
+typedef unsigned short uint16_T;
+typedef int int32_T;
+typedef unsigned int uint32_T;
+typedef float real32_T;
+typedef double real64_T;
+
+/*===========================================================================*
+ * Generic type definitions: real_T, time_T, boolean_T, int_T, uint_T,       *
+ *                           ulong_T, char_T and byte_T.                     *
+ *===========================================================================*/
+
+typedef double real_T;
+typedef double time_T;
+typedef bool boolean_T;
+typedef int int_T;
+typedef unsigned int uint_T;
+typedef unsigned long ulong_T;
+typedef char char_T;
+typedef char_T byte_T;
+
+/*===========================================================================*
+ * Complex number type definitions                                           *
+ *===========================================================================*/
+#define CREAL_T
+
+typedef struct {
+  real32_T re;
+  real32_T im;
+} creal32_T;
+
+typedef struct {
+  real64_T re;
+  real64_T im;
+} creal64_T;
+
+typedef struct {
+  real_T re;
+  real_T im;
+} creal_T;
+
+typedef struct {
+  int8_T re;
+  int8_T im;
+} cint8_T;
+
+typedef struct {
+  uint8_T re;
+  uint8_T im;
+} cuint8_T;
+
+typedef struct {
+  int16_T re;
+  int16_T im;
+} cint16_T;
+
+typedef struct {
+  uint16_T re;
+  uint16_T im;
+} cuint16_T;
+
+typedef struct {
+  int32_T re;
+  int32_T im;
+} cint32_T;
+
+typedef struct {
+  uint32_T re;
+  uint32_T im;
+} cuint32_T;
+
+/*=======================================================================*
+ * Min and Max:                                                          *
+ *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *
+ *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *
+ *=======================================================================*/
+
+#define MAX_int8_T ((int8_T)(127))
+#define MIN_int8_T ((int8_T)(-128))
+#define MAX_uint8_T ((uint8_T)(255))
+#define MIN_uint8_T ((uint8_T)(0))
+#define MAX_int16_T ((int16_T)(32767))
+#define MIN_int16_T ((int16_T)(-32768))
+#define MAX_uint16_T ((uint16_T)(65535))
+#define MIN_uint16_T ((uint16_T)(0))
+#define MAX_int32_T ((int32_T)(2147483647))
+#define MIN_int32_T ((int32_T)(-2147483647 - 1))
+#define MAX_uint32_T ((uint32_T)(0xFFFFFFFFU))
+#define MIN_uint32_T ((uint32_T)(0))
+
+/* Logical type definitions */
+#if (!defined(__cplusplus)) && (!defined(__true_false_are_keywords)) &&        \
+    (!defined(__bool_true_false_are_defined))
+#ifndef false
+#define false 0U
+#endif
+#ifndef true
+#define true 1U
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+/*
+ * File trailer for rtwtypes.h
+ *
+ * [EOF]
+ */
diff --git a/src/lib/mixer_module/wls_alloc_gen.c b/src/lib/mixer_module/wls_alloc_gen.c
new file mode 100644
index 0000000000..649caeec38
--- /dev/null
+++ b/src/lib/mixer_module/wls_alloc_gen.c
@@ -0,0 +1,935 @@
+/*
+ * File: wls_alloc_gen.c
+ *
+ * MATLAB Coder version            : 24.1
+ * C/C++ source code generated on  : 2025-06-16 11:03:22
+ */
+
+/* Include Files */
+#include "wls_alloc_gen.h"
+#include "wls_alloc_gen_emxutil.h"
+#include "wls_alloc_gen_types.h"
+#include <math.h>
+#include <string.h>
+
+/* Function Declarations */
+static void binary_expand_op(float in1[4], float in2,
+                             const emxArray_real32_T *in3);
+
+static void binary_expand_op_1(bool in1[4], const bool in2[4],
+                               const emxArray_real32_T *in3);
+
+static void binary_expand_op_2(bool in1[4], const bool in2[4],
+                               const emxArray_real32_T *in3);
+
+static int div_nde_s32_floor(int numerator);
+
+static void plus(float in1[4], const float in2[4],
+                 const emxArray_real32_T *in3);
+
+static float rt_hypotf(float u0, float u1);
+
+static int xgeqp3(float A_data[], const int A_size[2], float tau_data[],
+                  int jpvt_data[], int jpvt_size[2]);
+
+static float xnrm2(int n, const float x_data[], int ix0);
+
+/* Function Definitions */
+/*
+ * Arguments    : float in1[4]
+ *                float in2
+ *                const emxArray_real32_T *in3
+ * Return Type  : void
+ */
+static void binary_expand_op(float in1[4], float in2,
+                             const emxArray_real32_T *in3)
+{
+  const float *in3_data;
+  int stride_0_0;
+  in3_data = in3->data;
+  stride_0_0 = (in3->size[0] != 1);
+  in1[0] += in2 * in3_data[0];
+  in1[1] += in2 * in3_data[stride_0_0];
+  in1[2] += in2 * in3_data[stride_0_0 << 1];
+  in1[3] += in2 * in3_data[3 * stride_0_0];
+}
+
+/*
+ * Arguments    : bool in1[4]
+ *                const bool in2[4]
+ *                const emxArray_real32_T *in3
+ * Return Type  : void
+ */
+static void binary_expand_op_1(bool in1[4], const bool in2[4],
+                               const emxArray_real32_T *in3)
+{
+  const float *in3_data;
+  int stride_0_0;
+  in3_data = in3->data;
+  stride_0_0 = (in3->size[0] != 1);
+  in1[0] = (in2[0] && (in3_data[0] > 0.0F));
+  in1[1] = (in2[1] && (in3_data[stride_0_0] > 0.0F));
+  in1[2] = (in2[2] && (in3_data[stride_0_0 << 1] > 0.0F));
+  in1[3] = (in2[3] && (in3_data[3 * stride_0_0] > 0.0F));
+}
+
+/*
+ * Arguments    : bool in1[4]
+ *                const bool in2[4]
+ *                const emxArray_real32_T *in3
+ * Return Type  : void
+ */
+static void binary_expand_op_2(bool in1[4], const bool in2[4],
+                               const emxArray_real32_T *in3)
+{
+  const float *in3_data;
+  int stride_0_0;
+  in3_data = in3->data;
+  stride_0_0 = (in3->size[0] != 1);
+  in1[0] = (in2[0] && (in3_data[0] < 0.0F));
+  in1[1] = (in2[1] && (in3_data[stride_0_0] < 0.0F));
+  in1[2] = (in2[2] && (in3_data[stride_0_0 << 1] < 0.0F));
+  in1[3] = (in2[3] && (in3_data[3 * stride_0_0] < 0.0F));
+}
+
+/*
+ * Arguments    : int numerator
+ * Return Type  : int
+ */
+static int div_nde_s32_floor(int numerator)
+{
+  int i;
+  if ((numerator < 0) && (numerator % 7 != 0)) {
+    i = -1;
+  } else {
+    i = 0;
+  }
+  return numerator / 7 + i;
+}
+
+/*
+ * Arguments    : float in1[4]
+ *                const float in2[4]
+ *                const emxArray_real32_T *in3
+ * Return Type  : void
+ */
+static void plus(float in1[4], const float in2[4], const emxArray_real32_T *in3)
+{
+  const float *in3_data;
+  int stride_0_0;
+  in3_data = in3->data;
+  stride_0_0 = (in3->size[0] != 1);
+  in1[0] = in2[0] + in3_data[0];
+  in1[1] = in2[1] + in3_data[stride_0_0];
+  in1[2] = in2[2] + in3_data[stride_0_0 << 1];
+  in1[3] = in2[3] + in3_data[3 * stride_0_0];
+}
+
+/*
+ * Arguments    : float u0
+ *                float u1
+ * Return Type  : float
+ */
+static float rt_hypotf(float u0, float u1)
+{
+  float a;
+  float b;
+  float y;
+  a = fabsf(u0);
+  b = fabsf(u1);
+  if (a < b) {
+    a /= b;
+    y = b * sqrtf(a * a + 1.0F);
+  } else if (a > b) {
+    b /= a;
+    y = a * sqrtf(b * b + 1.0F);
+  } else {
+    y = a * 1.41421354F;
+  }
+  return y;
+}
+
+/*
+ * Arguments    : float A_data[]
+ *                const int A_size[2]
+ *                float tau_data[]
+ *                int jpvt_data[]
+ *                int jpvt_size[2]
+ * Return Type  : int
+ */
+static int xgeqp3(float A_data[], const int A_size[2], float tau_data[],
+                  int jpvt_data[], int jpvt_size[2])
+{
+  float work_data[4];
+  int i;
+  int ix0;
+  int iy;
+  int k;
+  int tau_size;
+  tau_size = A_size[1];
+  if (tau_size - 1 >= 0) {
+    memset(&tau_data[0], 0, (unsigned int)tau_size * sizeof(float));
+  }
+  if (A_size[1] < 1) {
+    jpvt_size[0] = 1;
+    jpvt_size[1] = tau_size;
+    for (iy = 0; iy < tau_size; iy++) {
+      jpvt_data[iy] = iy + 1;
+    }
+  } else {
+    float vn1_data[4];
+    float vn2_data[4];
+    float absxk;
+    float scale;
+    float smax;
+    float t;
+    int kend;
+    jpvt_size[0] = 1;
+    jpvt_size[1] = tau_size;
+    for (k = 0; k < tau_size; k++) {
+      jpvt_data[k] = k + 1;
+      work_data[k] = 0.0F;
+      vn1_data[k] = 0.0F;
+      vn2_data[k] = 0.0F;
+      ix0 = k * 7;
+      smax = 0.0F;
+      scale = 1.29246971E-26F;
+      kend = ix0 + 7;
+      for (iy = ix0 + 1; iy <= kend; iy++) {
+        absxk = fabsf(A_data[iy - 1]);
+        if (absxk > scale) {
+          t = scale / absxk;
+          smax = smax * t * t + 1.0F;
+          scale = absxk;
+        } else {
+          t = absxk / scale;
+          smax += t * t;
+        }
+      }
+      absxk = scale * sqrtf(smax);
+      vn1_data[k] = absxk;
+      vn2_data[k] = absxk;
+    }
+    for (i = 0; i < tau_size; i++) {
+      int b_i;
+      int ii;
+      int ip1;
+      int nmi;
+      int pvt;
+      ip1 = i + 2;
+      ii = i * 7 + i;
+      nmi = tau_size - i;
+      if (nmi < 1) {
+        kend = -1;
+      } else {
+        kend = 0;
+        if (nmi > 1) {
+          smax = fabsf(vn1_data[i]);
+          for (k = 2; k <= nmi; k++) {
+            scale = fabsf(vn1_data[(i + k) - 1]);
+            if (scale > smax) {
+              kend = k - 1;
+              smax = scale;
+            }
+          }
+        }
+      }
+      pvt = i + kend;
+      if (pvt != i) {
+        kend = pvt * 7;
+        iy = i * 7;
+        for (k = 0; k < 7; k++) {
+          ix0 = kend + k;
+          smax = A_data[ix0];
+          b_i = iy + k;
+          A_data[ix0] = A_data[b_i];
+          A_data[b_i] = smax;
+        }
+        kend = jpvt_data[pvt];
+        jpvt_data[pvt] = jpvt_data[i];
+        jpvt_data[i] = kend;
+        vn1_data[pvt] = vn1_data[i];
+        vn2_data[pvt] = vn2_data[i];
+      }
+      t = A_data[ii];
+      ix0 = ii + 2;
+      tau_data[i] = 0.0F;
+      smax = xnrm2(6 - i, A_data, ii + 2);
+      if (smax != 0.0F) {
+        absxk = A_data[ii];
+        scale = rt_hypotf(absxk, smax);
+        if (absxk >= 0.0F) {
+          scale = -scale;
+        }
+        if (fabsf(scale) < 9.86076132E-32F) {
+          kend = 0;
+          b_i = (ii - i) + 7;
+          do {
+            kend++;
+            for (k = ix0; k <= b_i; k++) {
+              A_data[k - 1] *= 1.01412048E+31F;
+            }
+            scale *= 1.01412048E+31F;
+            t *= 1.01412048E+31F;
+          } while ((fabsf(scale) < 9.86076132E-32F) && (kend < 20));
+          scale = rt_hypotf(t, xnrm2(6 - i, A_data, ii + 2));
+          if (t >= 0.0F) {
+            scale = -scale;
+          }
+          tau_data[i] = (scale - t) / scale;
+          smax = 1.0F / (t - scale);
+          for (k = ix0; k <= b_i; k++) {
+            A_data[k - 1] *= smax;
+          }
+          for (k = 0; k < kend; k++) {
+            scale *= 9.86076132E-32F;
+          }
+          t = scale;
+        } else {
+          tau_data[i] = (scale - absxk) / scale;
+          smax = 1.0F / (absxk - scale);
+          b_i = (ii - i) + 7;
+          for (k = ix0; k <= b_i; k++) {
+            A_data[k - 1] *= smax;
+          }
+          t = scale;
+        }
+      }
+      A_data[ii] = t;
+      if (i + 1 < tau_size) {
+        int lastv;
+        A_data[ii] = 1.0F;
+        k = ii + 8;
+        if (tau_data[i] != 0.0F) {
+          bool exitg2;
+          lastv = 7 - i;
+          kend = (ii - i) + 6;
+          while ((lastv > 0) && (A_data[kend] == 0.0F)) {
+            lastv--;
+            kend--;
+          }
+          nmi -= 2;
+          exitg2 = false;
+          while ((!exitg2) && (nmi + 1 > 0)) {
+            int exitg1;
+            kend = (ii + nmi * 7) + 7;
+            ix0 = kend;
+            do {
+              exitg1 = 0;
+              if (ix0 + 1 <= kend + lastv) {
+                if (A_data[ix0] != 0.0F) {
+                  exitg1 = 1;
+                } else {
+                  ix0++;
+                }
+              } else {
+                nmi--;
+                exitg1 = 2;
+              }
+            } while (exitg1 == 0);
+            if (exitg1 == 1) {
+              exitg2 = true;
+            }
+          }
+        } else {
+          lastv = 0;
+          nmi = -1;
+        }
+        if (lastv > 0) {
+          if (nmi + 1 != 0) {
+            if (nmi >= 0) {
+              memset(&work_data[0], 0, (unsigned int)(nmi + 1) * sizeof(float));
+            }
+            b_i = (ii + 7 * nmi) + 8;
+            for (iy = k; iy <= b_i; iy += 7) {
+              smax = 0.0F;
+              pvt = (iy + lastv) - 1;
+              for (ix0 = iy; ix0 <= pvt; ix0++) {
+                smax += A_data[ix0 - 1] * A_data[(ii + ix0) - iy];
+              }
+              kend = div_nde_s32_floor((iy - ii) - 8);
+              work_data[kend] += smax;
+            }
+          }
+          if (-tau_data[i] != 0.0F) {
+            kend = ii;
+            for (iy = 0; iy <= nmi; iy++) {
+              absxk = work_data[iy];
+              if (absxk != 0.0F) {
+                smax = absxk * -tau_data[i];
+                b_i = kend + 8;
+                pvt = lastv + kend;
+                for (ix0 = b_i; ix0 <= pvt + 7; ix0++) {
+                  A_data[ix0 - 1] += A_data[((ii + ix0) - kend) - 8] * smax;
+                }
+              }
+              kend += 7;
+            }
+          }
+        }
+        A_data[ii] = t;
+      }
+      for (iy = ip1; iy <= tau_size; iy++) {
+        kend = i + (iy - 1) * 7;
+        absxk = vn1_data[iy - 1];
+        if (absxk != 0.0F) {
+          smax = fabsf(A_data[kend]) / absxk;
+          smax = 1.0F - smax * smax;
+          if (smax < 0.0F) {
+            smax = 0.0F;
+          }
+          scale = absxk / vn2_data[iy - 1];
+          scale = smax * (scale * scale);
+          if (scale <= 0.000345266977F) {
+            absxk = xnrm2(6 - i, A_data, kend + 2);
+            vn1_data[iy - 1] = absxk;
+            vn2_data[iy - 1] = absxk;
+          } else {
+            vn1_data[iy - 1] = absxk * sqrtf(smax);
+          }
+        }
+      }
+    }
+  }
+  return tau_size;
+}
+
+/*
+ * Arguments    : int n
+ *                const float x_data[]
+ *                int ix0
+ * Return Type  : float
+ */
+static float xnrm2(int n, const float x_data[], int ix0)
+{
+  float scale;
+  float y;
+  int k;
+  int kend;
+  y = 0.0F;
+  scale = 1.29246971E-26F;
+  kend = (ix0 + n) - 1;
+  for (k = ix0; k <= kend; k++) {
+    float absxk;
+    absxk = fabsf(x_data[k - 1]);
+    if (absxk > scale) {
+      float t;
+      t = scale / absxk;
+      y = y * t * t + 1.0F;
+      scale = absxk;
+    } else {
+      float t;
+      t = absxk / scale;
+      y += t * t;
+    }
+  }
+  return scale * sqrtf(y);
+}
+
+/*
+ * change for matlab generate C, just add the param m, remove values of optional
+ * arguments, then this fuction can be used as lib. WLS_ALLOC - Control
+ * allocation using weighted least squares.
+ *
+ *   [u,W,iter] = wls_alloc(B,v,umin,umax,[Wv,Wu,ud,gamma,u0,W0,imax])
+ *
+ *  Solves the weighted, bounded least-squares problem
+ *
+ *    min ||Wu(u-ud)||^2 + gamma ||Wv(Bu-v)||^2
+ *
+ *    subj. to  umin <= u <= umax
+ *
+ *  using an active set method.
+ *
+ *   Inputs:
+ *   -------
+ *  B     control effectiveness matrix (k x m)
+ *  v     commanded virtual control (k x 1)
+ *  umin  lower position limits (m x 1)
+ *  umax  upper position limits (m x 1)
+ *  Wv    virtual control weighting matrix (k x k) [I]
+ *  Wu    control weighting matrix (m x m) [I]
+ *  ud    desired control (m x 1) [0]
+ *  gamma weight (scalar) [1e6]
+ *  u0    initial point (m x 1)
+ *  W0    initial working set (m x 1) [empty]
+ *  imax  max no. of iterations [100]
+ *
+ *   Outputs:
+ *   -------
+ *  u     optimal control
+ *  W     optimal active set
+ *  iter  no. of iterations (= no. of changes in the working set + 1)
+ *
+ *                             0 if u_i not saturated
+ *  Working set syntax: W_i = -1 if u_i = umin_i
+ *                            +1 if u_i = umax_i
+ *
+ *  See also: WLSC_ALLOC, IP_ALLOC, FXP_ALLOC, QP_SIM.
+ *
+ * Arguments    : const float B[12]
+ *                const float v[3]
+ *                const float umin[4]
+ *                const float umax[4]
+ *                const float Wv[9]
+ *                const float Wu[16]
+ *                const float ud[4]
+ *                float gam
+ *                float u[4]
+ *                float W[4]
+ *                float imax
+ *                float m
+ * Return Type  : void
+ */
+void wls_alloc_gen(const float B[12], const float v[3], const float umin[4],
+                   const float umax[4], const float Wv[9], const float Wu[16],
+                   const float ud[4], float gam, float u[4], float W[4],
+                   float imax, float m)
+{
+  static float A[28];
+  static float A_data[28];
+  static float b_gam_sq[12];
+  emxArray_real32_T *dist;
+  emxArray_real32_T *p;
+  float d[7];
+  float b_Wu[4];
+  float u_opt[4];
+  float c_gam_sq[3];
+  float f;
+  float f1;
+  float f2;
+  float gam_sq;
+  float *dist_data;
+  float *p_data;
+  int jpvt_data[4];
+  int A_size[2];
+  int aoffset;
+  int b_i;
+  int i;
+  int iter;
+  int j;
+  int k;
+  signed char tmp_data[4];
+  bool bv[4];
+  bool bv1[4];
+  bool i_free[4];
+  bool exitg1;
+  /*  Number of variables */
+  /*  m = length(umin); */
+  /*  Set default values of optional arguments */
+  /*  if nargin < 11 */
+  /*    imax = 100; % Heuristic value */
+  /*    [k,m] = size(B); */
+  /*    if nargin < 10, u = (umin+umax)/2; W = zeros(m,1); end */
+  /*    if nargin < 8,  gam = 1e6;       end */
+  /*    if nargin < 7,  ud = zeros(m,1); end */
+  /*    if nargin < 6,  Wu = eye(m);     end */
+  /*    if nargin < 5,  Wv = eye(k);     end */
+  /*  end */
+  gam_sq = sqrtf(gam);
+  for (i = 0; i < 3; i++) {
+    f = Wv[i];
+    f1 = Wv[i + 3];
+    f2 = Wv[i + 6];
+    for (k = 0; k < 4; k++) {
+      b_gam_sq[i + 3 * k] =
+          (gam_sq * f * B[3 * k] + gam_sq * f1 * B[3 * k + 1]) +
+          gam_sq * f2 * B[3 * k + 2];
+    }
+  }
+  for (i = 0; i < 4; i++) {
+    A[7 * i] = b_gam_sq[3 * i];
+    A[7 * i + 1] = b_gam_sq[3 * i + 1];
+    A[7 * i + 2] = b_gam_sq[3 * i + 2];
+    aoffset = i << 2;
+    A[7 * i + 3] = Wu[aoffset];
+    A[7 * i + 4] = Wu[aoffset + 1];
+    A[7 * i + 5] = Wu[aoffset + 2];
+    A[7 * i + 6] = Wu[aoffset + 3];
+  }
+  /*  Initial residual. */
+  f = v[0];
+  f1 = v[1];
+  f2 = v[2];
+  for (i = 0; i < 3; i++) {
+    c_gam_sq[i] = (gam_sq * Wv[i] * f + gam_sq * Wv[i + 3] * f1) +
+                  gam_sq * Wv[i + 6] * f2;
+  }
+  f = ud[0];
+  f1 = ud[1];
+  f2 = ud[2];
+  gam_sq = ud[3];
+  for (i = 0; i < 4; i++) {
+    b_Wu[i] =
+        ((Wu[i] * f + Wu[i + 4] * f1) + Wu[i + 8] * f2) + Wu[i + 12] * gam_sq;
+  }
+  d[0] = c_gam_sq[0];
+  d[1] = c_gam_sq[1];
+  d[2] = c_gam_sq[2];
+  d[3] = b_Wu[0];
+  d[4] = b_Wu[1];
+  d[5] = b_Wu[2];
+  d[6] = b_Wu[3];
+  f = u[0];
+  f1 = u[1];
+  f2 = u[2];
+  gam_sq = u[3];
+  for (i = 0; i < 7; i++) {
+    d[i] -= ((A[i] * f + A[i + 7] * f1) + A[i + 14] * f2) + A[i + 21] * gam_sq;
+  }
+  /*  Determine indeces of free variables. */
+  i_free[0] = (W[0] == 0.0F);
+  i_free[1] = (W[1] == 0.0F);
+  i_free[2] = (W[2] == 0.0F);
+  i_free[3] = (W[3] == 0.0F);
+  /*  Iterate until optimum is found or maximum number of iterations */
+  /*  is reached. */
+  iter = 0;
+  emxInit_real32_T(&p);
+  emxInit_real32_T(&dist);
+  exitg1 = false;
+  while ((!exitg1) && (iter <= (int)imax - 1)) {
+    float b_B[7];
+    float p_free_data[4];
+    int p_free_size;
+    int rankA;
+    int trueCount;
+    bool exitg2;
+    bool y;
+    /*  ---------------------------------------- */
+    /*   Compute optimal perturbation vector p. */
+    /*  ---------------------------------------- */
+    /*  Eliminate saturated variables. */
+    trueCount = 0;
+    if (i_free[0]) {
+      trueCount = 1;
+    }
+    if (i_free[1]) {
+      trueCount++;
+    }
+    if (i_free[2]) {
+      trueCount++;
+    }
+    if (i_free[3]) {
+      trueCount++;
+    }
+    aoffset = 0;
+    if (i_free[0]) {
+      tmp_data[0] = 0;
+      aoffset = 1;
+    }
+    if (i_free[1]) {
+      tmp_data[aoffset] = 1;
+      aoffset++;
+    }
+    if (i_free[2]) {
+      tmp_data[aoffset] = 2;
+      aoffset++;
+    }
+    if (i_free[3]) {
+      tmp_data[aoffset] = 3;
+    }
+    /*  Solve the reduced optimization problem for free variables. */
+    if (trueCount == 0) {
+      p_free_size = 0;
+    } else {
+      A_size[0] = 7;
+      A_size[1] = trueCount;
+      for (i = 0; i < trueCount; i++) {
+        for (k = 0; k < 7; k++) {
+          A_data[k + 7 * i] = A[k + 7 * tmp_data[i]];
+        }
+      }
+      int jpvt_size[2];
+      xgeqp3(A_data, A_size, b_Wu, jpvt_data, jpvt_size);
+      rankA = 0;
+      if (A_size[1] > 0) {
+        gam_sq = 8.34465E-6F * fabsf(A_data[0]);
+        while ((rankA < A_size[1]) &&
+               (fabsf(A_data[rankA + 7 * rankA]) > gam_sq)) {
+          rankA++;
+        }
+      }
+      for (b_i = 0; b_i < 7; b_i++) {
+        b_B[b_i] = d[b_i];
+      }
+      aoffset = A_size[1];
+      p_free_size = A_size[1];
+      for (j = 0; j < aoffset; j++) {
+        p_free_data[j] = 0.0F;
+        if (b_Wu[j] != 0.0F) {
+          gam_sq = b_B[j];
+          i = j + 2;
+          for (b_i = i; b_i < 8; b_i++) {
+            gam_sq += A_data[(b_i + 7 * j) - 1] * b_B[b_i - 1];
+          }
+          gam_sq *= b_Wu[j];
+          if (gam_sq != 0.0F) {
+            b_B[j] -= gam_sq;
+            for (b_i = i; b_i < 8; b_i++) {
+              b_B[b_i - 1] -= A_data[(b_i + 7 * j) - 1] * gam_sq;
+            }
+          }
+        }
+      }
+      for (b_i = 0; b_i < rankA; b_i++) {
+        p_free_data[jpvt_data[b_i] - 1] = b_B[b_i];
+      }
+      for (j = rankA; j >= 1; j--) {
+        i = jpvt_data[j - 1];
+        aoffset = 7 * (j - 1);
+        p_free_data[i - 1] /= A_data[(j + aoffset) - 1];
+        for (b_i = 0; b_i <= j - 2; b_i++) {
+          k = jpvt_data[b_i];
+          p_free_data[k - 1] -= p_free_data[i - 1] * A_data[b_i + aoffset];
+        }
+      }
+    }
+    /*  Zero all perturbations corresponding to active constraints. */
+    rankA = (int)m;
+    i = p->size[0];
+    p->size[0] = (int)m;
+    emxEnsureCapacity_real32_T(p, i);
+    p_data = p->data;
+    for (i = 0; i < rankA; i++) {
+      p_data[i] = 0.0F;
+    }
+    /*  Insert perturbations from p_free into free the variables. */
+    for (i = 0; i < p_free_size; i++) {
+      p_data[tmp_data[i]] = p_free_data[i];
+    }
+    /*  ---------------------------- */
+    /*   Is the new point feasible? */
+    /*  ---------------------------- */
+    if (p->size[0] == 4) {
+      u_opt[0] = u[0] + p_data[0];
+      u_opt[1] = u[1] + p_data[1];
+      u_opt[2] = u[2] + p_data[2];
+      u_opt[3] = u[3] + p_data[3];
+    } else {
+      plus(u_opt, u, p);
+    }
+    y = false;
+    aoffset = 0;
+    exitg2 = false;
+    while ((!exitg2) && (aoffset + 1 <= trueCount)) {
+      f = u_opt[tmp_data[aoffset]];
+      if ((f < umin[tmp_data[aoffset]]) || (f > umax[tmp_data[aoffset]])) {
+        y = true;
+        exitg2 = true;
+      } else {
+        aoffset++;
+      }
+    }
+    if (!y) {
+      bool x[4];
+      /*  ---------------------------- */
+      /*   Yes, check for optimality. */
+      /*  ---------------------------- */
+      /*  Update point and residual. */
+      u[0] = u_opt[0];
+      u[1] = u_opt[1];
+      u[2] = u_opt[2];
+      u[3] = u_opt[3];
+      for (b_i = 0; b_i < 7; b_i++) {
+        b_B[b_i] = 0.0F;
+      }
+      for (k = 0; k < trueCount; k++) {
+        aoffset = k * 7;
+        for (b_i = 0; b_i < 7; b_i++) {
+          i = aoffset + b_i;
+          b_B[b_i] += A[i % 7 + 7 * tmp_data[i / 7]] * p_free_data[k];
+        }
+      }
+      for (i = 0; i < 7; i++) {
+        d[i] -= b_B[i];
+      }
+      /*  Compute Lagrangian multipliers. */
+      /*  Are all lambda non-negative? */
+      for (b_i = 0; b_i < 4; b_i++) {
+        f = 0.0F;
+        for (i = 0; i < 7; i++) {
+          f += A[i + 7 * b_i] * d[i];
+        }
+        f *= W[b_i];
+        u_opt[b_i] = f;
+        x[b_i] = (f >= -2.22044605E-16F);
+      }
+      y = true;
+      k = 0;
+      exitg2 = false;
+      while ((!exitg2) && (k < 4)) {
+        if (!x[k]) {
+          y = false;
+          exitg2 = true;
+        } else {
+          k++;
+        }
+      }
+      if (y) {
+        /*  / ------------------------ \ */
+        /*  | Optimum found, bail out. | */
+        /*  \ ------------------------ / */
+        exitg1 = true;
+      } else {
+        /*  -------------------------------------------------- */
+        /*   Optimum not found, remove one active constraint. */
+        /*  -------------------------------------------------- */
+        /*  Remove constraint with most negative lambda from the */
+        /*  working set. */
+        gam_sq = u_opt[0];
+        p_free_size = 0;
+        if (u_opt[0] > u_opt[1]) {
+          gam_sq = u_opt[1];
+          p_free_size = 1;
+        }
+        if (gam_sq > u_opt[2]) {
+          gam_sq = u_opt[2];
+          p_free_size = 2;
+        }
+        if (gam_sq > u_opt[3]) {
+          p_free_size = 3;
+        }
+        W[p_free_size] = 0.0F;
+        i_free[p_free_size] = true;
+        iter++;
+      }
+    } else {
+      /*  --------------------------------------- */
+      /*   No, find primary bounding constraint. */
+      /*  --------------------------------------- */
+      /*  Compute distances to the different boundaries. Since alpha < 1 */
+      /*  is the maximum step length, initiate with ones. */
+      i = dist->size[0];
+      dist->size[0] = (int)m;
+      emxEnsureCapacity_real32_T(dist, i);
+      dist_data = dist->data;
+      for (i = 0; i < rankA; i++) {
+        dist_data[i] = 1.0F;
+      }
+      if (p->size[0] == 4) {
+        bv[0] = (i_free[0] && (p_data[0] < 0.0F));
+        bv[1] = (i_free[1] && (p_data[1] < 0.0F));
+        bv[2] = (i_free[2] && (p_data[2] < 0.0F));
+        bv[3] = (i_free[3] && (p_data[3] < 0.0F));
+      } else {
+        binary_expand_op_2(bv, i_free, p);
+      }
+      if (bv[0]) {
+        dist_data[0] = (umin[0] - u[0]) / p_data[0];
+      }
+      if (bv[1]) {
+        dist_data[1] = (umin[1] - u[1]) / p_data[1];
+      }
+      if (bv[2]) {
+        dist_data[2] = (umin[2] - u[2]) / p_data[2];
+      }
+      if (bv[3]) {
+        dist_data[3] = (umin[3] - u[3]) / p_data[3];
+      }
+      if (p->size[0] == 4) {
+        bv1[0] = (i_free[0] && (p_data[0] > 0.0F));
+        bv1[1] = (i_free[1] && (p_data[1] > 0.0F));
+        bv1[2] = (i_free[2] && (p_data[2] > 0.0F));
+        bv1[3] = (i_free[3] && (p_data[3] > 0.0F));
+      } else {
+        binary_expand_op_1(bv1, i_free, p);
+      }
+      if (bv1[0]) {
+        dist_data[0] = (umax[0] - u[0]) / p_data[0];
+      }
+      if (bv1[1]) {
+        dist_data[1] = (umax[1] - u[1]) / p_data[1];
+      }
+      if (bv1[2]) {
+        dist_data[2] = (umax[2] - u[2]) / p_data[2];
+      }
+      if (bv1[3]) {
+        dist_data[3] = (umax[3] - u[3]) / p_data[3];
+      }
+      /*  Proportion of p to travel */
+      if (dist->size[0] <= 2) {
+        if (dist->size[0] == 1) {
+          gam_sq = dist_data[0];
+          p_free_size = 0;
+        } else {
+          gam_sq = dist_data[dist->size[0] - 1];
+          if (dist_data[0] > gam_sq) {
+            p_free_size = dist->size[0] - 1;
+          } else {
+            gam_sq = dist_data[0];
+            p_free_size = 0;
+          }
+        }
+      } else {
+        gam_sq = dist_data[0];
+        p_free_size = 0;
+        for (k = 2; k <= rankA; k++) {
+          f = dist_data[k - 1];
+          if (gam_sq > f) {
+            gam_sq = f;
+            p_free_size = k - 1;
+          }
+        }
+      }
+      /*  Update point and residual. */
+      if (p->size[0] == 4) {
+        u[0] += gam_sq * p_data[0];
+        u[1] += gam_sq * p_data[1];
+        u[2] += gam_sq * p_data[2];
+        u[3] += gam_sq * p_data[3];
+      } else {
+        binary_expand_op(u, gam_sq, p);
+      }
+      for (i = 0; i < trueCount; i++) {
+        for (k = 0; k < 7; k++) {
+          A_data[k + 7 * i] = A[k + 7 * tmp_data[i]] * gam_sq;
+        }
+      }
+      for (b_i = 0; b_i < 7; b_i++) {
+        b_B[b_i] = 0.0F;
+      }
+      for (k = 0; k < trueCount; k++) {
+        aoffset = k * 7;
+        for (b_i = 0; b_i < 7; b_i++) {
+          b_B[b_i] += A_data[aoffset + b_i] * p_free_data[k];
+        }
+      }
+      for (i = 0; i < 7; i++) {
+        d[i] -= b_B[i];
+      }
+      /*  Add corresponding constraint to working set. */
+      if (p_data[p_free_size] < 0.0F) {
+        W[p_free_size] = -1.0F;
+      } else {
+        W[p_free_size] = (float)(p_data[p_free_size] > 0.0F);
+      }
+      i_free[p_free_size] = false;
+      iter++;
+    }
+  }
+  emxFree_real32_T(&dist);
+  emxFree_real32_T(&p);
+}
+
+/*
+ * Arguments    : void
+ * Return Type  : void
+ */
+void wls_alloc_gen_initialize(void)
+{
+}
+
+/*
+ * Arguments    : void
+ * Return Type  : void
+ */
+void wls_alloc_gen_terminate(void)
+{
+}
+
+/*
+ * File trailer for wls_alloc_gen.c
+ *
+ * [EOF]
+ */
diff --git a/src/lib/mixer_module/wls_alloc_gen.h b/src/lib/mixer_module/wls_alloc_gen.h
new file mode 100644
index 0000000000..d83653819c
--- /dev/null
+++ b/src/lib/mixer_module/wls_alloc_gen.h
@@ -0,0 +1,40 @@
+/*
+ * File: wls_alloc_gen.h
+ *
+ * MATLAB Coder version            : 24.1
+ * C/C++ source code generated on  : 2025-06-16 11:03:22
+ */
+
+#ifndef WLS_ALLOC_GEN_H
+#define WLS_ALLOC_GEN_H
+
+/* Include Files */
+#include "rtwtypes.h"
+#include <stddef.h>
+#include <stdlib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Function Declarations */
+extern void wls_alloc_gen(const float B[12], const float v[3],
+                          const float umin[4], const float umax[4],
+                          const float Wv[9], const float Wu[16],
+                          const float ud[4], float gam, float u[4], float W[4],
+                          float imax, float m);
+
+extern void wls_alloc_gen_initialize(void);
+
+extern void wls_alloc_gen_terminate(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/*
+ * File trailer for wls_alloc_gen.h
+ *
+ * [EOF]
+ */
diff --git a/src/lib/mixer_module/wls_alloc_gen_emxutil.c b/src/lib/mixer_module/wls_alloc_gen_emxutil.c
new file mode 100644
index 0000000000..81cf5426e0
--- /dev/null
+++ b/src/lib/mixer_module/wls_alloc_gen_emxutil.c
@@ -0,0 +1,94 @@
+/*
+ * File: wls_alloc_gen_emxutil.c
+ *
+ * MATLAB Coder version            : 24.1
+ * C/C++ source code generated on  : 2025-06-16 11:03:22
+ */
+
+/* Include Files */
+#include "wls_alloc_gen_emxutil.h"
+#include "wls_alloc_gen_types.h"
+#include <stdlib.h>
+#include <string.h>
+
+/* Function Definitions */
+/*
+ * Arguments    : emxArray_real32_T *emxArray
+ *                int oldNumel
+ * Return Type  : void
+ */
+void emxEnsureCapacity_real32_T(emxArray_real32_T *emxArray, int oldNumel)
+{
+  int i;
+  int newNumel;
+  void *newData;
+  if (oldNumel < 0) {
+    oldNumel = 0;
+  }
+  newNumel = 1;
+  for (i = 0; i < emxArray->numDimensions; i++) {
+    newNumel *= emxArray->size[i];
+  }
+  if (newNumel > emxArray->allocatedSize) {
+    i = emxArray->allocatedSize;
+    if (i < 16) {
+      i = 16;
+    }
+    while (i < newNumel) {
+      if (i > 1073741823) {
+        i = MAX_int32_T;
+      } else {
+        i *= 2;
+      }
+    }
+    newData = malloc((unsigned int)i * sizeof(float));
+    if (emxArray->data != NULL) {
+      memcpy(newData, emxArray->data, sizeof(float) * (unsigned int)oldNumel);
+      if (emxArray->canFreeData) {
+        free(emxArray->data);
+      }
+    }
+    emxArray->data = (float *)newData;
+    emxArray->allocatedSize = i;
+    emxArray->canFreeData = true;
+  }
+}
+
+/*
+ * Arguments    : emxArray_real32_T **pEmxArray
+ * Return Type  : void
+ */
+void emxFree_real32_T(emxArray_real32_T **pEmxArray)
+{
+  if (*pEmxArray != (emxArray_real32_T *)NULL) {
+    if (((*pEmxArray)->data != (float *)NULL) && (*pEmxArray)->canFreeData) {
+      free((*pEmxArray)->data);
+    }
+    free((*pEmxArray)->size);
+    free(*pEmxArray);
+    *pEmxArray = (emxArray_real32_T *)NULL;
+  }
+}
+
+/*
+ * Arguments    : emxArray_real32_T **pEmxArray
+ * Return Type  : void
+ */
+void emxInit_real32_T(emxArray_real32_T **pEmxArray)
+{
+  emxArray_real32_T *emxArray;
+  *pEmxArray = (emxArray_real32_T *)malloc(sizeof(emxArray_real32_T));
+  emxArray = *pEmxArray;
+  emxArray->data = (float *)NULL;
+  emxArray->numDimensions = 1;
+  emxArray->size = (int *)malloc(sizeof(int));
+  emxArray->allocatedSize = 0;
+  emxArray->canFreeData = true;
+  emxArray->size[0] = 0;
+}
+
+/*
+ * File trailer for wls_alloc_gen_emxutil.c
+ *
+ * [EOF]
+ */
diff --git a/src/lib/mixer_module/wls_alloc_gen_emxutil.h b/src/lib/mixer_module/wls_alloc_gen_emxutil.h
new file mode 100644
index 0000000000..e3dc85e7f7
--- /dev/null
+++ b/src/lib/mixer_module/wls_alloc_gen_emxutil.h
@@ -0,0 +1,38 @@
+/*
+ * File: wls_alloc_gen_emxutil.h
+ *
+ * MATLAB Coder version            : 24.1
+ * C/C++ source code generated on  : 2025-06-16 11:03:22
+ */
+
+#ifndef WLS_ALLOC_GEN_EMXUTIL_H
+#define WLS_ALLOC_GEN_EMXUTIL_H
+
+/* Include Files */
+#include "rtwtypes.h"
+#include "wls_alloc_gen_types.h"
+#include <stddef.h>
+#include <stdlib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Function Declarations */
+extern void emxEnsureCapacity_real32_T(emxArray_real32_T *emxArray,
+                                       int oldNumel);
+
+extern void emxFree_real32_T(emxArray_real32_T **pEmxArray);
+
+extern void emxInit_real32_T(emxArray_real32_T **pEmxArray);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/*
+ * File trailer for wls_alloc_gen_emxutil.h
+ *
+ * [EOF]
+ */
diff --git a/src/lib/mixer_module/wls_alloc_gen_types.h b/src/lib/mixer_module/wls_alloc_gen_types.h
new file mode 100644
index 0000000000..7a91643a84
--- /dev/null
+++ b/src/lib/mixer_module/wls_alloc_gen_types.h
@@ -0,0 +1,35 @@
+/*
+ * File: wls_alloc_gen_types.h
+ *
+ * MATLAB Coder version            : 24.1
+ * C/C++ source code generated on  : 2025-06-16 11:03:22
+ */
+
+#ifndef WLS_ALLOC_GEN_TYPES_H
+#define WLS_ALLOC_GEN_TYPES_H
+
+/* Include Files */
+#include "rtwtypes.h"
+
+/* Type Definitions */
+#ifndef struct_emxArray_real32_T
+#define struct_emxArray_real32_T
+struct emxArray_real32_T {
+  float *data;
+  int *size;
+  int allocatedSize;
+  int numDimensions;
+  bool canFreeData;
+};
+#endif /* struct_emxArray_real32_T */
+#ifndef typedef_emxArray_real32_T
+#define typedef_emxArray_real32_T
+typedef struct emxArray_real32_T emxArray_real32_T;
+#endif /* typedef_emxArray_real32_T */
+
+#endif
+/*
+ * File trailer for wls_alloc_gen_types.h
+ *
+ * [EOF]
+ */
diff --git a/src/lib/motion_planning/VelocitySmoothing.cpp b/src/lib/motion_planning/VelocitySmoothing.cpp
index 7dfd951e2e..840ada7352 100644
--- a/src/lib/motion_planning/VelocitySmoothing.cpp
+++ b/src/lib/motion_planning/VelocitySmoothing.cpp
@@ -73,6 +73,7 @@ float VelocitySmoothing::saturateT1ForAccel(float a0, float j_max, float T1, flo

 float VelocitySmoothing::computeT1(float a0, float v3, float j_max, float a_max)
 {
+	// assume that Constant acceleration time is zero firstly.
 	float delta = 2.f * a0 * a0 + 4.f * j_max * v3;

 	if (delta < 0.f) {
diff --git a/src/modules/control_allocator/ControlAllocation/ControlAllocationPseudoInverse.cpp b/src/modules/control_allocator/ControlAllocation/ControlAllocationPseudoInverse.cpp
index b613e77c73..bf26a028bd 100644
--- a/src/modules/control_allocator/ControlAllocation/ControlAllocationPseudoInverse.cpp
+++ b/src/modules/control_allocator/ControlAllocation/ControlAllocationPseudoInverse.cpp
@@ -54,7 +54,7 @@ void
 ControlAllocationPseudoInverse::updatePseudoInverse()
 {
 	if (_mix_update_needed) {
-		_mix = matrix::geninv(_effectiveness);
+		matrix::geninv(_effectiveness, _mix);
 		_mix_update_needed = false;
 	}
 }
diff --git a/src/modules/flight_mode_manager/CMakeLists.txt b/src/modules/flight_mode_manager/CMakeLists.txt
index 4b7cac1852..1f2cc5e319 100644
--- a/src/modules/flight_mode_manager/CMakeLists.txt
+++ b/src/modules/flight_mode_manager/CMakeLists.txt
@@ -62,6 +62,7 @@ list(APPEND flight_tasks_all
 	ManualPosition
 	ManualPositionSmoothVel
 	Transition
+	MyTask
 	${flight_tasks_to_add}
 )

diff --git a/src/modules/flight_mode_manager/FlightModeManager.cpp b/src/modules/flight_mode_manager/FlightModeManager.cpp
index 422844b552..9b1bf820f0 100644
--- a/src/modules/flight_mode_manager/FlightModeManager.cpp
+++ b/src/modules/flight_mode_manager/FlightModeManager.cpp
@@ -102,6 +102,7 @@ void FlightModeManager::Run()
 		const hrt_abstime time_stamp_now = hrt_absolute_time();
 		// Guard against too small (< 0.2ms) and too large (> 100ms) dt's.
 		const float dt = math::constrain(((time_stamp_now - _time_stamp_last_loop) / 1e6f), 0.0002f, 0.1f);
+		// PX4_INFO("Running, dt: %f", (double) dt);
 		_time_stamp_last_loop = time_stamp_now;

 		_home_position_sub.update();
@@ -136,6 +137,7 @@ void FlightModeManager::Run()
 		}

 		start_flight_task();
+		// PX4_INFO("start_flight_task !");

 		if (_vehicle_command_sub.updated()) {
 			handleCommand();
@@ -143,6 +145,7 @@ void FlightModeManager::Run()

 		if (isAnyTaskActive()) {
 			generateTrajectorySetpoint(dt, vehicle_local_position);
+			// PX4_INFO("isAnyTaskActive !");
 		}

 	}
@@ -221,7 +224,7 @@ void FlightModeManager::start_flight_task()
 		FlightTaskError error = FlightTaskError::NoError;

 		error = switchTask(FlightTaskIndex::AutoLineSmoothVel);
-
+		// PX4_INFO("AutoLineSmoothVel : %s", errorToString(error));
 		if (error != FlightTaskError::NoError) {
 			if (prev_failure_count == 0) {
 				PX4_WARN("Auto activation failed with error: %s", errorToString(error));
@@ -233,6 +236,8 @@ void FlightModeManager::start_flight_task()
 		} else {
 			// we want to be in this mode, reset the failure count
 			_task_failure_count = 0;
+			// PX4_INFO("after AutoLineSmoothVel succesful"); // report if activation was succesful
+
 		}

 	} else if (_vehicle_status_sub.get().nav_state == vehicle_status_s::NAVIGATION_STATE_DESCEND) {
@@ -267,7 +272,11 @@ void FlightModeManager::start_flight_task()
 		case 0:
 			error = switchTask(FlightTaskIndex::ManualPosition);
 			break;
+		case 1: // Add case for new task: MyTask
+     			error = switchTask(FlightTaskIndex::MyTask);
+			// PX4_INFO("MyTask : %s", errorToString(error));

+     			break;
 		case 3:
 			error = switchTask(FlightTaskIndex::ManualPositionSmoothVel);
 			break;
@@ -281,6 +290,9 @@ void FlightModeManager::start_flight_task()
 			}

 			error = switchTask(FlightTaskIndex::ManualAcceleration);
+			// PX4_INFO("ManualAcceleration : %s", errorToString(error));
+
+
 			break;
 		}

@@ -295,6 +307,7 @@ void FlightModeManager::start_flight_task()
 		} else {
 			check_failure(task_failure, vehicle_status_s::NAVIGATION_STATE_POSCTL);
 			task_failure = false;
+			// PX4_INFO("after switchTask to ManualAcceleration succesful"); // report if activation was succesful
 		}
 	}

@@ -407,7 +420,7 @@ void FlightModeManager::handleCommand()
 {
 	// get command
 	vehicle_command_s command;
-
+	// PX4_INFO("before while");
 	while (_vehicle_command_sub.update(&command)) {
 		// check what command it is
 		FlightTaskIndex desired_task = switchVehicleCommand(command.command);
@@ -416,6 +429,8 @@ void FlightModeManager::handleCommand()
 		if (desired_task != FlightTaskIndex::None) {
 			// switch to the commanded task
 			FlightTaskError switch_result = switchTask(desired_task);
+			// PX4_INFO("desired_task : %s", errorToString(switch_result));
+
 			uint8_t cmd_result = vehicle_command_ack_s::VEHICLE_RESULT_FAILED;

 			// if we are in/switched to the desired task
@@ -459,6 +474,8 @@ void FlightModeManager::generateTrajectorySetpoint(const float dt,
 	if (_current_task.task->updateInitialize() && _current_task.task->update() && _current_task.task->updateFinalize()) {
 		// setpoints and constraints for the position controller from flighttask
 		setpoint = _current_task.task->getPositionSetpoint();
+		// PX4_INFO("Running, active flight task: %" PRIu32, static_cast<uint32_t>(_current_task.index));
+		// PX4_INFO("x: %f, y: %f, z: %f, vx: %f, vy: %f, vz: %f, ax: %f, ay: %f, az: %f", (double) setpoint.x, (double) setpoint.y, (double) setpoint.z, (double) setpoint.vx, (double) setpoint.vy, (double) setpoint.vz, (double) setpoint.acceleration[0], (double) setpoint.acceleration[1], (double) setpoint.acceleration[2]);
 		constraints = _current_task.task->getConstraints();
 	}

diff --git a/src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp b/src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp
index c13035f363..078ac2d7fe 100644
--- a/src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp
+++ b/src/modules/flight_mode_manager/tasks/ManualAltitude/FlightTaskManualAltitude.cpp
@@ -349,6 +349,10 @@ void FlightTaskManualAltitude::_updateSetpoints()

 	_man_input_filter.setParameters(_deltatime, _param_mc_man_tilt_tau.get());
 	_man_input_filter.update(sp);
+	// for (size_t i = 0; i < 2; i++)
+	// {
+	// 	PX4_INFO("sp(%ld): %f", i, (double) sp(i));
+	// }
 	sp = _man_input_filter.getState();
 	_rotateIntoHeadingFrame(sp);

@@ -357,6 +361,7 @@ void FlightTaskManualAltitude::_updateSetpoints()
 	}

 	_acceleration_setpoint.xy() = sp * tanf(math::radians(_param_mpc_man_tilt_max.get())) * CONSTANTS_ONE_G;
+	// PX4_INFO("_acceleration_setpoint : %f", (double) (_acceleration_setpoint(0)));

 	_updateAltitudeLock();
 	_respectGroundSlowdown();
diff --git a/src/modules/flight_mode_manager/tasks/MyTask/CMakeLists.txt b/src/modules/flight_mode_manager/tasks/MyTask/CMakeLists.txt
new file mode 100644
index 0000000000..ba2c083216
--- /dev/null
+++ b/src/modules/flight_mode_manager/tasks/MyTask/CMakeLists.txt
@@ -0,0 +1,39 @@
+############################################################################
+#
+#   Copyright (c) 2022 PX4 Development Team. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name PX4 nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+px4_add_library(FlightTaskMyTask
+FlightTaskMyTask.cpp
+)
+
+target_link_libraries(FlightTaskMyTask PUBLIC FlightTask)
+target_include_directories(FlightTaskMyTask PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
diff --git a/src/modules/flight_mode_manager/tasks/MyTask/FlightTaskMyTask.cpp b/src/modules/flight_mode_manager/tasks/MyTask/FlightTaskMyTask.cpp
new file mode 100644
index 0000000000..9e1db2e2a0
--- /dev/null
+++ b/src/modules/flight_mode_manager/tasks/MyTask/FlightTaskMyTask.cpp
@@ -0,0 +1,20 @@
+#include "FlightTaskMyTask.hpp"
+
+bool FlightTaskMyTask::activate(vehicle_local_position_setpoint_s last_setpoint)
+{
+  PX4_INFO("before activate"); // report if activation was succesful
+
+  bool ret = FlightTask::activate(last_setpoint);
+  PX4_INFO("FlightTaskMyTask activate was firstly called! ret: %d", ret); // report if activation was succesful
+  return ret;
+}
+
+bool FlightTaskMyTask::update()
+{
+  _position_setpoint(0) = 0.f;
+	_position_setpoint(1) = 0.f;
+  _position_setpoint(2) = _position(2);
+  _yaw_setpoint=M_PI;
+  PX4_INFO("FlightTaskMyTask update was called! go to home!!!\n"); // report update
+  return true;
+}
diff --git a/src/modules/flight_mode_manager/tasks/MyTask/FlightTaskMyTask.hpp b/src/modules/flight_mode_manager/tasks/MyTask/FlightTaskMyTask.hpp
new file mode 100644
index 0000000000..a447f18ed0
--- /dev/null
+++ b/src/modules/flight_mode_manager/tasks/MyTask/FlightTaskMyTask.hpp
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "FlightTask.hpp"
+
+class FlightTaskMyTask : public FlightTask
+{
+public:
+  FlightTaskMyTask() = default;
+  virtual ~FlightTaskMyTask() = default;
+
+  bool update();
+  bool activate(vehicle_local_position_setpoint_s last_setpoint);
+
+private:
+//   float _origin_z{0.f};
+};
diff --git a/src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp b/src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp
index 1993231fa5..46d09f9c44 100644
--- a/src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp
+++ b/src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.cpp
@@ -75,7 +75,6 @@ bool FlightTaskOrbit::applyCommandParameters(const vehicle_command_s &command)

 	// save current yaw estimate for ORBIT_YAW_BEHAVIOUR_HOLD_INITIAL_HEADING
 	_initial_heading = _yaw;
-
 	// commanded center coordinates
 	if (PX4_ISFINITE(command.param5) && PX4_ISFINITE(command.param6)) {
 		if (map_projection_initialized(&_global_local_proj_ref)) {
@@ -87,6 +86,10 @@ bool FlightTaskOrbit::applyCommandParameters(const vehicle_command_s &command)
 			ret = false;
 		}
 	}
+	// PX4_INFO("after applyCommandParameters, _center: %f", (double) _center(0));
+	const Vector2f center_to_init_position = Vector2f(_position) - _center;
+	_length = center_to_init_position.norm();
+

 	// commanded altitude
 	if (PX4_ISFINITE(command.param7)) {
@@ -167,9 +170,13 @@ bool FlightTaskOrbit::activate(const vehicle_local_position_setpoint_s &last_set
 	_r = _radius_min;
 	_v =  1.f;
 	_center = _position.xy();
+	_init_pos = _position.xy();
+
 	_initial_heading = _yaw;
 	_slew_rate_yaw.setForcedValue(_yaw);
 	_slew_rate_yaw.setSlewRate(math::radians(_param_mpc_yawrauto_max.get()));
+	_time_stamp_last_loop = hrt_absolute_time();
+	_iter = 0.f;

 	// need a valid position and velocity
 	ret = ret && PX4_ISFINITE(_position(0))
@@ -184,6 +191,12 @@ bool FlightTaskOrbit::activate(const vehicle_local_position_setpoint_s &last_set

 bool FlightTaskOrbit::update()
 {
+	const hrt_abstime time_stamp_now = hrt_absolute_time();
+	// Guard against too small (< 0.2ms) and too large (> 100ms) dt's.
+	const float dt = math::constrain(((time_stamp_now - _time_stamp_last_loop) / 1e6f), 0.0002f, 0.1f);
+	// PX4_INFO("FlightTaskOrbit Running, dt: %f", (double) dt);
+	_time_stamp_last_loop = time_stamp_now;
+
 	// update altitude
 	bool ret = FlightTaskManualAltitudeSmoothVel::update();

@@ -194,15 +207,17 @@ bool FlightTaskOrbit::update()
 	setRadius(r);
 	setVelocity(v);

-	const Vector2f center_to_position = Vector2f(_position) - _center;
+	// const Vector2f center_to_position = Vector2f(_position) - _center;
+	const Vector2f init_to_position = Vector2f(_position) - _init_pos;

-	if (_in_circle_approach) {
-		generate_circle_approach_setpoints(center_to_position);
+	// if (_in_circle_approach) {
+		// generate_circle_approach_setpoints(center_to_position);

-	} else {
-		generate_circle_setpoints(center_to_position);
-		generate_circle_yaw_setpoints(center_to_position);
-	}
+	// } else {
+		// generate_circle_setpoints(center_to_position);
+		generate_lissajous_setpoints(init_to_position, dt);
+		// generate_circle_yaw_setpoints(center_to_position);
+	// }

 	// Apply yaw smoothing
 	_yaw_setpoint = _slew_rate_yaw.update(_yaw_setpoint, _deltatime);
@@ -215,7 +230,7 @@ bool FlightTaskOrbit::update()

 void FlightTaskOrbit::generate_circle_approach_setpoints(const Vector2f &center_to_position)
 {
-	const Vector2f start_to_circle = (_r - center_to_position.norm()) * center_to_position.unit_or_zero();
+	const Vector2f start_to_circle = ( - center_to_position.norm()) * center_to_position.unit_or_zero();

 	if (_circle_approach_line.isEndReached()) {
 		// calculate target point on circle and plan a line trajectory
@@ -231,6 +246,50 @@ void FlightTaskOrbit::generate_circle_approach_setpoints(const Vector2f &center_
 	_circle_approach_line.generateSetpoints(_position_setpoint, _velocity_setpoint);
 	_in_circle_approach = !_circle_approach_line.isEndReached();
 }
+void FlightTaskOrbit::generate_lissajous_setpoints(const Vector2f &init_to_position, const float dt)
+{
+	// Lissajous
+	float T=20;
+	// float T=_length*6.f/_v;
+	_iter++;
+
+	if( ((float) _iter) > 2147483647)
+	{
+		_iter = 0;
+	}
+	float t= ((float) _iter) *dt;
+	// PX4_INFO("FlightTaskOrbit Running, t: %f", (double) t);
+	// PX4_INFO("FlightTaskOrbit Running, _iter: %d", _iter);
+
+
+
+
+	// x = r*sin((2*pi/T)*t);
+	// y = r*sin(2*(2*pi/T)*t);
+	_position_setpoint(0) = _length*sin(2*3.14f*t/T);
+	_position_setpoint(1) = _length*sin(2* 2*3.14f*t/T);
+	// _position_setpoint(0) = _position_setpoint(1) = NAN;
+
+	// velocity
+	Vector2f velocity_ref_xy( (_length*(2*3.14f/T))*cos(2*3.14f*t/T),  (_length*(2* 2*3.14f/T))*cos(2* 2*3.14f*t/T) );
+	// velocity_ref_xy = velocity_ref_xy.unit_or_zero();
+	// velocity_ref_xy *= _v;
+	_velocity_setpoint.xy() = velocity_ref_xy;
+	// _velocity_setpoint(0) = NAN;
+	// _velocity_setpoint(1) = NAN;
+
+	// acc
+	Vector2f acc_ref_xy( -(_length*(2*3.14f/T)*(2*3.14f/T)) * sin(2*3.14f*t/T),  -(_length*(2* 2*3.14f/T))*(2* 2*3.14f/T) * sin(2* 2*3.14f*t/T) );
+	_acceleration_setpoint.xy() = acc_ref_xy;
+	// _acceleration_setpoint(0) = NAN;
+	// _acceleration_setpoint(0) = NAN;
+
+	//yaw
+	// _yaw_setpoint = _initial_heading;
+	// _yawspeed_setpoint = NAN;
+	_yaw_setpoint = atan2f((_length*(2* 2*3.14f/T))*cos(2* 2*3.14f*t/T), (_length*(2*3.14f/T))*cos(2*3.14f*t/T));
+	_yawspeed_setpoint = NAN;
+}

 void FlightTaskOrbit::generate_circle_setpoints(const Vector2f &center_to_position)
 {
@@ -249,7 +308,7 @@ void FlightTaskOrbit::generate_circle_setpoints(const Vector2f &center_to_positi

 void FlightTaskOrbit::generate_circle_yaw_setpoints(const Vector2f &center_to_position)
 {
-	switch (_yaw_behaviour) {
+	switch (3U) {
 	case orbit_status_s::ORBIT_YAW_BEHAVIOUR_HOLD_INITIAL_HEADING:
 		// make vehicle keep the same heading as when the orbit was commanded
 		_yaw_setpoint = _initial_heading;
diff --git a/src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.hpp b/src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.hpp
index ef268801bd..9544b9ce94 100644
--- a/src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.hpp
+++ b/src/modules/flight_mode_manager/tasks/Orbit/FlightTaskOrbit.hpp
@@ -89,6 +89,8 @@ protected:
 	bool setVelocity(const float v);

 private:
+	void generate_lissajous_setpoints(const matrix::Vector2f &center_to_position, const float dt);
+
 	/** generates setpoints to smoothly reach the closest point on the circle when starting from far away */
 	void generate_circle_approach_setpoints(const matrix::Vector2f &center_to_position);
 	/** generates xy setpoints to make the vehicle orbit */
@@ -96,21 +98,25 @@ private:
 	/** generates yaw setpoints to control the vehicle's heading */
 	void generate_circle_yaw_setpoints(const matrix::Vector2f &center_to_position);

+	hrt_abstime _time_stamp_last_loop{0}; ///< time stamp of last loop iteration
+	int _iter;
+	float _length = 1.f;
 	float _r = 0.f; /**< radius with which to orbit the target */
 	float _v = 0.f; /**< clockwise tangential velocity for orbiting in m/s */
 	matrix::Vector2f _center; /**< local frame coordinates of the center point */
+	matrix::Vector2f _init_pos;

 	bool _in_circle_approach = false;
 	StraightLine _circle_approach_line;

 	// TODO: create/use parameters for limits
 	const float _radius_min = 1.f;
-	const float _radius_max = 100.f;
-	const float _velocity_max = 10.f;
-	const float _acceleration_max = 2.f;
+	const float _radius_max = 10000.f;
+	const float _velocity_max = 1000.f;
+	const float _acceleration_max = 2000.f;

 	/** yaw behaviour during the orbit flight according to MAVLink's ORBIT_YAW_BEHAVIOUR enum */
-	int _yaw_behaviour = orbit_status_s::ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TO_CIRCLE_CENTER;
+	int _yaw_behaviour = orbit_status_s::ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TANGENT_TO_CIRCLE;
 	float _initial_heading = 0.f; /**< the heading of the drone when the orbit command was issued */
 	SlewRateYaw<float> _slew_rate_yaw;

diff --git a/src/modules/logger/logged_topics.cpp b/src/modules/logger/logged_topics.cpp
index b668559a8e..007dad1e88 100644
--- a/src/modules/logger/logged_topics.cpp
+++ b/src/modules/logger/logged_topics.cpp
@@ -47,16 +47,16 @@ void LoggedTopics::add_default_topics()
 {
 	add_topic("actuator_armed");
 	add_topic("actuator_controls_0", 50);
-	add_topic("actuator_controls_1", 100);
-	add_topic("actuator_controls_2", 100);
-	add_topic("actuator_controls_3", 100);
-	add_topic("actuator_controls_4", 100);
-	add_topic("actuator_controls_5", 100);
-	add_topic("airspeed", 1000);
-	add_topic("airspeed_validated", 200);
-	add_topic("camera_capture");
-	add_topic("camera_trigger");
-	add_topic("camera_trigger_secondary");
+	// add_topic("actuator_controls_1", 100);
+	// add_topic("actuator_controls_2", 100);
+	// add_topic("actuator_controls_3", 100);
+	// add_topic("actuator_controls_4", 100);
+	// add_topic("actuator_controls_5", 100);
+	// add_topic("airspeed", 1000);
+	// add_topic("airspeed_validated", 200);
+	// add_topic("camera_capture");
+	// add_topic("camera_trigger");
+	// add_topic("camera_trigger_secondary");
 	add_topic("cellular_status", 200);
 	add_topic("commander_state");
 	add_topic("cpuload");
@@ -117,11 +117,11 @@ void LoggedTopics::add_default_topics()
 	add_topic("wind", 1000);

 	// Control allocation topics
-	add_topic("vehicle_actuator_setpoint", 20);
-	add_topic("vehicle_angular_acceleration", 20);
-	add_topic("vehicle_angular_acceleration_setpoint", 20);
-	add_topic("vehicle_thrust_setpoint", 20);
-	add_topic("vehicle_torque_setpoint", 20);
+	// add_topic("vehicle_actuator_setpoint", 20);
+	// add_topic("vehicle_angular_acceleration", 20);
+	// add_topic("vehicle_angular_acceleration_setpoint", 20);
+	// add_topic("vehicle_thrust_setpoint", 20);
+	// add_topic("vehicle_torque_setpoint", 20);

 	// multi topics
 	add_topic_multi("actuator_outputs", 100, 3);
@@ -194,8 +194,11 @@ void LoggedTopics::add_default_topics()
 void LoggedTopics::add_high_rate_topics()
 {
 	// maximum rate to analyze fast maneuvers (e.g. for racing)
+	add_topic("input_rc");
 	add_topic("actuator_controls_0");
 	add_topic("actuator_outputs");
+	add_topic("actuator_outputs_value");
+	add_topic("allocation_value");
 	add_topic("manual_control_setpoint");
 	add_topic("rate_ctrl_status", 20);
 	add_topic("sensor_combined");
diff --git a/src/modules/mc_att_control/AttitudeControl/AttitudeControl.cpp b/src/modules/mc_att_control/AttitudeControl/AttitudeControl.cpp
index 859b86316f..3df27a9401 100644
--- a/src/modules/mc_att_control/AttitudeControl/AttitudeControl.cpp
+++ b/src/modules/mc_att_control/AttitudeControl/AttitudeControl.cpp
@@ -74,21 +74,62 @@ matrix::Vector3f AttitudeControl::update(const Quatf &q) const

 	// mix full and reduced desired attitude
 	Quatf q_mix = qd_red.inversed() * qd;
+	// float temp=acosf(q_mix(0))-asinf(q_mix(3));
+	// PX4_INFO("===================");
+	// PX4_INFO("acosf:%8.6f\n", (double) acosf(q_mix(0)));
+	// PX4_INFO("asinf:%8.6f\n", (double) asinf(q_mix(3)));
+	// PX4_INFO("===================");
+	// PX4_INFO("temp:%8.6f\n", (double) temp);
+	// PX4_INFO("===================");
+	Dcmf R_sp{qd};
+	Dcmf R{q};
+	// const Eulerf euler{R_sp};
+	// PX4_INFO("psi:%8.6f\n", (double) euler.psi());
+	// PX4_INFO("===================");
 	q_mix.canonicalize();
+
 	// catch numerical problems with the domain of acosf and asinf
 	q_mix(0) = math::constrain(q_mix(0), -1.f, 1.f);
 	q_mix(3) = math::constrain(q_mix(3), -1.f, 1.f);
-	qd = qd_red * Quatf(cosf(_yaw_w * acosf(q_mix(0))), 0, 0, sinf(_yaw_w * asinf(q_mix(3))));
+	// qd = qd_red * Quatf(cosf(_yaw_w * acosf(q_mix(0))), 0, 0, sinf(_yaw_w * asinf(q_mix(3))));
+

 	// quaternion attitude control law, qe is rotation from q to qd
-	const Quatf qe = q.inversed() * qd;
+	// const Quatf qe = q.inversed() * qd;
+	// AxisAngle<float> rot{qe};
+	// Vector<float, 3> rot_e = rot.axis() * sin(rot.angle());
+	// Vector<float, 3> rot_e_h = 2.0f*rot.axis() * sin(rot.angle()/2.0f); // close to rot_e

+	Dcmf R_e = (R.transpose()*R_sp - R_sp.transpose()*R);
+	Vector<float, 3> e_R =R_e.vee()/2; //e_R = rot_e
 	// using sin(alpha/2) scaled rotation axis as attitude error (see quaternion definition by axis angle)
 	// also taking care of the antipodal unit quaternion ambiguity
-	const Vector3f eq = 2.f * qe.canonical().imag();
-
+	// const Vector3f eq = 2.f * qe.canonical().imag(); // eq =  sign(q(0))*rot_e_h =  sign(q(0)) * 2.0f*rot.axis() * sin(rot.angle()/2.0f)
+	// const Vector3f eq = 2.f * qe.imag()*qe(0); //eq=rot_e= q(0)*rot_e_h
+
+
+	// PX4_INFO("===================");
+	// PX4_INFO("qe1:%8.6f\t qe2:%8.6f\t qe3:%8.6f\t", (double) qe(1), (double) qe(2), (double) qe(3));
+	// PX4_INFO("===================");
+	// PX4_INFO("rot_e_h0:%8.6f\t rot_e_h1:%8.6f\t rot_e_h2:%8.6f\t", (double) rot_e_h(0), (double) rot_e_h(1), (double) rot_e_h(2));
+	// PX4_INFO("===================");
+	// PX4_INFO("rot_e0:%8.6f\t rot_e1:%8.6f\t rot_e2:%8.6f\t", (double) rot_e(0), (double) rot_e(1), (double) rot_e(2));
+	// PX4_INFO("===================");
+	// PX4_INFO("e0:%8.6f\t e1:%8.6f\t e2:%8.6f\t", (double) (rot_e(0)-rot_e_h(0)), (double) (rot_e(1)-rot_e_h(1)), (double) (rot_e(2)-rot_e_h(2)));
+	// PX4_INFO("===================");
+	// PX4_INFO("rot0:%8.6f\t rot1:%8.6f\t rot2:%8.6f\t", (double) rot(0), (double) rot(1), (double) rot(2));
+	// PX4_INFO("===================");
+	// PX4_INFO("e0:%8.6f\t e1:%8.6f\t e2:%8.6f\t", (double) (rot(0)-rot_e(0)), (double) (rot(1)-rot_e(1)), (double) (rot(2)-rot_e(2)));
+	// PX4_INFO("===================");
+	// PX4_INFO("e_R0:%8.6f\t e_R1:%8.6f\t e_R2:%8.6f\t", (double) e_R(0), (double) e_R(1), (double) e_R(2));
+	// PX4_INFO("===================");
+	// PX4_INFO("e0:%8.6f\t e1:%8.6f\t e2:%8.6f\t", (double) (e_R(0)-rot_e(0)), (double) (e_R(1)-rot_e(1)), (double) (e_R(2)-rot_e(2)));
+	// PX4_INFO("===================");
+	// PX4_INFO("eq0:%8.6f\t eq1:%8.6f\t eq2:%8.6f\t", (double) eq(0), (double) eq(1), (double) eq(2));
+	// PX4_INFO("===================");
+	// PX4_INFO("e0:%8.6f\t e1:%8.6f\t e2:%8.6f\t", (double) (eq(0)-rot_e_h(0)), (double) (eq(1)-rot_e_h(1)), (double) (eq(2)-rot_e_h(2)));
 	// calculate angular rates setpoint
-	matrix::Vector3f rate_setpoint = eq.emult(_proportional_gain);
+	matrix::Vector3f rate_setpoint = e_R.emult(_proportional_gain);

 	// Feed forward the yaw setpoint rate.
 	// yawspeed_setpoint is the feed forward commanded rotation around the world z-axis,
diff --git a/src/modules/mc_att_control/mc_att_control_main.cpp b/src/modules/mc_att_control/mc_att_control_main.cpp
index 3acf95dfc8..45bb36817c 100644
--- a/src/modules/mc_att_control/mc_att_control_main.cpp
+++ b/src/modules/mc_att_control/mc_att_control_main.cpp
@@ -215,6 +215,7 @@ MulticopterAttitudeControl::generate_attitude_setpoint(const Quatf &q, float dt,
 	attitude_setpoint.timestamp = hrt_absolute_time();

 	_vehicle_attitude_setpoint_pub.publish(attitude_setpoint);
+	// PX4_INFO("==============generate_attitude_setpoint _vehicle_attitude_setpoint_pub publish================= \n");
 }

 void
@@ -249,6 +250,7 @@ MulticopterAttitudeControl::Run()
 			_vehicle_attitude_setpoint_sub.update(&vehicle_attitude_setpoint);
 			_attitude_control.setAttitudeSetpoint(Quatf(vehicle_attitude_setpoint.q_d), vehicle_attitude_setpoint.yaw_sp_move_rate);
 			_thrust_setpoint_body = Vector3f(vehicle_attitude_setpoint.thrust_body);
+			// PX4_INFO("==============Check for new attitude setpoint================= \n");
 		}

 		// Check for a heading reset
@@ -314,6 +316,8 @@ MulticopterAttitudeControl::Run()
 				_man_y_input_filter.reset(0.f);
 			}

+
+
 			Vector3f rates_sp = _attitude_control.update(q);

 			// publish rate setpoint
diff --git a/src/modules/mc_att_control/mc_att_control_params.c b/src/modules/mc_att_control/mc_att_control_params.c
index f45e856942..9339f0e7b3 100644
--- a/src/modules/mc_att_control/mc_att_control_params.c
+++ b/src/modules/mc_att_control/mc_att_control_params.c
@@ -158,3 +158,81 @@ PARAM_DEFINE_FLOAT(MC_YAWRATE_MAX, 200.0f);
  * @group Multicopter Position Control
  */
 PARAM_DEFINE_FLOAT(MC_MAN_TILT_TAU, 0.0f);
+
+/**
+ * USER_ADD_REF
+ *
+ * add step ref.
+ *
+ * @value 0 without
+ * @value 1 add step ref
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_INT32(USER_ADD_REF, 0);
+
+/**
+ * roll step amp
+ *
+ * rad
+ *
+ * @unit rad
+ * @min 0.0
+ * @max 0.35
+ * @decimal 2
+ * @increment 0.05
+ * @group Multicopter Attitude Control
+ */
+PARAM_DEFINE_FLOAT(USER_STEP_R_AMP, 0.0f);
+
+/**
+ * pitch step amp
+ *
+ * rad
+ *
+ * @unit rad
+ * @min 0.0
+ * @max 0.35
+ * @decimal 2
+ * @increment 0.05
+ * @group Multicopter Attitude Control
+ */
+PARAM_DEFINE_FLOAT(USER_STEP_P_AMP, 0.0f);
+
+// /**
+//  * yaw step amp
+//  *
+//  * rad.
+//  *
+//  * @unit rad
+//  * @min 0.0
+//  * @max 0.35
+//  * @decimal 2
+//  * @increment 0.05
+//  * @group Multicopter Attitude Control
+//  */
+// PARAM_DEFINE_FLOAT(MC_YAW_AMP, 0.0f);
+
+/**
+ * Period of step wave
+ *
+ * The period of the step wave, in seconds.
+ *
+ * @min 0.0
+ * @max 30
+ * @unit s
+ * @decimal 2
+ * @increment 0.01
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_FLOAT(USER_STEP_TIME, 0.f);
+
+/**
+ * USER_TEST_NUM
+ *
+ * number of the step test.
+ *
+ * @min 0
+ * @max 125
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_INT32(USER_TEST_NUM, 1);
diff --git a/src/modules/mc_pos_control/MulticopterPositionControl.cpp b/src/modules/mc_pos_control/MulticopterPositionControl.cpp
index 674d44b48b..ed174bcd62 100644
--- a/src/modules/mc_pos_control/MulticopterPositionControl.cpp
+++ b/src/modules/mc_pos_control/MulticopterPositionControl.cpp
@@ -134,6 +134,9 @@ int MulticopterPositionControl::parameters_update(bool force)
 		if (num_changed > 0) {
 			param_notify_changes();
 		}
+		_cycle_time = _param_step_ref_time.get();
+		// _step_roll_amp = _param_step_roll_amp.get();
+		// _step_pitch_amp = _param_step_pitch_amp.get();

 		if (_param_mpc_tiltmax_air.get() > MAX_SAFE_TILT_DEG) {
 			_param_mpc_tiltmax_air.set(MAX_SAFE_TILT_DEG);
@@ -262,6 +265,28 @@ void MulticopterPositionControl::Run()
 	perf_begin(_cycle_perf);
 	vehicle_local_position_s local_pos;

+	// rc detection
+	// 上是-1
+	// channels[6]:  -1	0	1	= yaw step  // 7通道右上角
+	// 9-12通道在正面
+	// channels[8]:  -1	0       1	=servo disturb
+	// channels[9]:  -1	0       1	=
+	// channels[10]: -1	0       1	=
+	// channels[11]: -1	0       1	=pid or indi
+	if (_rc_channels_sub.update(&_rc_channels))
+	{
+		if (_rc_channels.channels[6] < 0.f)
+		{
+			_rc_step_flag = false;
+			// PX4_INFO("no step !");
+		}
+		else
+		{
+			_rc_step_flag = true;
+			// PX4_INFO("step !");
+		}
+	}
+
 	if (_local_pos_sub.update(&local_pos)) {
 		const hrt_abstime time_stamp_now = local_pos.timestamp;
 		const float dt = math::constrain(((time_stamp_now - _time_stamp_last_loop) * 1e-6f), 0.002f, 0.04f);
@@ -419,6 +444,7 @@ void MulticopterPositionControl::Run()

 			// Run position control
 			if (_control.update(dt)) {
+				// PX4_INFO("position control");
 				_failsafe_land_hysteresis.set_state_and_update(false, time_stamp_now);

 			} else {
@@ -452,7 +478,152 @@ void MulticopterPositionControl::Run()
 			vehicle_attitude_setpoint_s attitude_setpoint{};
 			_control.getAttitudeSetpoint(attitude_setpoint);
 			attitude_setpoint.timestamp = hrt_absolute_time();
+
+			// for sitl  yaw step
+			// 自动触发逻辑控制入口
+			// 两个标志位共同使能，要使遥控器控制，参数必须使用默认值。
+			if (_param_user_add_ref.get() == 1 || _rc_step_flag) {
+
+				// === 当前是否要启动 step 测试 ===
+				if (!_step_active && !_step_waiting_for_next && _step_repeat_counter < _param_test_time.get()) {
+					_use_step_ref = true;
+					_step_active = true;
+					PX4_INFO("STEP #%d STARTED", _step_repeat_counter + 1);
+				}
+
+				// === step 测试执行逻辑 ===
+				if (_use_step_ref) {
+
+					if (!_use_step_ref_prev) {
+						_add_step_time = hrt_absolute_time();
+						start_yaw_body = attitude_setpoint.yaw_body;
+
+						// 记录当前模式
+						vehicle_status_s status;
+						if (_vehicle_status_sub.copy(&status)) {
+							_original_main_mode = status.nav_state;
+							_mode_recorded = true;
+							_mode_restored = false;
+							PX4_INFO("Record mode.");
+
+							// 切换到 ALTCTL
+							vehicle_command_s cmd{};
+							cmd.timestamp = hrt_absolute_time();
+							cmd.param1 = 1.0f;
+							cmd.param2 = PX4_CUSTOM_MAIN_MODE_POSCTL; // PX4_CUSTOM_MAIN_MODE_POSCTL or PX4_CUSTOM_MAIN_MODE_ALTCTL
+							cmd.param3 = 0.0f;
+							cmd.command = vehicle_command_s::VEHICLE_CMD_DO_SET_MODE;
+							cmd.target_system = 1;
+							cmd.target_component = 1;
+							cmd.source_system = 1;
+							cmd.source_component = 1;
+							cmd.from_external = false;
+							cmd.test_flag=1;
+							_vehicle_command_pub.publish(cmd);
+							PX4_INFO("Switched to POSCTL mode."); // POSCTL or ALTCTL
+						}
+					}
+
+					// 计算扰动时间
+					hrt_abstime interval = hrt_elapsed_time(&_add_step_time);
+					float time_sec = interval / 1e6f;
+
+					if (time_sec < 1.f * _cycle_time) {
+						attitude_setpoint.yaw_body = start_yaw_body;
+					} else if (time_sec < 2.f * _cycle_time) {
+						attitude_setpoint.yaw_body = start_yaw_body + M_PI_F / 4.0f;
+					} else if (time_sec < 3.0f * _cycle_time) {
+						attitude_setpoint.yaw_body = start_yaw_body - M_PI_F / 4.0f;
+					} else if (time_sec < 4.0f * _cycle_time) {
+						attitude_setpoint.yaw_body = start_yaw_body;
+					}
+
+					Quatf q_sp = Eulerf(attitude_setpoint.roll_body,
+							attitude_setpoint.pitch_body,
+							attitude_setpoint.yaw_body);
+					q_sp.copyTo(attitude_setpoint.q_d);
+
+					// step 结束，恢复模式并进入等待状态
+					if (time_sec >= 5.0f * _cycle_time && !_mode_restored) {
+						vehicle_command_s cmd{};
+						cmd.timestamp = hrt_absolute_time();
+						cmd.param1 = 1.0f;
+
+						switch (_original_main_mode) {
+							// case vehicle_status_s::NAVIGATION_STATE_POSCTL:
+							// 	cmd.param2 = PX4_CUSTOM_MAIN_MODE_POSCTL;
+							// 	break;
+							// case vehicle_status_s::NAVIGATION_STATE_AUTO_LOITER:
+							// 	cmd.param2 = PX4_CUSTOM_MAIN_MODE_AUTO;
+							// 	cmd.param3 = PX4_CUSTOM_SUB_MODE_AUTO_LOITER;
+							// 	break;
+							// case vehicle_status_s::NAVIGATION_STATE_OFFBOARD:
+							// 	cmd.param2 = PX4_CUSTOM_MAIN_MODE_OFFBOARD;
+							// 	break;
+							default:
+								cmd.param2 = PX4_CUSTOM_MAIN_MODE_POSCTL;
+								break;
+						}
+
+						cmd.command = vehicle_command_s::VEHICLE_CMD_DO_SET_MODE;
+						cmd.target_system = 1;
+						cmd.target_component = 1;
+						cmd.source_system = 1;
+						cmd.source_component = 1;
+						cmd.from_external = false;
+						cmd.test_flag=2;
+						_vehicle_command_pub.publish(cmd);
+						_mode_restored = true;
+
+						// 结束step，进入等待阶段
+						_use_step_ref = false;
+						_step_active = false;
+						_step_waiting_for_next = true;
+						_last_step_end_time = hrt_absolute_time();
+						_step_repeat_counter++;
+						PX4_INFO("STEP #%d DONE", _step_repeat_counter);
+					}
+				}
+
+				// === 执行等待状态逻辑 ===
+				if (_step_waiting_for_next) {
+					float wait_elapsed = hrt_elapsed_time(&_last_step_end_time) / 1e6f;
+					if (wait_elapsed >= 2.0f * _cycle_time) {
+						_step_waiting_for_next = false;  // 准备进入下一轮
+					}
+				}
+			}
+			// 如果中断
+			else {
+				if (_step_active || _step_waiting_for_next || _use_step_ref || _step_repeat_counter > 0) {
+					PX4_INFO("STEP test interrupted: param disabled or aborted at cycle #%d", _step_repeat_counter);
+					// === 中断后强制切换回 POSCTL 模式 ===
+					vehicle_command_s cmd{};
+					cmd.timestamp = hrt_absolute_time();
+					cmd.param1 = 1.0f;
+					cmd.param2 = PX4_CUSTOM_MAIN_MODE_POSCTL;
+					cmd.command = vehicle_command_s::VEHICLE_CMD_DO_SET_MODE;
+					cmd.target_system = 1;
+					cmd.target_component = 1;
+					cmd.source_system = 1;
+					cmd.source_component = 1;
+					cmd.from_external = false;
+					cmd.test_flag=0;
+					_vehicle_command_pub.publish(cmd);
+					PX4_INFO("STEP test interrupted: switched back to POSCTL mode.");
+				}
+				// 参数关闭或结束：重置
+				_use_step_ref = false;
+				_step_active = false;
+				_step_waiting_for_next = false;
+				_mode_recorded = false;
+				_mode_restored = false;
+				_step_repeat_counter = 0;
+			}
+			_use_step_ref_prev = _use_step_ref;
+
 			_vehicle_attitude_setpoint_pub.publish(attitude_setpoint);
+			// PX4_INFO("position _vehicle_attitude_setpoint_pub");

 		} else {
 			// an update is necessary here because otherwise the takeoff state doesn't get skiped with non-altitude-controlled modes
diff --git a/src/modules/mc_pos_control/MulticopterPositionControl.hpp b/src/modules/mc_pos_control/MulticopterPositionControl.hpp
index 1e6b591a42..dc96c49bc0 100644
--- a/src/modules/mc_pos_control/MulticopterPositionControl.hpp
+++ b/src/modules/mc_pos_control/MulticopterPositionControl.hpp
@@ -64,7 +64,10 @@
 #include <uORB/topics/vehicle_land_detected.h>
 #include <uORB/topics/vehicle_local_position.h>
 #include <uORB/topics/vehicle_local_position_setpoint.h>
-
+#include <uORB/topics/rc_channels.h>
+#include <uORB/topics/vehicle_command.h>
+#include <uORB/topics/vehicle_status.h>
+#include <commander/px4_custom_mode.h>
 using namespace time_literals;

 class MulticopterPositionControl : public ModuleBase<MulticopterPositionControl>, public control::SuperBlock,
@@ -128,6 +131,30 @@ private:
 		.maybe_landed = true,
 		.landed = true,
 	};
+	bool _use_step_ref{false};
+	bool _use_step_ref_prev{false};
+	hrt_abstime _add_step_time;
+	float start_yaw_body{0.0f};
+	float _cycle_time;
+	float _step_roll_amp;
+	float _step_pitch_amp;
+
+	uORB::Subscription _rc_channels_sub{ORB_ID(rc_channels)};
+	rc_channels_s		_rc_channels{};
+	bool _rc_step_flag{false};
+
+
+	// --- 用于飞行模式切换记录与控制 ---
+	uORB::Publication<vehicle_command_s> _vehicle_command_pub{ORB_ID(vehicle_command)};
+	uORB::Subscription _vehicle_status_sub{ORB_ID(vehicle_status)};
+	uint8_t _original_main_mode{0};
+	bool _mode_recorded{false};
+	bool _mode_restored{false};
+
+	int _step_repeat_counter{0};
+	bool _step_active{false};               // 当前是否正在step中
+	bool _step_waiting_for_next{false};     // 是否处于等待期
+	hrt_abstime _last_step_end_time{0};     // 上一轮结束时的时间

 	DEFINE_PARAMETERS(
 		// Position Control
@@ -172,7 +199,12 @@ private:
 		(ParamFloat<px4::params::MPC_MAN_Y_TAU>) _param_mpc_man_y_tau,

 		(ParamFloat<px4::params::MPC_XY_VEL_ALL>) _param_mpc_xy_vel_all,
-		(ParamFloat<px4::params::MPC_Z_VEL_ALL>) _param_mpc_z_vel_all
+		(ParamFloat<px4::params::MPC_Z_VEL_ALL>) _param_mpc_z_vel_all,
+		(ParamInt<px4::params::USER_ADD_REF>) _param_user_add_ref,
+		// (ParamFloat<px4::params::USER_STEP_R_AMP>) _param_step_roll_amp,
+		// (ParamFloat<px4::params::USER_STEP_P_AMP>) _param_step_pitch_amp,
+		(ParamFloat<px4::params::USER_STEP_TIME>) _param_step_ref_time,
+		(ParamInt<px4::params::USER_TEST_NUM>) _param_test_time
 	);

 	control::BlockDerivative _vel_x_deriv; /**< velocity derivative in x */
diff --git a/src/modules/mc_pos_control/PositionControl/ControlMath.cpp b/src/modules/mc_pos_control/PositionControl/ControlMath.cpp
index c540baca19..59bb27f04f 100644
--- a/src/modules/mc_pos_control/PositionControl/ControlMath.cpp
+++ b/src/modules/mc_pos_control/PositionControl/ControlMath.cpp
@@ -117,6 +117,10 @@ void bodyzToAttitude(Vector3f body_z, const float yaw_sp, vehicle_attitude_setpo
 	att_sp.roll_body = euler.phi();
 	att_sp.pitch_body = euler.theta();
 	att_sp.yaw_body = euler.psi();
+	//===================================
+	// float temp=euler.psi()-yaw_sp;
+	// PX4_INFO("yaw_sp:%8.4f\n", (double) yaw_sp);
+	// PX4_INFO("temp:%8.4f\n", (double) temp);
 }

 Vector2f constrainXY(const Vector2f &v0, const Vector2f &v1, const float &max)
diff --git a/src/modules/mc_pos_control/PositionControl/PositionControl.cpp b/src/modules/mc_pos_control/PositionControl/PositionControl.cpp
index caca1c85a4..3efd266a3c 100644
--- a/src/modules/mc_pos_control/PositionControl/PositionControl.cpp
+++ b/src/modules/mc_pos_control/PositionControl/PositionControl.cpp
@@ -86,6 +86,13 @@ void PositionControl::setInputSetpoint(const vehicle_local_position_setpoint_s &
 	_acc_sp = Vector3f(setpoint.acceleration);
 	_yaw_sp = setpoint.yaw;
 	_yawspeed_sp = setpoint.yawspeed;
+
+	// for (size_t i = 0; i < 3; i++)
+	// {
+	// 	PX4_INFO("_pos_sp(%ld): %f", i, (double) _pos_sp(i));
+	// 	PX4_INFO("_vel_sp(%ld): %f", i, (double) _vel_sp(i));
+	// 	PX4_INFO("_acc_sp(%ld): %f", i, (double) _acc_sp(i));
+	// }
 }

 bool PositionControl::update(const float dt)
@@ -94,7 +101,13 @@ bool PositionControl::update(const float dt)
 	const bool valid = (PX4_ISFINITE(_pos_sp(0)) == PX4_ISFINITE(_pos_sp(1)))
 			   && (PX4_ISFINITE(_vel_sp(0)) == PX4_ISFINITE(_vel_sp(1)))
 			   && (PX4_ISFINITE(_acc_sp(0)) == PX4_ISFINITE(_acc_sp(1)));
-
+	// PX4_INFO("valid: %f", (double) valid);
+	// for (size_t i = 0; i < 3; i++)
+	// {
+	// 	PX4_INFO("_pos_sp(%ld): %f", i, (double) _pos_sp(i));
+	// 	PX4_INFO("_vel_sp(%ld): %f", i, (double) _vel_sp(i));
+	// 	PX4_INFO("_acc_sp(%ld): %f", i, (double) _acc_sp(i));
+	// }
 	_positionControl();
 	_velocityControl(dt);

@@ -108,16 +121,60 @@ void PositionControl::_positionControl()
 {
 	// P-position controller
 	Vector3f vel_sp_position = (_pos_sp - _pos).emult(_gain_pos_p);
+	// PX4_INFO("==============_positionControl================= \n");
+	// PX4_INFO("_pos_sp 0: %f", (double) (_pos_sp(0)));
+	// PX4_INFO("_pos_sp 1: %f", (double) (_pos_sp(1)));
+	// PX4_INFO("_pos_sp 2: %f", (double) (_pos_sp(2)));
+	// PX4_INFO("1");
+	// for (size_t i = 0; i < 3; i++)
+	// {
+
+	// 	PX4_INFO("vel_sp_position(%ld): %f", i, (double) vel_sp_position(i));
+	// 	// PX4_INFO("_vel_sp(%ld): %f", i, (double) _vel_sp(i));
+	// }
 	// Position and feed-forward velocity setpoints or position states being NAN results in them not having an influence
+	// PX4_INFO("_vel_sp 0: %f", (double) (_vel_sp(0)));
+	// PX4_INFO("_vel_sp 1: %f", (double) (_vel_sp(1)));
+	// PX4_INFO("_vel_sp 2: %f", (double) (_vel_sp(2)));
+
+	// PX4_INFO("vel_sp_position 0: %f", (double) (vel_sp_position(0)));
+	// PX4_INFO("vel_sp_position 1: %f", (double) (vel_sp_position(1)));
+	// PX4_INFO("vel_sp_position 2: %f", (double) (vel_sp_position(2)));
+
 	ControlMath::addIfNotNanVector3f(_vel_sp, vel_sp_position);
+	// PX4_INFO("===============addIfNotNanVector3f================ \n");
+	// PX4_INFO("_vel_sp 0: %f", (double) (_vel_sp(0)));
+	// PX4_INFO("_vel_sp 1: %f", (double) (_vel_sp(1)));
+	// PX4_INFO("_vel_sp 2: %f", (double) (_vel_sp(2)));
+
+
+	// PX4_INFO("before");
+	// for (size_t i = 0; i < 3; i++)
+	// {
+
+	// 	PX4_INFO("vel_sp_position(%ld): %f", i, (double) vel_sp_position(i));
+	// 	PX4_INFO("_vel_sp(%ld): %f", i, (double) _vel_sp(i));
+	// }
 	// make sure there are no NAN elements for further reference while constraining
+
+
 	ControlMath::setZeroIfNanVector3f(vel_sp_position);
+	// PX4_INFO("==============setZeroIfNanVector3f================= \n");
+	// PX4_INFO("vel_sp_position 0: %f", (double) (vel_sp_position(0)));
+	// PX4_INFO("vel_sp_position 1: %f", (double) (vel_sp_position(1)));
+	// PX4_INFO("vel_sp_position 2: %f", (double) (vel_sp_position(2)));

 	// Constrain horizontal velocity by prioritizing the velocity component along the
 	// the desired position setpoint over the feed-forward term.
 	_vel_sp.xy() = ControlMath::constrainXY(vel_sp_position.xy(), (_vel_sp - vel_sp_position).xy(), _lim_vel_horizontal);
 	// Constrain velocity in z-direction.
 	_vel_sp(2) = math::constrain(_vel_sp(2), -_lim_vel_up, _lim_vel_down);
+	// PX4_INFO("===============_vel_sp constrain ================ \n");
+	// PX4_INFO("_vel_sp 0: %f", (double) (_vel_sp(0)));
+	// PX4_INFO("_vel_sp 1: %f", (double) (_vel_sp(1)));
+	// PX4_INFO("_vel_sp 2: %f", (double) (_vel_sp(2)));
+	// PX4_INFO("=============================== \n");
+
 }

 void PositionControl::_velocityControl(const float dt)
@@ -127,8 +184,24 @@ void PositionControl::_velocityControl(const float dt)
 	Vector3f acc_sp_velocity = vel_error.emult(_gain_vel_p) + _vel_int - _vel_dot.emult(_gain_vel_d);

 	// No control input from setpoints or corresponding states which are NAN
+	// PX4_INFO("==============_velocityControl================= \n");
+	// PX4_INFO("_acc_sp 0: %f", (double) (_acc_sp(0)));
+	// PX4_INFO("_acc_sp 1: %f", (double) (_acc_sp(1)));
+	// PX4_INFO("_acc_sp 2: %f", (double) (_acc_sp(2)));
+	// PX4_INFO("before acc_sp_velocity 0: %f", (double) (acc_sp_velocity(0)));
+	// PX4_INFO("before acc_sp_velocity 1: %f", (double) (acc_sp_velocity(1)));
+	// PX4_INFO("before acc_sp_velocity 2: %f", (double) (acc_sp_velocity(2)));
 	ControlMath::addIfNotNanVector3f(_acc_sp, acc_sp_velocity);
-
+	// PX4_INFO("===============addIfNotNanVector3f================ \n");
+	// PX4_INFO("_acc_sp 0: %f", (double) (_acc_sp(0)));
+	// PX4_INFO("_acc_sp 1: %f", (double) (_acc_sp(1)));
+	// PX4_INFO("_acc_sp 2: %f", (double) (_acc_sp(2)));
+
+	// for (size_t i = 0; i < 3; i++)
+	// {
+	// 	PX4_INFO("acc_sp_velocity(%ld): %f", i, (double) acc_sp_velocity(i));
+	// 	PX4_INFO("_acc_sp(%ld): %f", i, (double) _acc_sp(i));
+	// }
 	_accelerationControl();

 	// Integrator anti-windup in vertical direction
@@ -177,6 +250,10 @@ void PositionControl::_accelerationControl()
 {
 	// Assume standard acceleration due to gravity in vertical direction for attitude generation
 	Vector3f body_z = Vector3f(-_acc_sp(0), -_acc_sp(1), CONSTANTS_ONE_G).normalized();
+	// PX4_INFO("==============_accelerationControl================= \n");
+	// PX4_INFO("body_z 0: %f", (double) (body_z(0)));
+	// PX4_INFO("body_z 1: %f", (double) (body_z(1)));
+	// PX4_INFO("body_z 2: %f", (double) (body_z(2)));
 	ControlMath::limitTilt(body_z, Vector3f(0, 0, 1), _lim_tilt);
 	// Scale thrust assuming hover thrust produces standard gravity
 	float collective_thrust = _acc_sp(2) * (_hover_thrust / CONSTANTS_ONE_G) - _hover_thrust;
diff --git a/src/modules/mc_pos_control/mc_pos_control_params.c b/src/modules/mc_pos_control/mc_pos_control_params.c
index 46c5fb3946..f627cfeacb 100644
--- a/src/modules/mc_pos_control/mc_pos_control_params.c
+++ b/src/modules/mc_pos_control/mc_pos_control_params.c
@@ -698,8 +698,10 @@ PARAM_DEFINE_FLOAT(MPC_TKO_RAMP_T, 3.0f);
  * 4 Smooth position control where sticks map to acceleration and there's a virtual brake drag
  *
  * @value 0 Simple position control
+ * @value 1 MyTask position mode implementation
  * @value 3 Smooth position control (Jerk optimized)
  * @value 4 Acceleration based input
+
  * @group Multicopter Position Control
  */
 PARAM_DEFINE_INT32(MPC_POS_MODE, 4);
diff --git a/src/modules/mc_rate_control/CMakeLists.txt b/src/modules/mc_rate_control/CMakeLists.txt
index 758d56b7c8..fdb59f1be5 100644
--- a/src/modules/mc_rate_control/CMakeLists.txt
+++ b/src/modules/mc_rate_control/CMakeLists.txt
@@ -32,6 +32,7 @@
 ############################################################################

 add_subdirectory(RateControl)
+add_subdirectory(IndiControl)

 px4_add_module(
 	MODULE modules__mc_rate_control
@@ -41,9 +42,12 @@ px4_add_module(
 	SRCS
 		MulticopterRateControl.cpp
 		MulticopterRateControl.hpp
+
+
 	DEPENDS
 		circuit_breaker
 		mathlib
 		RateControl
+		IndiControl
 		px4_work_queue
 	)
diff --git a/src/modules/mc_rate_control/IndiControl/CMakeLists.txt b/src/modules/mc_rate_control/IndiControl/CMakeLists.txt
new file mode 100644
index 0000000000..9c12335df0
--- /dev/null
+++ b/src/modules/mc_rate_control/IndiControl/CMakeLists.txt
@@ -0,0 +1,42 @@
+############################################################################
+#
+#   Copyright (c) 2019 PX4 Development Team. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name PX4 nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+px4_add_library(IndiControl
+	IndiControl.cpp
+	IndiControl.hpp
+)
+target_compile_options(IndiControl PRIVATE ${MAX_CUSTOM_OPT_LEVEL})
+target_include_directories(IndiControl PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
+target_link_libraries(IndiControl PRIVATE mathlib)
+
+px4_add_unit_gtest(SRC IndiControlTest.cpp LINKLIBS IndiControl)
diff --git a/src/modules/mc_rate_control/IndiControl/IndiControl.cpp b/src/modules/mc_rate_control/IndiControl/IndiControl.cpp
new file mode 100644
index 0000000000..950eb895dd
--- /dev/null
+++ b/src/modules/mc_rate_control/IndiControl/IndiControl.cpp
@@ -0,0 +1,107 @@
+/****************************************************************************
+ *
+ *   Copyright (c) 2019 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file IndiControl.cpp
+ */
+
+#include <IndiControl.hpp>
+#include <px4_platform_common/defines.h>
+
+using namespace matrix;
+
+void IndiControl::setParams(const Vector3f &P, const float k)
+{
+	_gain_p = P;
+	_k=k;  // k =_k_cv*_k_v*_k_v
+	_B.setZero(); //= { {-46.2254,0.0,46.2254,0.0}, {0.0,-46.0825,0.0,46.0825},{46.7411,46.7411,46.7411,46.7411}};
+	_B(0, 0)=-_L_1*_k/_I_x;
+	_B(0, 2)=_L_1*_k/_I_x;
+	_B(1, 1)=-_L_1*_k/_I_y;
+	_B(1, 3)=_L_1*_k/_I_y;
+	_B(2, 0)=_L_2*_k/_I_z;
+	_B(2, 1)=_L_2*_k/_I_z;
+	_B(2, 2)=_L_2*_k/_I_z;
+	_B(2, 3)=_L_2*_k/_I_z;
+	// PX4_INFO("INDI is updated");
+
+}
+
+void IndiControl::init()
+{
+	// l1=0.167;l2=0.0698;k=3; % k*delta=F on cs
+	// I_x=0.00967;I_y=0.0097;I_z=0.00448;
+	// I=diag([I_x;I_y;I_z]);
+	// B=I\[-l1 0 l1 0;0 -l1 0 l1;l2 l2 l2 l2]*k;
+	// % B=[-l1*k/I_x 0 l1*k/I_x 0;0 -l1*k/I_y 0 l1*k/I_y;l2*k/I_z l2*k/I_z l2*k/I_z l2*k/I_z];
+	// % B=I\diag([2*l1;2*l1;4*l2])*k*[-0.5 0 0.5 0;0 -0.5 0 0.5;0.25 0.25 0.25 0.25];
+	// % [-0.5 0 0.5 0;0 -0.5 0 0.5;0.25 0.25 0.25 0.25]= piv([-1 0 1;0 -1 1;1 0 1;0 1 1])
+	// % I\[2*l1 0 0;0 2*l1 0;0 0 4*l2]*k is the different of gain, that is diag([92.4509;92.1649;186.9643])
+	_B.setZero(); //= { {-46.2254,0.0,46.2254,0.0}, {0.0,-46.0825,0.0,46.0825},{46.7411,46.7411,46.7411,46.7411}};
+	_B(0, 0)=-_L_1*_k/_I_x;
+	_B(0, 2)=_L_1*_k/_I_x;
+	_B(1, 1)=-_L_1*_k/_I_y;
+	_B(1, 3)=_L_1*_k/_I_y;
+	_B(2, 0)=_L_2*_k/_I_z;
+	_B(2, 1)=_L_2*_k/_I_z;
+	_B(2, 2)=_L_2*_k/_I_z;
+	_B(2, 3)=_L_2*_k/_I_z;
+	// PX4_INFO("_B");
+	// _B.print();
+}
+
+Vector3f IndiControl::update(const Vector3f &rate, const Vector3f &rate_sp, const Vector3f &angular_accel,
+			     const float dt, const actuator_outputs_value_s &actuator_outputs_value, Vector3f &Nu_i, const bool landed, bool use_u, bool use_tau_i)
+{
+	// angular rates error
+	Vector3f rate_error = rate_sp - rate;
+
+	if (landed || !use_tau_i) {
+		Nu_i.setZero();
+		// PX4_INFO("Nu_i of INDI is zero");
+	}
+	else
+	{
+		Matrix<float, 4, 1> delta_0 (actuator_outputs_value.delta);
+		if(use_u) {
+			Nu_i = _B * delta_0 - angular_accel;
+		}
+		else {
+			Nu_i =  - angular_accel;
+		}
+
+	}
+	Vector3f K =  _gain_p; // by diag([92.4509;92.1649;186.9643]), using the same as PID param
+	Vector3f Nu_f= K.emult(rate_error);
+	return Nu_f;
+}
diff --git a/src/modules/mc_rate_control/IndiControl/IndiControl.hpp b/src/modules/mc_rate_control/IndiControl/IndiControl.hpp
new file mode 100644
index 0000000000..1e70539cb6
--- /dev/null
+++ b/src/modules/mc_rate_control/IndiControl/IndiControl.hpp
@@ -0,0 +1,93 @@
+/****************************************************************************
+ *
+ *   Copyright (c) 2019 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/**
+ * @file IndiControl.hpp
+ *
+ * PID 3 axis angular rate / angular velocity control.
+ */
+
+#pragma once
+
+#include <matrix/matrix/math.hpp>
+// #include <mathlib/math/filter/LowPassFilter2pVector3f.hpp>
+
+#include <lib/mixer/MultirotorMixer/MultirotorMixer.hpp>
+#include <uORB/topics/rate_ctrl_status.h>
+#include <uORB/topics/actuator_outputs_value.h>
+#include <px4_platform_common/defines.h>
+
+class IndiControl
+{
+public:
+	IndiControl() = default;
+	~IndiControl() = default;
+
+	/**
+	 * Set the rate control gains
+	 * @param P 3D vector of proportional gains for body x,y,z axis
+	 * @param k
+	 */
+	void setParams(const matrix::Vector3f &P, const float k);
+
+	void init();
+
+	/**
+	 * Run one control loop cycle calculation
+	 * @param rate estimation of the current vehicle angular rate
+	 * @param rate_sp desired vehicle angular rate setpoint
+	 * @param dt desired vehicle angular rate setpoint
+	 * @param actuator_outputs_value current value of actuators
+	 * @param Nu_i second term of virtual control
+	 * @param use_u use u0 or not
+	 * @param use_tau_i use Nu_i or not
+	 * @return [-1,1] normalized torque vector to apply to the vehicle //This is not a value between -1 and +1
+	 */
+	matrix::Vector3f update(const matrix::Vector3f &rate, const matrix::Vector3f &rate_sp, const matrix::Vector3f &angular_accel,
+			     const float dt, const actuator_outputs_value_s &actuator_outputs_value, matrix::Vector3f &Nu_i, const bool landed, bool use_u, bool use_tau_i);
+
+private:
+
+	// Gains
+	matrix::Vector3f _gain_p; ///< rate control proportional gain for all axes x, y, z
+	//I of prop
+	float _I_prop{0.000037f};// ignore
+	float _I_x{0.01149};//setting in the .sdf
+	float _I_y{0.01153};//setting in the .sdf
+	float _I_z{0.004865};//setting in the .sdf
+	float _L_1{0.167f}; //setting in the .sdf
+	float _L_2{0.0698}; //setting in the .sdf
+	float _k{3.0f};	// USER_OMEGA_2_F, k  =_k_cv*_k_v*_k_v, setting k in the gazebo
+
+	matrix::Matrix<float, 3, 4> _B;
+};
diff --git a/src/modules/mc_rate_control/IndiControl/IndiControlTest.cpp b/src/modules/mc_rate_control/IndiControl/IndiControlTest.cpp
new file mode 100644
index 0000000000..3311e6eeb6
--- /dev/null
+++ b/src/modules/mc_rate_control/IndiControl/IndiControlTest.cpp
@@ -0,0 +1,44 @@
+/****************************************************************************
+ *
+ *   Copyright (C) 2019 PX4 Development Team. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name PX4 nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+#include <gtest/gtest.h>
+#include <IndiControl.hpp>
+
+using namespace matrix;
+
+TEST(IndiControlTest, AllZeroCase)
+{
+	IndiControl rate_control;
+	Vector3f torque = rate_control.update(Vector3f(), Vector3f(), Vector3f(), 0.f, false);
+	EXPECT_EQ(torque, Vector3f());
+}
diff --git a/src/modules/mc_rate_control/MulticopterRateControl.cpp b/src/modules/mc_rate_control/MulticopterRateControl.cpp
index 4e907fc4d2..2795d5eb02 100644
--- a/src/modules/mc_rate_control/MulticopterRateControl.cpp
+++ b/src/modules/mc_rate_control/MulticopterRateControl.cpp
@@ -66,6 +66,8 @@ MulticopterRateControl::init()
 		return false;
 	}

+	_indi_control.init();
+
 	return true;
 }

@@ -75,12 +77,31 @@ MulticopterRateControl::parameters_updated()
 	// rate control parameters
 	// The controller gain K is used to convert the parallel (P + I/s + sD) form
 	// to the ideal (K * [1 + 1/sTi + sTd]) form
+	// const Vector3f torque_convert_acc=Vector3f(0.3491f*2*43.6031, 0.3491f*2*43.4519, 0.3491f*4*42.5051); // 92.4509f since B_inv, 0.3491f since unit (outputs[i+4] = (_u[i])/0.3491f;).
+
+	// for example, for default PID in roll channel, INDI_roll_p=PID_rollrate_p*0.3491f* 2*43.6031=PID_rollrate_p*30.44. ntrol=_param_mc_rollrate_p*error= B'*delta' = 2*43.6031\B*delta/0.3491=92.4509\INDI_control/0.3491, where B*delta=INDI_control. such that,
+	// INDI_roll_p=_param_mc_rollrate_p*0.3491f* 2*43.6031=_param_mc_rollrate_p*30.44.
+	// INDI_pitch_p=_param_mc_pitchrate_p*0.3491f*2*43.4519=_param_mc_pitchrate_p*30.33.
+	// INDI_yaw_p=_param_mc_yawrate_p*0.3491f*4*42.5051=_param_mc_yawrate_p*59.35.
 	const Vector3f rate_k = Vector3f(_param_mc_rollrate_k.get(), _param_mc_pitchrate_k.get(), _param_mc_yawrate_k.get());

-	_rate_control.setGains(
-		rate_k.emult(Vector3f(_param_mc_rollrate_p.get(), _param_mc_pitchrate_p.get(), _param_mc_yawrate_p.get())),
-		rate_k.emult(Vector3f(_param_mc_rollrate_i.get(), _param_mc_pitchrate_i.get(), _param_mc_yawrate_i.get())),
-		rate_k.emult(Vector3f(_param_mc_rollrate_d.get(), _param_mc_pitchrate_d.get(), _param_mc_yawrate_d.get())));
+	_indi_control.setParams(Vector3f(_param_mc_indiroll_p.get(), _param_mc_indipitch_p.get(), _param_mc_indiyaw_p.get()),  _param_omega_2_force.get());
+
+	_use_indi=_param_use_indi.get();
+	_use_tau_i=_param_use_tau_i.get();
+	_use_u=_param_use_u.get();
+
+	// if (_param_use_control_alloc.get() == 1)
+	// 	_rate_control.setGains(
+	// 		torque_convert_acc.emult(rate_k.emult(Vector3f(_param_mc_rollrate_p.get(), _param_mc_pitchrate_p.get(), _param_mc_yawrate_p.get()))),
+	// 		torque_convert_acc.emult(rate_k.emult(Vector3f(_param_mc_rollrate_i.get(), _param_mc_pitchrate_i.get(), _param_mc_yawrate_i.get()))),
+	// 		torque_convert_acc.emult(rate_k.emult(Vector3f(_param_mc_rollrate_d.get(), _param_mc_pitchrate_d.get(), _param_mc_yawrate_d.get()))));
+
+	// else
+		_rate_control.setGains(
+			rate_k.emult(Vector3f(_param_mc_rollrate_p.get(), _param_mc_pitchrate_p.get(), _param_mc_yawrate_p.get())),
+			rate_k.emult(Vector3f(_param_mc_rollrate_i.get(), _param_mc_pitchrate_i.get(), _param_mc_yawrate_i.get())),
+			rate_k.emult(Vector3f(_param_mc_rollrate_d.get(), _param_mc_pitchrate_d.get(), _param_mc_yawrate_d.get())));

 	_rate_control.setIntegratorLimit(
 		Vector3f(_param_mc_rr_int_lim.get(), _param_mc_pr_int_lim.get(), _param_mc_yr_int_lim.get()));
@@ -120,6 +141,29 @@ MulticopterRateControl::Run()
 	/* run controller on gyro changes */
 	vehicle_angular_velocity_s angular_velocity;

+	// 上是-1
+	// channels[6]:  -1	0	1	= yaw step  // 7通道右上角
+	// 9-12通道在正面
+	// channels[8]:  -1	0       1	=servo disturb
+	// channels[9]:  -1	0       1	=
+	// channels[10]: -1	0       1	=
+	// channels[11]: -1	0       1	=pid or indi
+	if (_rc_channels_sub.update(&_rc_channels))
+	{
+		// PX4_INFO("Hello rc! 7:%f. 9:%f. 10:%f. 11:%f. 12:%f.", (double) _rc_channels.channels[6], (double) _rc_channels.channels[8], (double) _rc_channels.channels[9], (double) _rc_channels.channels[10], (double) _rc_channels.channels[11]);
+		if (_rc_channels.channels[11] < 0.f)
+		{
+			_rc_indi_flag = false;
+			// PX4_INFO("PID !");
+		}
+		else
+		{
+			_rc_indi_flag = true;
+			// PX4_INFO("indi  !");
+		}
+	}
+
+
 	if (_vehicle_angular_velocity_sub.update(&angular_velocity)) {

 		// grab corresponding vehicle_angular_acceleration immediately after vehicle_angular_velocity copy
@@ -135,6 +179,8 @@ MulticopterRateControl::Run()
 		const Vector3f angular_accel{v_angular_acceleration.xyz};
 		const Vector3f rates{angular_velocity.xyz};

+
+
 		/* check for updates in other topics */
 		_v_control_mode_sub.update(&_v_control_mode);

@@ -175,6 +221,7 @@ MulticopterRateControl::Run()

 				// publish rate setpoint
 				vehicle_rates_setpoint_s v_rates_sp{};
+
 				v_rates_sp.roll = _rates_sp(0);
 				v_rates_sp.pitch = _rates_sp(1);
 				v_rates_sp.yaw = _rates_sp(2);
@@ -218,8 +265,46 @@ MulticopterRateControl::Run()
 				}
 			}

+			Vector3f indi_fb(0.f,0.f,0.f);
+			Vector3f att_control(0.f,0.f,0.f);
+			Vector3f error_fb(0.f,0.f,0.f);
+			_actuator_outputs_value_sub.update(&_actuator_outputs_value);
+			float indi_dt=0.0f;
+			bool control_flag=false;
 			// run rate controller
-			const Vector3f att_control = _rate_control.update(rates, _rates_sp, angular_accel, dt, _maybe_landed || _landed);
+			hrt_abstime timestamp_ca_start = hrt_absolute_time();
+			// 两个标志位共同使能，要使遥控器控制，参数必须使用默认值。
+			if (_use_indi == 1 || _rc_indi_flag)// ang_acc, have to be use with AC
+			{
+				const hrt_abstime now_temp = hrt_absolute_time();
+				indi_dt = math::constrain((now_temp - _time_last_dt_update_multicopter) / 1e6f, 0.0001f, 0.02f);
+				_time_last_dt_update_multicopter = now_temp;
+				// if (_maybe_landed || _landed)
+				// {
+				// 	att_control = _rate_control.update(rates, _rates_sp, angular_accel, dt, _maybe_landed || _landed);
+				// 	// PX4_INFO("_landed PID");
+				// }
+				// else
+				// {
+					_rate_control.resetIntegral();
+					error_fb = _indi_control.update(rates, _rates_sp, angular_accel, dt, _actuator_outputs_value, indi_fb, _maybe_landed || _landed,  _use_u, _use_tau_i);
+					// if (_use_tau_i)
+						att_control = error_fb + indi_fb;
+					// else
+					// 	att_control = error_fb;
+					// PX4_INFO("INDI");
+				// }
+				control_flag=true;
+			}
+			else
+			{
+				att_control = _rate_control.update(rates, _rates_sp, angular_accel, dt, _maybe_landed || _landed);
+
+				// PX4_INFO("PID");
+				control_flag=false;
+			}
+			hrt_abstime timestamp_ca_end = hrt_absolute_time();
+			_rate_control_running_time_us = (timestamp_ca_end - timestamp_ca_start); //us

 			// publish rate controller status
 			rate_ctrl_status_s rate_ctrl_status{};
@@ -229,12 +314,24 @@ MulticopterRateControl::Run()

 			// publish actuator controls
 			actuator_controls_s actuators{};
+
+			actuators.control_flag=control_flag;
+			actuators.indi_fb[actuator_controls_s::INDEX_ROLL] = PX4_ISFINITE(indi_fb(0)) ? indi_fb(0) : 0.0f;
+			actuators.indi_fb[actuator_controls_s::INDEX_PITCH] = PX4_ISFINITE(indi_fb(1)) ? indi_fb(1) : 0.0f;
+			actuators.indi_fb[actuator_controls_s::INDEX_YAW] = PX4_ISFINITE(indi_fb(2)) ? indi_fb(2) : 0.0f;
+
+			actuators.error_fb[actuator_controls_s::INDEX_ROLL] = PX4_ISFINITE(error_fb(0)) ? error_fb(0) : 0.0f;
+			actuators.error_fb[actuator_controls_s::INDEX_PITCH] = PX4_ISFINITE(error_fb(1)) ? error_fb(1) : 0.0f;
+			actuators.error_fb[actuator_controls_s::INDEX_YAW] = PX4_ISFINITE(error_fb(2)) ? error_fb(2) : 0.0f;
+
 			actuators.control[actuator_controls_s::INDEX_ROLL] = PX4_ISFINITE(att_control(0)) ? att_control(0) : 0.0f;
 			actuators.control[actuator_controls_s::INDEX_PITCH] = PX4_ISFINITE(att_control(1)) ? att_control(1) : 0.0f;
 			actuators.control[actuator_controls_s::INDEX_YAW] = PX4_ISFINITE(att_control(2)) ? att_control(2) : 0.0f;
 			actuators.control[actuator_controls_s::INDEX_THROTTLE] = PX4_ISFINITE(_thrust_sp) ? _thrust_sp : 0.0f;
 			actuators.control[actuator_controls_s::INDEX_LANDING_GEAR] = _landing_gear;
 			actuators.timestamp_sample = angular_velocity.timestamp_sample;
+			actuators.indi_dt=indi_dt;
+			actuators.rate_control_running_time=_rate_control_running_time_us;

 			// scale effort by battery status if enabled
 			if (_param_mc_bat_scale_en.get()) {
@@ -253,6 +350,7 @@ MulticopterRateControl::Run()
 				}
 			}

+
 			actuators.timestamp = hrt_absolute_time();
 			_actuators_0_pub.publish(actuators);

@@ -263,6 +361,7 @@ MulticopterRateControl::Run()
 				actuators.timestamp = hrt_absolute_time();
 				_actuators_0_pub.publish(actuators);
 			}
+
 		}
 	}

diff --git a/src/modules/mc_rate_control/MulticopterRateControl.hpp b/src/modules/mc_rate_control/MulticopterRateControl.hpp
index 531b1e435b..cd4cf7bd60 100644
--- a/src/modules/mc_rate_control/MulticopterRateControl.hpp
+++ b/src/modules/mc_rate_control/MulticopterRateControl.hpp
@@ -34,6 +34,7 @@
 #pragma once

 #include <RateControl.hpp>
+#include <IndiControl.hpp>

 #include <lib/matrix/matrix/math.hpp>
 #include <lib/perf/perf_counter.h>
@@ -53,13 +54,14 @@
 #include <uORB/topics/multirotor_motor_limits.h>
 #include <uORB/topics/parameter_update.h>
 #include <uORB/topics/rate_ctrl_status.h>
+#include <uORB/topics/actuator_outputs_value.h>
 #include <uORB/topics/vehicle_angular_acceleration.h>
 #include <uORB/topics/vehicle_angular_velocity.h>
 #include <uORB/topics/vehicle_control_mode.h>
 #include <uORB/topics/vehicle_land_detected.h>
 #include <uORB/topics/vehicle_rates_setpoint.h>
 #include <uORB/topics/vehicle_status.h>
-
+#include <uORB/topics/rc_channels.h>
 using namespace time_literals;

 class MulticopterRateControl : public ModuleBase<MulticopterRateControl>, public ModuleParams, public px4::WorkItem
@@ -88,6 +90,7 @@ private:
 	void		parameters_updated();

 	RateControl _rate_control; ///< class for rate control calculations
+	IndiControl _indi_control;

 	uORB::Subscription _battery_status_sub{ORB_ID(battery_status)};
 	uORB::Subscription _landing_gear_sub{ORB_ID(landing_gear)};
@@ -96,6 +99,7 @@ private:
 	uORB::Subscription _v_control_mode_sub{ORB_ID(vehicle_control_mode)};
 	uORB::Subscription _v_rates_sp_sub{ORB_ID(vehicle_rates_setpoint)};
 	uORB::Subscription _vehicle_angular_acceleration_sub{ORB_ID(vehicle_angular_acceleration)};
+	uORB::Subscription _actuator_outputs_value_sub{ORB_ID(actuator_outputs_value)};
 	uORB::Subscription _vehicle_land_detected_sub{ORB_ID(vehicle_land_detected)};
 	uORB::Subscription _vehicle_status_sub{ORB_ID(vehicle_status)};

@@ -113,9 +117,20 @@ private:
 	bool _actuators_0_circuit_breaker_enabled{false};	/**< circuit breaker to suppress output */
 	bool _landed{true};
 	bool _maybe_landed{true};
+	hrt_abstime _time_last_dt_update_multicopter{0};
+	hrt_abstime _rate_control_running_time_us{0};
+	actuator_outputs_value_s _actuator_outputs_value{};
+	// bool _actuator_outputs_sub_flag{false};
+	bool _use_indi{false};
+	bool _use_tau_i{true};
+	bool _use_u{true};
+	uORB::Subscription _rc_channels_sub{ORB_ID(rc_channels)};
+	rc_channels_s		_rc_channels{};
+	bool _rc_indi_flag{false};

 	float _battery_status_scale{0.0f};

+
 	perf_counter_t	_loop_perf;			/**< loop duration performance counter */

 	matrix::Vector3f _rates_sp;			/**< angular rates setpoint */
@@ -160,7 +175,17 @@ private:

 		(ParamBool<px4::params::MC_BAT_SCALE_EN>) _param_mc_bat_scale_en,

-		(ParamInt<px4::params::CBRK_RATE_CTRL>) _param_cbrk_rate_ctrl
+		(ParamInt<px4::params::CBRK_RATE_CTRL>) _param_cbrk_rate_ctrl,
+
+		(ParamFloat<px4::params::USER_OMEGA_2_F>) _param_omega_2_force,
+		(ParamFloat<px4::params::USER_INDI_R_P>) _param_mc_indiroll_p,
+		(ParamFloat<px4::params::USER_INDI_P_P>) _param_mc_indipitch_p,
+		(ParamFloat<px4::params::USER_INDI_Y_P>) _param_mc_indiyaw_p,
+		(ParamInt<px4::params::USER_USE_INDI>) _param_use_indi,
+		(ParamInt<px4::params::USER_PID_CA>) _param_use_control_alloc,
+		(ParamInt<px4::params::USER_USE_TAUI>) _param_use_tau_i,
+		(ParamInt<px4::params::USER_USE_U>) _param_use_u
+
 	)

 	matrix::Vector3f _acro_rate_max;	/**< max attitude rates in acro mode */
diff --git a/src/modules/mc_rate_control/RateControl/RateControl.hpp b/src/modules/mc_rate_control/RateControl/RateControl.hpp
index a39dabb194..28f4952c8f 100644
--- a/src/modules/mc_rate_control/RateControl/RateControl.hpp
+++ b/src/modules/mc_rate_control/RateControl/RateControl.hpp
@@ -82,7 +82,7 @@ public:
 	 * @param rate estimation of the current vehicle angular rate
 	 * @param rate_sp desired vehicle angular rate setpoint
 	 * @param dt desired vehicle angular rate setpoint
-	 * @return [-1,1] normalized torque vector to apply to the vehicle
+	 * @return [-1,1] normalized torque vector to apply to the vehicle //This is not a value between -1 and +1
 	 */
 	matrix::Vector3f update(const matrix::Vector3f &rate, const matrix::Vector3f &rate_sp,
 				const matrix::Vector3f &angular_accel, const float dt, const bool landed);
diff --git a/src/modules/mc_rate_control/mc_rate_control_params.c b/src/modules/mc_rate_control/mc_rate_control_params.c
index 4bc092db60..b7d65f4d6f 100644
--- a/src/modules/mc_rate_control/mc_rate_control_params.c
+++ b/src/modules/mc_rate_control/mc_rate_control_params.c
@@ -398,3 +398,84 @@ PARAM_DEFINE_FLOAT(MC_ACRO_SUPEXPOY, 0.7f);
  * @group Multicopter Rate Control
  */
 PARAM_DEFINE_INT32(MC_BAT_SCALE_EN, 0);
+
+/**
+ * k
+ *
+ * delta_2_force.
+ *
+ * @min 0.0
+ * @max 10
+ * @decimal 3
+ * @increment 0.001
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_FLOAT(USER_OMEGA_2_F, 3.0f);//
+
+/**
+ * Roll rate P gain of INDI
+ *
+ * Roll rate proportional gain, i.e. control output for angular speed error 1 rad/s.
+ *
+ * @min 0.1
+ * @max 30
+ * @decimal 3
+ * @increment 0.001
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_FLOAT(USER_INDI_R_P, 10.f);
+
+/**
+ * Pitch rate P gain of INDI
+ *
+ * Pitch rate proportional gain, i.e. control output for angular speed error 1 rad/s.
+ *
+ * @min 0.1
+ * @max 30
+ * @decimal 3
+ * @increment 0.001
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_FLOAT(USER_INDI_P_P, 10.f);
+
+/**
+ * Yaw rate P gain of INDI
+ *
+ * Yaw rate proportional gain, i.e. control output for angular speed error 1 rad/s.
+ *
+ * @min 0.0
+ * @max 30
+ * @decimal 3
+ * @increment 0.001
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_FLOAT(USER_INDI_Y_P, 10.f);
+
+/**
+ * USER_USE_INDI
+ *
+ * use INDI control or not.
+ *
+ * @value 0 PID
+ * @value 1 INDI
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_INT32(USER_USE_INDI, 0);
+
+/**
+ * use tau_i.
+ *
+ * @value 0 just use error fb.
+ * @value 1 use indi fb
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_INT32(USER_USE_TAUI, 1);
+
+/**
+ * use u_0.
+ *
+ * @value 0 remove u_0, just use y^(/rho)_0.
+ * @value 1 use u_0
+ * @group Multicopter Rate Control
+ */
+PARAM_DEFINE_INT32(USER_USE_U, 1);
diff --git a/src/modules/sensors/vehicle_angular_velocity/VehicleAngularVelocity.cpp b/src/modules/sensors/vehicle_angular_velocity/VehicleAngularVelocity.cpp
index 475a5d7ff3..daff55c713 100644
--- a/src/modules/sensors/vehicle_angular_velocity/VehicleAngularVelocity.cpp
+++ b/src/modules/sensors/vehicle_angular_velocity/VehicleAngularVelocity.cpp
@@ -619,7 +619,7 @@ float VehicleAngularVelocity::FilterAngularVelocity(int axis, float data[], int
 	// Apply general low-pass filter (IMU_GYRO_CUTOFF)
 	_lp_filter_velocity[axis].applyArray(data, N);

-	// return last filtered sample
+	// return last filtered sample  //???
 	return data[N - 1];
 }

@@ -788,6 +788,8 @@ void VehicleAngularVelocity::PrintStatus()
 		 _selected_sensor_device_id, (double)_filter_sample_rate_hz, _fifo_available ? "FIFO" : "");
 	PX4_INFO("estimated bias: [%.4f %.4f %.4f]", (double)_bias(0), (double)_bias(1), (double)_bias(2));

+	PX4_INFO("_publish_interval_min_us: %" PRIu64 "us \n", _publish_interval_min_us);
+
 	_calibration.PrintStatus();
 }

diff --git a/src/modules/simulator/simulator_mavlink.cpp b/src/modules/simulator/simulator_mavlink.cpp
index 1dc01db12a..b868c3f495 100644
--- a/src/modules/simulator/simulator_mavlink.cpp
+++ b/src/modules/simulator/simulator_mavlink.cpp
@@ -161,7 +161,7 @@ void Simulator::actuator_controls_from_outputs(mavlink_hil_actuator_controls_t *
 		} else {
 			const float pwm_center = (PWM_DEFAULT_MAX + PWM_DEFAULT_MIN) / 2;
 			const float pwm_delta = (PWM_DEFAULT_MAX - PWM_DEFAULT_MIN) / 2;
-
+			// important
 			/* scale PWM out PWM_DEFAULT_MIN..PWM_DEFAULT_MAX us to -1..1 for other channels */
 			msg->controls[i] = (_actuator_outputs.output[i] - pwm_center) / pwm_delta;
 			msg->controls[i] = math::constrain(msg->controls[i], -1.f, 1.f);
diff --git a/src/systemcmds/tests/test_matrix.cpp b/src/systemcmds/tests/test_matrix.cpp
index b3b8021274..b7bc519040 100644
--- a/src/systemcmds/tests/test_matrix.cpp
+++ b/src/systemcmds/tests/test_matrix.cpp
@@ -776,7 +776,8 @@ bool MatrixTest::pseudoInverseTests()
 				};

 	Matrix<float, 3, 4> A0(data0);
-	Matrix<float, 4, 3> A0_I = geninv(A0);
+	Matrix<float, 4, 3> A0_I;
+	geninv(A0, A0_I);
 	Matrix<float, 4, 3> A0_I_check(data0_check);

 	ut_test((A0_I - A0_I_check).abs().max() < 1e-5);
@@ -795,7 +796,8 @@ bool MatrixTest::pseudoInverseTests()
 				};

 	Matrix<float, 4, 3> A1(data1);
-	Matrix<float, 3, 4> A1_I = geninv(A1);
+	Matrix<float, 3, 4> A1_I;
+	geninv(A1, A1_I);
 	Matrix<float, 3, 4> A1_I_check(data1_check);

 	ut_test((A1_I - A1_I_check).abs().max() < 1e-5);
@@ -845,7 +847,8 @@ bool MatrixTest::pseudoInverseTests()
 		{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}
 	};
 	Matrix<float, 16, 6> A_check(A_quad_w);
-	Matrix<float, 16, 6> A = geninv(B);
+	Matrix<float, 16, 6> A;
+	geninv(B, A);
 	ut_test((A - A_check).abs().max() < 1e-5);

 	return true;
diff --git a/src/systemcmds/tests/test_microbench_matrix.cpp b/src/systemcmds/tests/test_microbench_matrix.cpp
index deec4e0233..290a6cf25c 100644
--- a/src/systemcmds/tests/test_microbench_matrix.cpp
+++ b/src/systemcmds/tests/test_microbench_matrix.cpp
@@ -170,8 +170,8 @@ bool MicroBenchMatrix::time_matrix_dcm()

 bool MicroBenchMatrix::time_matrix_pseduo_inverse()
 {
-	PERF("matrix 6x16 pseudo inverse (all non-zero columns)", A16 = matrix::geninv(B16), 100);
-	PERF("matrix 6x16 pseudo inverse (4 non-zero columns)", A16 = matrix::geninv(B16_4), 100);
+	PERF("matrix 6x16 pseudo inverse (all non-zero columns)", matrix::geninv(B16, A16), 100);
+	PERF("matrix 6x16 pseudo inverse (4 non-zero columns)", matrix::geninv(B16_4, A16), 100);
 	return true;
 }

